import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-EQYUJS47.js";

// ../../node_modules/@vechain/connex/dist/connex.js
var require_connex = __commonJS({
  "../../node_modules/@vechain/connex/dist/connex.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else {
        var a = factory();
        for (var i in a)
          (typeof exports === "object" ? exports : root)[i] = a[i];
      }
    })(self, function() {
      return (
        /******/
        (() => {
          var __webpack_modules__ = {
            /***/
            280: (
              /***/
              (__unused_webpack_module, __webpack_exports__, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__);
                __webpack_require__2.d(__webpack_exports__, {
                  "Connex": () => (
                    /* binding */
                    ConnexClass
                  ),
                  "default": () => (
                    /* binding */
                    esm
                  )
                });
                var abi_coder = __webpack_require__2(2046);
                var sha3 = __webpack_require__2(747);
                var Buffer = __webpack_require__2(8764)["Buffer"];
                function keccak256(...data) {
                  const h = sha3.keccak_256.create();
                  data.forEach((d) => {
                    if (Buffer.isBuffer(d)) {
                      h.update(d);
                    } else {
                      h.update(Buffer.from(d, "utf8"));
                    }
                  });
                  return Buffer.from(h.digest());
                }
                var abi_Buffer = __webpack_require__2(8764)["Buffer"];
                class Coder extends abi_coder.AbiCoder {
                  constructor() {
                    super((type, value) => {
                      if (type.match(/^u?int/) && !Array.isArray(value) && typeof value !== "object" || value._ethersType === "BigNumber") {
                        return value.toString();
                      }
                      return value;
                    });
                  }
                  encode(types, values) {
                    try {
                      return super.encode(types, values);
                    } catch (err) {
                      if (err.reason) {
                        throw new Error(err.reason);
                      }
                      throw err;
                    }
                  }
                  decode(types, data) {
                    try {
                      return super.decode(types, data);
                    } catch (err) {
                      if (err.reason) {
                        throw new Error(err.reason);
                      }
                      throw err;
                    }
                  }
                }
                const coder = new Coder();
                function formatSignature(fragment) {
                  try {
                    return (0, abi_coder.formatSignature)(fragment).replace(/\(tuple\(/g, "((").replace(/\,tuple\(/g, ",(");
                  } catch (err) {
                    if (err.reason) {
                      throw new Error(err.reason);
                    }
                    throw err;
                  }
                }
                var abi;
                (function(abi2) {
                  function encodeParameter(type, value) {
                    return coder.encode([type], [value]);
                  }
                  abi2.encodeParameter = encodeParameter;
                  function decodeParameter(type, data) {
                    return coder.decode([type], data)[0];
                  }
                  abi2.decodeParameter = decodeParameter;
                  function encodeParameters(types, values) {
                    return coder.encode(types, values);
                  }
                  abi2.encodeParameters = encodeParameters;
                  function decodeParameters(types, data) {
                    const result = coder.decode(types, data);
                    const decoded = {};
                    types.forEach((t, i) => {
                      decoded[i] = result[i];
                      if (t.name) {
                        decoded[t.name] = result[i];
                      }
                    });
                    return decoded;
                  }
                  abi2.decodeParameters = decodeParameters;
                  class Function2 {
                    /**
                     * create a function object
                     * @param definition abi definition of the function
                     */
                    constructor(definition) {
                      this.definition = definition;
                      this.canonicalName = formatSignature(definition);
                      this.signature = "0x" + keccak256(this.canonicalName).slice(0, 4).toString("hex");
                    }
                    /**
                     * encode input parameters into call data
                     * @param args arguments for the function
                     */
                    encode(...args) {
                      return this.signature + encodeParameters(this.definition.inputs, args).slice(2);
                    }
                    /**
                     * decode output data
                     * @param outputData output data to decode
                     */
                    decode(outputData) {
                      return decodeParameters(this.definition.outputs, outputData);
                    }
                  }
                  abi2.Function = Function2;
                  class Event {
                    /** for contract event */
                    constructor(definition) {
                      this.definition = definition;
                      this.canonicalName = formatSignature(definition);
                      this.signature = "0x" + keccak256(this.canonicalName).toString("hex");
                    }
                    /**
                     * encode an object of indexed keys into topics.
                     * @param indexed an object contains indexed keys
                     */
                    encode(indexed) {
                      const topics = [];
                      if (!this.definition.anonymous) {
                        topics.push(this.signature);
                      }
                      for (const input of this.definition.inputs) {
                        if (!input.indexed) {
                          continue;
                        }
                        const value = indexed[input.name];
                        if (value === void 0 || value === null) {
                          topics.push(null);
                        } else {
                          let topic;
                          if (isValueType(input.type)) {
                            topic = encodeParameter(input.type, value);
                          } else {
                            if (input.type === "string") {
                              topic = "0x" + keccak256(value).toString("hex");
                            } else if (typeof value === "string" && /^0x[0-9a-f]+$/i.test(value) && value.length % 2 === 0) {
                              topic = "0x" + keccak256(abi_Buffer.from(value.slice(2), "hex")).toString("hex");
                            } else {
                              throw new Error(`event.encode: invalid ${input.type} value`);
                            }
                          }
                          topics.push(topic);
                        }
                      }
                      return topics;
                    }
                    /**
                     * decode event log
                     * @param data data in event output
                     * @param topics topics in event
                     */
                    decode(data, topics) {
                      if (!this.definition.anonymous) {
                        topics = topics.slice(1);
                      }
                      if (this.definition.inputs.filter((t) => t.indexed).length !== topics.length) {
                        throw new Error("invalid topics count");
                      }
                      const decodedNonIndexed = coder.decode(this.definition.inputs.filter((t) => !t.indexed), data);
                      const decoded = {};
                      this.definition.inputs.forEach((t, i) => {
                        if (t.indexed) {
                          const topic = topics.shift();
                          decoded[i] = isValueType(t.type) ? decodeParameter(t.type, topic) : topic;
                        } else {
                          decoded[i] = decodedNonIndexed.shift();
                        }
                        if (t.name) {
                          decoded[t.name] = decoded[i];
                        }
                      });
                      return decoded;
                    }
                  }
                  abi2.Event = Event;
                  function isValueType(type) {
                    return type === "address" || type === "bool" || /^(u?int)([0-9]*)$/.test(type) || /^bytes([0-9]+)$/.test(type);
                  }
                })(abi || (abi = {}));
                const errorSelector = "0x" + keccak256("Error(string)").toString("hex").slice(0, 8);
                const panicSelector = "0x" + keccak256("Panic(uint256)").toString("hex").slice(0, 8);
                function decodeRevertReason(data) {
                  try {
                    if (data.startsWith(errorSelector)) {
                      return abi.decodeParameter("string", "0x" + data.slice(errorSelector.length));
                    } else if (data.startsWith(panicSelector)) {
                      const decoded = abi.decodeParameter("uint256", "0x" + data.slice(panicSelector.length));
                      return `Panic(0x${parseInt(decoded).toString(16).padStart(2, "0")})`;
                    }
                    return "";
                  } catch (_a) {
                    return "";
                  }
                }
                var dist = __webpack_require__2(6462);
                function isDecString(val) {
                  return typeof val === "string" && /^[0-9]+$/.test(val);
                }
                function isHexString(val) {
                  return typeof val === "string" && /^0x[0-9a-f]+$/i.test(val);
                }
                function isHexBytes(val, n) {
                  if (typeof val !== "string" || !/^0x[0-9a-f]*$/i.test(val)) {
                    return false;
                  }
                  return n ? val.length === n * 2 + 2 : val.length % 2 === 0;
                }
                function isUInt(val, bit) {
                  if (val < 0 || !Number.isInteger(val)) {
                    return false;
                  }
                  return bit ? val < Math.pow(2, bit) : true;
                }
                function isBigInt(v) {
                  return typeof v === "string" ? isDecString(v) || isHexString(v) : isUInt(v, 0);
                }
                class BadParameter extends Error {
                  constructor(msg) {
                    super(msg);
                  }
                }
                BadParameter.prototype.name = "BadParameter";
                function ensure(b, msg) {
                  if (!b) {
                    throw new BadParameter(msg);
                  }
                }
                function test(value, scheme, context) {
                  try {
                    return dist.Gu(value, scheme, context);
                  } catch (err) {
                    if (err instanceof dist.p8) {
                      throw new BadParameter(err.message);
                    }
                    throw err;
                  }
                }
                function bytes(v) {
                  return isHexBytes(v) ? "" : "expected bytes in hex string";
                }
                function bytes8(v) {
                  return isHexBytes(v, 8) ? "" : "expected bytes8";
                }
                function bytes32(v) {
                  return isHexBytes(v, 32) ? "" : "expected bytes32";
                }
                function uint8(v) {
                  return isUInt(v, 8) ? "" : "expected 8-bit unsigned integer";
                }
                function uint32(v) {
                  return isUInt(v, 32) ? "" : "expected 32-bit unsigned integer";
                }
                function uint64(v) {
                  return isUInt(v, 64) ? "" : "expected 64-bit unsigned integer";
                }
                function bool(v) {
                  return typeof v === "boolean" ? "" : "expected boolean";
                }
                function bigInt(v) {
                  return isBigInt(v) ? "" : "expected unsigned integer in number or string";
                }
                function hexString(v) {
                  return isHexString(v) ? "" : "expected integer in hex string";
                }
                function address(v) {
                  return isHexBytes(v, 20) ? "" : "expected address";
                }
                function string(v) {
                  return typeof v === "string" ? "" : "expected string";
                }
                const MAX_LIMIT = 256;
                function newFilter(readyDriver, kind, criteria) {
                  const filterBody = {
                    range: {
                      unit: "block",
                      from: 0,
                      to: Math.pow(2, 32) - 1
                    },
                    options: {
                      offset: 0,
                      limit: 10
                    },
                    criteriaSet: criteria,
                    order: "asc"
                  };
                  let cacheHints;
                  return {
                    range(range) {
                      test(range, {
                        unit: (v) => v === "block" || v === "time" ? "" : `expected 'block' or 'time'`,
                        from: uint64,
                        to: uint64
                      }, "arg0");
                      ensure(range.from <= range.to, "arg0.from: expected <= arg0.to");
                      filterBody.range = Object.assign({}, range);
                      return this;
                    },
                    order(order) {
                      ensure(order === "asc" || order === "desc", `arg0: expected 'asc' or 'desc'`);
                      filterBody.order = order;
                      return this;
                    },
                    cache(hints) {
                      cacheHints = test(hints, [address], "arg0").map((t) => t.toLowerCase());
                      return this;
                    },
                    apply(offset, limit) {
                      test(offset, uint64, "arg0");
                      ensure(limit >= 0 && limit <= MAX_LIMIT && Number.isInteger(limit), `arg1: expected unsigned integer <= ${MAX_LIMIT}`);
                      filterBody.options.offset = offset;
                      filterBody.options.limit = limit;
                      if (kind === "transfer") {
                        return readyDriver.then((d) => d.filterTransferLogs(filterBody, cacheHints));
                      } else {
                        return readyDriver.then((d) => d.filterEventLogs(filterBody, cacheHints));
                      }
                    }
                  };
                }
                var bignumber = __webpack_require__2(634);
                var bignumber_default = __webpack_require__2.n(bignumber);
                var __awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                function newVendor(driver) {
                  return {
                    sign: (kind, msg) => {
                      if (kind === "tx") {
                        test(msg, [clauseScheme], "arg1");
                        return newTxSigningService(Promise.resolve(driver), msg);
                      } else if (kind === "cert") {
                        test(msg, {
                          purpose: (v) => v === "agreement" || v === "identification" ? "" : `expected 'agreement' or 'identification'`,
                          payload: {
                            type: (v) => v === "text" ? "" : `expected 'text'`,
                            content: string
                          }
                        }, "arg1");
                        return newCertSigningService(Promise.resolve(driver), msg);
                      } else {
                        throw new BadParameter(`arg0: expected 'tx' or 'cert'`);
                      }
                    }
                  };
                }
                function newTxSigningService(readyDriver, msg) {
                  const opts = {};
                  return {
                    signer(addr) {
                      opts.signer = test(addr, address, "arg0").toLowerCase();
                      return this;
                    },
                    gas(gas) {
                      opts.gas = test(gas, uint64, "arg0");
                      return this;
                    },
                    dependsOn(txid) {
                      opts.dependsOn = test(txid, bytes32, "arg0").toLowerCase();
                      return this;
                    },
                    link(url) {
                      opts.link = test(url, string, "arg0");
                      return this;
                    },
                    comment(text) {
                      opts.comment = test(text, string, "arg0");
                      return this;
                    },
                    delegate(url, signer) {
                      ensure(typeof url === "string", `arg0: expected url string`);
                      test(signer, dist.jt(address), "arg1");
                      opts.delegator = { url, signer: signer && signer.toLowerCase() };
                      return this;
                    },
                    accepted(cb) {
                      ensure(typeof cb === "function", "arg0: expected function");
                      opts.onAccepted = cb;
                      return this;
                    },
                    request() {
                      const transformedMsg = msg.map((c) => Object.assign(Object.assign({}, c), { value: new (bignumber_default())(c.value).toString(10) }));
                      return (() => __awaiter(this, void 0, void 0, function* () {
                        try {
                          const driver = yield readyDriver;
                          return yield driver.signTx(transformedMsg, opts);
                        } catch (err) {
                          throw new Rejected(err.message);
                        }
                      }))();
                    }
                  };
                }
                function newCertSigningService(readyDriver, msg) {
                  const opts = {};
                  return {
                    signer(addr) {
                      opts.signer = test(addr, address, "arg0").toLowerCase();
                      return this;
                    },
                    link(url) {
                      opts.link = test(url, string, "arg0");
                      return this;
                    },
                    accepted(cb) {
                      ensure(typeof cb === "function", "arg0: expected function");
                      opts.onAccepted = cb;
                      return this;
                    },
                    request() {
                      return (() => __awaiter(this, void 0, void 0, function* () {
                        try {
                          const driver = yield readyDriver;
                          return yield driver.signCert(msg, opts);
                        } catch (err) {
                          throw new Rejected(err.message);
                        }
                      }))();
                    }
                  };
                }
                class Rejected extends Error {
                  constructor(msg) {
                    super(msg);
                  }
                }
                Rejected.prototype.name = "Rejected";
                const clauseScheme = {
                  to: dist.AG(address),
                  value: bigInt,
                  data: dist.jt(bytes),
                  comment: dist.jt(string),
                  abi: dist.jt((v) => {
                    if (!(v instanceof Object)) {
                      return "expected object";
                    }
                    try {
                      new abi.Function(v).signature;
                      return "";
                    } catch (err) {
                      return `expected valid ABI (${err.message})`;
                    }
                  })
                };
                function newAccountVisitor(readyDriver, addr) {
                  return {
                    get address() {
                      return addr;
                    },
                    get: () => {
                      return readyDriver.then((d) => d.getAccount(addr, d.head.id));
                    },
                    getCode: () => {
                      return readyDriver.then((d) => d.getCode(addr, d.head.id));
                    },
                    getStorage: (key) => {
                      key = test(key, bytes32, "arg0").toLowerCase();
                      return readyDriver.then((d) => d.getStorage(addr, key, d.head.id));
                    },
                    method: (jsonABI) => {
                      let coder2;
                      try {
                        coder2 = new abi.Function(JSON.parse(JSON.stringify(jsonABI)));
                      } catch (err) {
                        throw new BadParameter(`arg0: expected valid ABI (${err.message})`);
                      }
                      return newMethod(readyDriver, addr, coder2);
                    },
                    event: (jsonABI) => {
                      let coder2;
                      try {
                        coder2 = new abi.Event(JSON.parse(JSON.stringify(jsonABI)));
                      } catch (err) {
                        throw new BadParameter(`arg0: expected valid ABI (${err.message})`);
                      }
                      return newEvent(readyDriver, addr, coder2);
                    }
                  };
                }
                function newMethod(readyDriver, addr, coder2) {
                  let value = 0;
                  const opts = {};
                  let cacheHints;
                  return {
                    value(val) {
                      value = test(val, bigInt, "arg0");
                      return this;
                    },
                    caller(addr2) {
                      opts.caller = test(addr2, address, "arg0").toLowerCase();
                      return this;
                    },
                    gas(gas) {
                      opts.gas = test(gas, uint64, "arg0");
                      return this;
                    },
                    gasPrice(gp) {
                      opts.gasPrice = test(gp, bigInt, "arg0").toString().toLowerCase();
                      return this;
                    },
                    gasPayer(addr2) {
                      opts.gasPayer = test(addr2, address, "arg0").toLowerCase();
                      return this;
                    },
                    cache(hints) {
                      cacheHints = test(hints, [address], "arg0").map((t) => t.toLowerCase());
                      return this;
                    },
                    asClause: (...args) => {
                      const inputsLen = (coder2.definition.inputs || []).length;
                      ensure(inputsLen === args.length, `args count expected ${inputsLen}`);
                      try {
                        const data = coder2.encode(...args);
                        return {
                          to: addr,
                          value: value.toString().toLowerCase(),
                          data
                        };
                      } catch (err) {
                        throw new BadParameter(`args can not be encoded (${err.message})`);
                      }
                    },
                    call(...args) {
                      const clause = this.asClause(...args);
                      return readyDriver.then((d) => d.explain(Object.assign({ clauses: [clause] }, opts), d.head.id, cacheHints)).then((outputs) => outputs[0]).then((output) => {
                        if (output.reverted) {
                          const revertReason = decodeRevertReason(output.data);
                          return Object.assign(Object.assign({}, output), { revertReason, decoded: {} });
                        } else {
                          const decoded = coder2.decode(output.data);
                          return Object.assign(Object.assign({}, output), { decoded });
                        }
                      });
                    },
                    transact(...args) {
                      const clause = this.asClause(...args);
                      return newTxSigningService(readyDriver, [Object.assign(Object.assign({}, clause), { abi: coder2.definition })]);
                    }
                  };
                }
                function newEvent(readyDriver, addr, coder2) {
                  const encode = (indexed) => {
                    const topics = coder2.encode(indexed);
                    return {
                      address: addr,
                      topic0: topics[0] || void 0,
                      topic1: topics[1] || void 0,
                      topic2: topics[2] || void 0,
                      topic3: topics[3] || void 0,
                      topic4: topics[4] || void 0
                    };
                  };
                  return {
                    asCriteria: (indexed) => {
                      try {
                        return encode(indexed);
                      } catch (err) {
                        throw new BadParameter(`arg0: can not be encoded (${err.message})`);
                      }
                    },
                    filter: (indexed) => {
                      test(indexed, [{}], "arg0");
                      if (indexed.length === 0) {
                        indexed = [{}];
                      }
                      const criteria = indexed.map((o, i) => {
                        try {
                          return encode(o);
                        } catch (err) {
                          throw new BadParameter(`arg0.#${i}: can not be encoded (${err.message})`);
                        }
                      });
                      const filter = newFilter(readyDriver, "event", criteria);
                      return {
                        range(range) {
                          filter.range(range);
                          return this;
                        },
                        order(order) {
                          filter.order(order);
                          return this;
                        },
                        cache(hints) {
                          filter.cache(hints);
                          return this;
                        },
                        apply(offset, limit) {
                          return filter.apply(offset, limit).then((events) => events.map((event) => {
                            const decoded = coder2.decode(event.data, event.topics);
                            return Object.assign(Object.assign({}, event), { decoded });
                          }));
                        }
                      };
                    }
                  };
                }
                function newBlockVisitor(driver, revision) {
                  return {
                    get revision() {
                      return revision;
                    },
                    get: () => driver.getBlock(revision)
                  };
                }
                function newTxVisitor(readyDriver, id) {
                  let allowPending = false;
                  return {
                    get id() {
                      return id;
                    },
                    allowPending() {
                      allowPending = true;
                      return this;
                    },
                    get: () => readyDriver.then((d) => d.getTransaction(id, allowPending)),
                    getReceipt: () => readyDriver.then((d) => d.getReceipt(id))
                  };
                }
                var head_tracker_awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                const checkpointInterval = 180;
                function newHeadTracker(driver) {
                  let head = Object.assign({}, driver.head);
                  let finalized = driver.genesis.id;
                  let resolvers = [];
                  void (() => head_tracker_awaiter(this, void 0, void 0, function* () {
                    for (; ; ) {
                      try {
                        const newHead = yield driver.pollHead();
                        if (newHead.id !== head.id && newHead.number >= head.number) {
                          if (head.number === 0 || (newHead.number + 1) % checkpointInterval === 0) {
                            try {
                              const finalizedBlk = yield driver.getBlock("finalized");
                              if (finalizedBlk && finalizedBlk.id != finalized) {
                                finalized = finalizedBlk.id;
                              }
                            } catch (_a) {
                            }
                          }
                          head = Object.assign({}, newHead);
                          const resolversCopy = resolvers;
                          resolvers = [];
                          resolversCopy.forEach((r) => r(newHead));
                        } else {
                          yield new Promise((resolve) => setTimeout(resolve, 1 * 1e3));
                        }
                      } catch (_b) {
                        break;
                      }
                    }
                  }))();
                  const genesisTs = driver.genesis.timestamp;
                  return {
                    get head() {
                      return head;
                    },
                    get progress() {
                      const nowTsMs = Date.now();
                      const headTsMs = head.timestamp * 1e3;
                      if (nowTsMs - headTsMs < 30 * 1e3) {
                        return 1;
                      }
                      const genesisTsMs = genesisTs * 1e3;
                      const p = (headTsMs - genesisTsMs) / (nowTsMs - genesisTsMs);
                      return p < 0 ? NaN : p;
                    },
                    get finalized() {
                      return finalized;
                    },
                    ticker: () => {
                      let lastHeadId = head.id;
                      return {
                        next: () => {
                          return new Promise((resolve) => {
                            if (lastHeadId !== head.id) {
                              return resolve(Object.assign({}, head));
                            }
                            resolvers.push((newHead) => {
                              resolve(Object.assign({}, newHead));
                            });
                          }).then((h) => {
                            lastHeadId = h.id;
                            return h;
                          });
                        }
                      };
                    }
                  };
                }
                function newExplainer(readyDriver, clauses) {
                  const opts = {};
                  let cacheHints;
                  return {
                    caller(addr) {
                      opts.caller = test(addr, address, "arg0").toLowerCase();
                      return this;
                    },
                    gas(gas) {
                      opts.gas = test(gas, uint64, "arg0");
                      return this;
                    },
                    gasPrice(gp) {
                      opts.gasPrice = test(gp, bigInt, "arg0").toString().toLowerCase();
                      return this;
                    },
                    gasPayer(addr) {
                      opts.gasPayer = test(addr, address, "arg0").toLowerCase();
                      return this;
                    },
                    cache(hints) {
                      cacheHints = test(hints, [address], "arg0").map((t) => t.toLowerCase());
                      return this;
                    },
                    execute() {
                      const transformedClauses = clauses.map((c) => {
                        return {
                          to: c.to ? c.to.toLowerCase() : null,
                          value: new (bignumber_default())(c.value).toString(10),
                          data: (c.data || "0x").toLowerCase()
                        };
                      });
                      return readyDriver.then((d) => d.explain(Object.assign({ clauses: transformedClauses }, opts), d.head.id, cacheHints)).then((outputs) => {
                        return outputs.map((o) => {
                          if (o.reverted) {
                            const revertReason = decodeRevertReason(o.data);
                            return Object.assign(Object.assign({}, o), { revertReason });
                          }
                          return o;
                        });
                      });
                    }
                  };
                }
                var thor_awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                function newThor(driver) {
                  const headTracker = newHeadTracker(driver);
                  const readyDriver = (() => thor_awaiter(this, void 0, void 0, function* () {
                    if (headTracker.head.number > 0) {
                      return driver;
                    }
                    yield headTracker.ticker().next();
                    return driver;
                  }))();
                  const genesis = JSON.parse(JSON.stringify(driver.genesis));
                  return {
                    get genesis() {
                      return genesis;
                    },
                    get status() {
                      return {
                        head: headTracker.head,
                        progress: headTracker.progress,
                        finalized: headTracker.finalized
                      };
                    },
                    ticker: () => headTracker.ticker(),
                    account: (addr) => {
                      addr = test(addr, address, "arg0").toLowerCase();
                      return newAccountVisitor(readyDriver, addr);
                    },
                    block: (revision) => {
                      if (typeof revision === "undefined") {
                        revision = driver.head.id;
                      } else {
                        ensure(typeof revision === "string" ? isHexBytes(revision, 32) : isUInt(revision, 32), "arg0: expected bytes32 or unsigned 32-bit integer");
                      }
                      return newBlockVisitor(driver, typeof revision === "string" ? revision.toLowerCase() : revision);
                    },
                    transaction: (id) => {
                      id = test(id, bytes32, "arg0").toLowerCase();
                      return newTxVisitor(readyDriver, id);
                    },
                    filter: (kind, criteria) => {
                      ensure(kind === "event" || kind === "transfer", `arg0: expected 'event' or 'transfer'`);
                      if (kind === "event") {
                        test(criteria, [eventCriteriaScheme], "arg1");
                        return newFilter(readyDriver, "event", criteria.map((c) => {
                          return {
                            address: c.address ? c.address.toLowerCase() : void 0,
                            topic0: c.topic0 ? c.topic0.toLowerCase() : void 0,
                            topic1: c.topic1 ? c.topic1.toLowerCase() : void 0,
                            topic2: c.topic2 ? c.topic2.toLowerCase() : void 0,
                            topic3: c.topic3 ? c.topic3.toLowerCase() : void 0,
                            topic4: c.topic4 ? c.topic4.toLowerCase() : void 0
                          };
                        }));
                      } else {
                        test(criteria, [transferCriteriaScheme], "arg1");
                        return newFilter(readyDriver, "transfer", criteria.map((c) => {
                          return {
                            txOrigin: c.txOrigin ? c.txOrigin.toLowerCase() : void 0,
                            sender: c.sender ? c.sender.toLowerCase() : void 0,
                            recipient: c.recipient ? c.recipient.toLowerCase() : void 0
                          };
                        }));
                      }
                    },
                    explain: (clauses) => {
                      test(clauses, [thor_clauseScheme], "arg0");
                      return newExplainer(readyDriver, clauses);
                    }
                  };
                }
                const thor_clauseScheme = {
                  to: dist.AG(address),
                  value: bigInt,
                  data: dist.jt(bytes)
                };
                const eventCriteriaScheme = {
                  address: dist.jt(address),
                  topic0: dist.jt(bytes32),
                  topic1: dist.jt(bytes32),
                  topic2: dist.jt(bytes32),
                  topic3: dist.jt(bytes32),
                  topic4: dist.jt(bytes32)
                };
                const transferCriteriaScheme = {
                  sender: dist.jt(address),
                  recipient: dist.jt(address),
                  txOrigin: dist.jt(address)
                };
                function newDriverGuard(driver, errHandler) {
                  const test2 = (obj, scheme, path) => {
                    try {
                      dist.Gu(obj, scheme, path);
                    } catch (err) {
                      if (errHandler) {
                        errHandler(err);
                      } else {
                        console.warn(`Connex-Driver[MALFORMED RESPONSE]: ${err.message}`);
                      }
                    }
                    return obj;
                  };
                  const genesis = test2(driver.genesis, blockScheme, "genesis");
                  return {
                    genesis,
                    get head() {
                      return test2(driver.head, headScheme, "head");
                    },
                    pollHead() {
                      return driver.pollHead().then((h) => test2(h, headScheme, "getHead()"));
                    },
                    getBlock(revision) {
                      return driver.getBlock(revision).then((b) => b ? test2(b, blockScheme, "getBlock()") : b);
                    },
                    getTransaction(id, allowPending) {
                      return driver.getTransaction(id, allowPending).then((tx) => tx ? test2(tx, txScheme, "getTransaction()") : tx);
                    },
                    getReceipt(id) {
                      return driver.getReceipt(id).then((r) => r ? test2(r, receiptScheme, "getReceipt()") : r);
                    },
                    getAccount(addr, revision) {
                      return driver.getAccount(addr, revision).then((a) => test2(a, {
                        balance: hexString,
                        energy: hexString,
                        hasCode: bool
                      }, "getAccount()"));
                    },
                    getCode(addr, revision) {
                      return driver.getCode(addr, revision).then((c) => test2(c, {
                        code: bytes
                      }, "getCode()"));
                    },
                    getStorage(addr, key, revision) {
                      return driver.getStorage(addr, key, revision).then((s) => test2(s, {
                        value: bytes32
                      }, "getStorage()"));
                    },
                    explain(arg, revision) {
                      return driver.explain(arg, revision).then((r) => test2(r, [vmOutputScheme], "explain()"));
                    },
                    filterEventLogs(arg) {
                      return driver.filterEventLogs(arg).then((r) => test2(r, [eventWithMetaScheme], "filterEventLogs()"));
                    },
                    filterTransferLogs(arg) {
                      return driver.filterTransferLogs(arg).then((r) => test2(r, [transferWithMetaScheme], "filterTransferLogs()"));
                    },
                    signTx(msg, options) {
                      return driver.signTx(msg, options).then((r) => test2(r, {
                        txid: bytes32,
                        signer: address
                      }, "signTx()"));
                    },
                    signCert(msg, options) {
                      return driver.signCert(msg, options).then((r) => test2(r, {
                        annex: {
                          domain: string,
                          timestamp: uint64,
                          signer: address
                        },
                        signature: (v) => isHexBytes(v, 65) ? "" : "expected 65 bytes"
                      }, "signCert()"));
                    }
                  };
                }
                const headScheme = {
                  id: bytes32,
                  number: uint32,
                  timestamp: uint64,
                  parentID: bytes32,
                  txsFeatures: dist.jt(uint32),
                  gasLimit: uint64
                };
                const blockScheme = {
                  id: bytes32,
                  number: uint32,
                  size: uint32,
                  parentID: bytes32,
                  timestamp: uint64,
                  gasLimit: uint64,
                  beneficiary: address,
                  gasUsed: uint64,
                  totalScore: uint64,
                  txsRoot: bytes32,
                  txsFeatures: dist.jt(uint32),
                  stateRoot: bytes32,
                  receiptsRoot: bytes32,
                  signer: address,
                  com: dist.jt(bool),
                  isFinalized: dist.jt(bool),
                  isTrunk: bool,
                  transactions: [bytes32]
                };
                const txScheme = {
                  id: bytes32,
                  chainTag: uint8,
                  blockRef: bytes8,
                  expiration: uint32,
                  gasPriceCoef: uint8,
                  gas: uint64,
                  origin: address,
                  delegator: dist.AG(dist.jt(address)),
                  nonce: hexString,
                  dependsOn: dist.AG(bytes32),
                  size: uint32,
                  clauses: [{
                    to: dist.AG(address),
                    value: hexString,
                    data: bytes
                  }],
                  meta: dist.AG({
                    blockID: bytes32,
                    blockNumber: uint32,
                    blockTimestamp: uint64
                  })
                };
                const logMetaScheme = {
                  blockID: bytes32,
                  blockNumber: uint32,
                  blockTimestamp: uint64,
                  txID: bytes32,
                  txOrigin: address,
                  clauseIndex: uint32
                };
                const eventScheme = {
                  address,
                  topics: [bytes32],
                  data: bytes
                };
                const eventWithMetaScheme = Object.assign(Object.assign({}, eventScheme), { meta: logMetaScheme });
                const transferScheme = {
                  sender: address,
                  recipient: address,
                  amount: hexString
                };
                const transferWithMetaScheme = Object.assign(Object.assign({}, transferScheme), { meta: logMetaScheme });
                const receiptScheme = {
                  gasUsed: uint64,
                  gasPayer: address,
                  paid: hexString,
                  reward: hexString,
                  reverted: bool,
                  outputs: [{
                    contractAddress: dist.AG(address),
                    events: [eventScheme],
                    transfers: [transferScheme]
                  }],
                  meta: {
                    blockID: bytes32,
                    blockNumber: uint32,
                    blockTimestamp: uint64,
                    txID: bytes32,
                    txOrigin: address
                  }
                };
                const vmOutputScheme = {
                  data: bytes,
                  vmError: string,
                  gasUsed: uint64,
                  reverted: bool,
                  revertReason: () => "",
                  events: [{
                    address,
                    topics: [bytes32],
                    data: bytes
                  }],
                  transfers: [{
                    sender: address,
                    recipient: address,
                    amount: hexString
                  }]
                };
                class Framework {
                  /**
                   * constructor
                   * @param driver the driver instance
                   */
                  constructor(driver) {
                    this.thor = newThor(driver);
                    this.vendor = newVendor(driver);
                  }
                  /**
                   * create a wrapper for driver, to validate responses. it should be helpful to make sure driver is properly
                   * implemented in development stage.
                   * @param driver the driver to be wrapped
                   * @param errorHandler optional error handler. If omitted, error message will be printed via console.warn.
                   */
                  static guardDriver(driver, errorHandler) {
                    return newDriverGuard(driver, errorHandler);
                  }
                }
                const genesisBlocks = {
                  main: {
                    number: 0,
                    id: "0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",
                    size: 170,
                    parentID: "0xffffffff53616c757465202620526573706563742c20457468657265756d2100",
                    timestamp: 1530316800,
                    gasLimit: 1e7,
                    beneficiary: "0x0000000000000000000000000000000000000000",
                    gasUsed: 0,
                    totalScore: 0,
                    txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
                    txsFeatures: 0,
                    stateRoot: "0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",
                    receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
                    signer: "0x0000000000000000000000000000000000000000",
                    isTrunk: true,
                    transactions: []
                  },
                  test: {
                    number: 0,
                    id: "0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",
                    size: 170,
                    parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
                    timestamp: 1530014400,
                    gasLimit: 1e7,
                    beneficiary: "0x0000000000000000000000000000000000000000",
                    gasUsed: 0,
                    totalScore: 0,
                    txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
                    txsFeatures: 0,
                    stateRoot: "0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",
                    receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
                    signer: "0x0000000000000000000000000000000000000000",
                    isTrunk: true,
                    transactions: []
                  }
                };
                class PromInt {
                  constructor() {
                    this.rejectors = /* @__PURE__ */ new Set();
                  }
                  /**
                   * interrupt all wrapped promises
                   */
                  interrupt() {
                    const rejectors = this.rejectors;
                    this.rejectors = /* @__PURE__ */ new Set();
                    rejectors.forEach((r) => r(new InterruptedError()));
                  }
                  /**
                   * wrap the promise
                   * @param p the given promise
                   * @returns the wrapped promise which will raise InterruptedError on interruption
                   */
                  wrap(p) {
                    return new Promise((resolve, reject) => {
                      const rejectors = this.rejectors;
                      rejectors.add(reject);
                      void p.then(resolve).catch(reject).then(() => rejectors.delete(reject));
                    });
                  }
                }
                class InterruptedError extends Error {
                  constructor() {
                    super("promise interrupted");
                  }
                }
                InterruptedError.prototype.name = "InterruptedError";
                var lru_cache = __webpack_require__2(9992);
                var bignumber_js_bignumber = __webpack_require__2(4491);
                var bignumber_js_bignumber_default = __webpack_require__2.n(bignumber_js_bignumber);
                var blake2b_Buffer = __webpack_require__2(8764)["Buffer"];
                const blake = __webpack_require__2(1161);
                function blake2b256(...data) {
                  const ctx = blake.blake2bInit(32, null);
                  data.forEach((d) => {
                    if (blake2b_Buffer.isBuffer(d)) {
                      blake.blake2bUpdate(ctx, d);
                    } else {
                      blake.blake2bUpdate(ctx, blake2b_Buffer.from(d, "utf8"));
                    }
                  });
                  return blake2b_Buffer.from(blake.blake2bFinal(ctx));
                }
                function bloom_newFilter(bits, k) {
                  const nBits = bits.length * 8;
                  return {
                    contains(key) {
                      let hash = blake2b256(key).readUInt32BE(0);
                      const delta = hash >>> 17 | hash << 15 >>> 0;
                      for (let i = 0; i < k; i++) {
                        const bitPos = hash % nBits;
                        const index = bitPos >>> 3;
                        const bit = 1 << bitPos % 8;
                        if (!(bits[index] & bit)) {
                          return false;
                        }
                        hash = hash + delta >>> 0;
                      }
                      return true;
                    }
                  };
                }
                var cache_Buffer = __webpack_require__2(8764)["Buffer"];
                var cache_awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                const WINDOW_LEN = 12;
                class Cache {
                  constructor() {
                    this.irreversible = {
                      blocks: new lru_cache(256),
                      txs: new lru_cache(512),
                      receipts: new lru_cache(512)
                    };
                    this.window = [];
                  }
                  handleNewBlock(head, bloom, block) {
                    while (this.window.length > 0) {
                      const top = this.window[this.window.length - 1];
                      if (top.id === head.id) {
                        return;
                      }
                      if (top.id === head.parentID) {
                        break;
                      }
                      this.window.pop();
                    }
                    this.window.push(Object.assign(Object.assign({}, head), { bloom: bloom ? bloom_newFilter(cache_Buffer.from(bloom.bits.slice(2), "hex"), bloom.k) : void 0, block, accounts: /* @__PURE__ */ new Map(), txs: /* @__PURE__ */ new Map(), receipts: /* @__PURE__ */ new Map(), tied: /* @__PURE__ */ new Map() }));
                    while (this.window.length > WINDOW_LEN) {
                      const bottom = this.window.shift();
                      bottom.txs.forEach((v, k) => this.irreversible.txs.set(k, v));
                      bottom.receipts.forEach((v, k) => this.irreversible.receipts.set(k, v));
                      if (bottom.block) {
                        this.irreversible.blocks.set(bottom.block.id, bottom.block);
                        this.irreversible.blocks.set(bottom.block.number, bottom.block);
                      }
                    }
                  }
                  getBlock(revision, fetch2) {
                    return cache_awaiter(this, void 0, void 0, function* () {
                      let block = this.irreversible.blocks.get(revision) || null;
                      if (block) {
                        return block;
                      }
                      const { slot } = this.findSlot(revision);
                      if (slot && slot.block) {
                        return slot.block;
                      }
                      block = yield fetch2();
                      if (block) {
                        if (slot && slot.id === block.id) {
                          slot.block = block;
                        }
                        if (this.isIrreversible(block.number)) {
                          this.irreversible.blocks.set(block.id, block);
                          if (block.isTrunk) {
                            this.irreversible.blocks.set(block.number, block);
                          }
                        }
                      }
                      return block;
                    });
                  }
                  getTx(txid, fetch2) {
                    return cache_awaiter(this, void 0, void 0, function* () {
                      let tx = this.irreversible.txs.get(txid) || null;
                      if (tx) {
                        return tx;
                      }
                      for (const slot of this.window) {
                        tx = slot.txs.get(txid) || null;
                        if (tx) {
                          return tx;
                        }
                      }
                      tx = yield fetch2();
                      if (tx && tx.meta) {
                        const { slot } = this.findSlot(tx.meta.blockID);
                        if (slot) {
                          slot.txs.set(txid, tx);
                        }
                        if (this.isIrreversible(tx.meta.blockNumber)) {
                          this.irreversible.txs.set(txid, tx);
                        }
                      }
                      return tx;
                    });
                  }
                  getReceipt(txid, fetch2) {
                    return cache_awaiter(this, void 0, void 0, function* () {
                      let receipt = this.irreversible.receipts.get(txid) || null;
                      if (receipt) {
                        return receipt;
                      }
                      for (const slot of this.window) {
                        receipt = slot.receipts.get(txid) || null;
                        if (receipt) {
                          return receipt;
                        }
                      }
                      receipt = yield fetch2();
                      if (receipt) {
                        const { slot } = this.findSlot(receipt.meta.blockID);
                        if (slot) {
                          slot.receipts.set(txid, receipt);
                        }
                        if (this.isIrreversible(receipt.meta.blockNumber)) {
                          this.irreversible.receipts.set(txid, receipt);
                        }
                      }
                      return receipt;
                    });
                  }
                  getAccount(addr, revision, fetch2) {
                    return cache_awaiter(this, void 0, void 0, function* () {
                      const found = this.findSlot(revision);
                      for (let i = found.index; i >= 0; i--) {
                        const slot = this.window[i];
                        const acc = slot.accounts.get(addr);
                        if (acc) {
                          if (i !== found.index) {
                            found.slot.accounts.set(addr, acc);
                          }
                          return acc.snapshot(found.slot.timestamp);
                        }
                        if (!slot.bloom || testBytesHex(slot.bloom, addr)) {
                          break;
                        }
                      }
                      const accObj = yield fetch2();
                      if (found.slot) {
                        found.slot.accounts.set(addr, new Account(accObj, found.slot.timestamp));
                      }
                      return accObj;
                    });
                  }
                  /**
                   * get cached entry which is tied to a batch of addresses
                   * @param key the cache key
                   * @param revision block id where cache bound to
                   * @param fetch to fetch value when cache missing
                   * @param hints array of tied addresses, as the gist to invalidate cache key. undefined means the key is always
                   * invalidated on different revision.
                   */
                  getTied(key, revision, fetch2, hints) {
                    return cache_awaiter(this, void 0, void 0, function* () {
                      const found = this.findSlot(revision);
                      for (let i = found.index; i >= 0; i--) {
                        const slot = this.window[i];
                        const v = slot.tied.get(key);
                        if (v) {
                          if (i !== found.index) {
                            found.slot.tied.set(key, v);
                          }
                          return v;
                        }
                        if (!slot.bloom || !hints) {
                          break;
                        }
                        if (hints.some((t) => testBytesHex(slot.bloom, t))) {
                          break;
                        }
                      }
                      const value = yield fetch2();
                      if (found.slot) {
                        found.slot.tied.set(key, value);
                      }
                      return value;
                    });
                  }
                  findSlot(revision) {
                    const index = this.window.findIndex((s) => s.id === revision || s.number === revision);
                    if (index >= 0) {
                      return { slot: this.window[index], index };
                    }
                    return { index };
                  }
                  isIrreversible(n) {
                    if (this.window.length > 0) {
                      return n < this.window[this.window.length - 1].number - WINDOW_LEN;
                    }
                    return false;
                  }
                }
                function testBytesHex(filter, hex) {
                  let buf = cache_Buffer.from(hex.slice(2), "hex");
                  const nzIndex = buf.findIndex((v) => v !== 0);
                  if (nzIndex < 0) {
                    buf = cache_Buffer.alloc(0);
                  } else {
                    buf = buf.slice(nzIndex);
                  }
                  return filter.contains(buf);
                }
                const ENERGY_GROWTH_RATE = 5e9;
                class Account {
                  constructor(obj, initTimestamp) {
                    this.obj = obj;
                    this.initTimestamp = initTimestamp;
                  }
                  snapshot(timestamp) {
                    return Object.assign(Object.assign({}, this.obj), { energy: this.energyAt(timestamp) });
                  }
                  energyAt(timestamp) {
                    if (timestamp < this.initTimestamp) {
                      return this.obj.energy;
                    }
                    return "0x" + new (bignumber_js_bignumber_default())(this.obj.balance).times(timestamp - this.initTimestamp).times(ENERGY_GROWTH_RATE).dividedToIntegerBy(1e18).plus(this.obj.energy).toString(16);
                  }
                }
                function sleep(ms) {
                  return new Promise((resolve) => setTimeout(resolve, ms));
                }
                var driver_no_vendor_awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                class DriverNoVendor {
                  constructor(net, genesis, initialHead) {
                    this.net = net;
                    this.genesis = genesis;
                    this.headResolvers = [];
                    this.int = new PromInt();
                    this.cache = new Cache();
                    this.pendingRequests = {};
                    if (initialHead) {
                      this.head = initialHead;
                    } else {
                      this.head = {
                        id: genesis.id,
                        number: genesis.number,
                        timestamp: genesis.timestamp,
                        parentID: genesis.parentID,
                        txsFeatures: genesis.txsFeatures,
                        gasLimit: genesis.gasLimit
                      };
                    }
                    void this.headTrackerLoop();
                  }
                  // close the driver to prevent mem leak
                  close() {
                    this.int.interrupt();
                  }
                  // implementations
                  pollHead() {
                    return this.int.wrap(new Promise((resolve) => {
                      this.headResolvers.push(() => resolve(this.head));
                    }));
                  }
                  getBlock(revision) {
                    return this.cache.getBlock(revision, () => this.httpGet(`blocks/${revision}`));
                  }
                  getTransaction(id, allowPending) {
                    return this.cache.getTx(id, () => {
                      const query = { head: this.head.id };
                      if (allowPending) {
                        query.pending = "true";
                      }
                      return this.httpGet(`transactions/${id}`, query);
                    });
                  }
                  getReceipt(id) {
                    return this.cache.getReceipt(id, () => this.httpGet(`transactions/${id}/receipt`, { head: this.head.id }));
                  }
                  getAccount(addr, revision) {
                    return this.cache.getAccount(addr, revision, () => this.httpGet(`accounts/${addr}`, { revision }));
                  }
                  getCode(addr, revision) {
                    return this.cache.getTied(`code-${addr}`, revision, () => this.httpGet(`accounts/${addr}/code`, { revision }));
                  }
                  getStorage(addr, key, revision) {
                    return this.cache.getTied(`storage-${addr}-${key}`, revision, () => this.httpGet(`accounts/${addr}/storage/${key}`, { revision }));
                  }
                  explain(arg, revision, cacheHints) {
                    const cacheKey = `explain-${blake2b256(JSON.stringify(arg)).toString("hex")}`;
                    return this.cache.getTied(cacheKey, revision, () => this.httpPost("accounts/*", arg, { revision }), cacheHints);
                  }
                  filterEventLogs(arg, cacheHints) {
                    const cacheKey = `event-${blake2b256(JSON.stringify(arg)).toString("hex")}`;
                    return this.cache.getTied(cacheKey, this.head.id, () => this.httpPost("logs/event", arg), cacheHints);
                  }
                  filterTransferLogs(arg, cacheHints) {
                    const cacheKey = `transfer-${blake2b256(JSON.stringify(arg)).toString("hex")}`;
                    return this.cache.getTied(cacheKey, this.head.id, () => this.httpPost("logs/transfer", arg), cacheHints);
                  }
                  signTx(msg, options) {
                    throw new Error("signer not implemented");
                  }
                  signCert(msg, options) {
                    throw new Error("signer not implemented");
                  }
                  //////
                  mergeRequest(req, ...keyParts) {
                    const key = JSON.stringify(keyParts);
                    const pending = this.pendingRequests[key];
                    if (pending) {
                      return pending;
                    }
                    return this.pendingRequests[key] = (() => driver_no_vendor_awaiter(this, void 0, void 0, function* () {
                      try {
                        return yield req();
                      } finally {
                        delete this.pendingRequests[key];
                      }
                    }))();
                  }
                  httpGet(path, query) {
                    return this.mergeRequest(() => {
                      return this.net.http("GET", path, {
                        query,
                        validateResponseHeader: this.headerValidator
                      });
                    }, path, query || "");
                  }
                  httpPost(path, body, query) {
                    return this.mergeRequest(() => {
                      return this.net.http("POST", path, {
                        query,
                        body,
                        validateResponseHeader: this.headerValidator
                      });
                    }, path, query || "", body || "");
                  }
                  get headerValidator() {
                    return (headers) => {
                      const xgid = headers["x-genesis-id"];
                      if (xgid && xgid !== this.genesis.id) {
                        throw new Error(`responded 'x-genesis-id' not matched`);
                      }
                    };
                  }
                  emitNewHead() {
                    const resolvers = this.headResolvers;
                    this.headResolvers = [];
                    resolvers.forEach((r) => r());
                  }
                  headTrackerLoop() {
                    return driver_no_vendor_awaiter(this, void 0, void 0, function* () {
                      for (; ; ) {
                        let attemptWs = false;
                        try {
                          const best = yield this.int.wrap(this.httpGet("blocks/best"));
                          if (best.id !== this.head.id && best.number >= this.head.number) {
                            this.head = {
                              id: best.id,
                              number: best.number,
                              timestamp: best.timestamp,
                              parentID: best.parentID,
                              txsFeatures: best.txsFeatures,
                              gasLimit: best.gasLimit
                            };
                            this.cache.handleNewBlock(this.head, void 0, best);
                            this.emitNewHead();
                            if (Date.now() - this.head.timestamp * 1e3 < 60 * 1e3) {
                              attemptWs = true;
                            }
                          }
                        } catch (err) {
                          if (err instanceof InterruptedError) {
                            break;
                          }
                        }
                        if (attemptWs) {
                          try {
                            yield this.trackWs();
                          } catch (err) {
                            if (err instanceof InterruptedError) {
                              break;
                            }
                          }
                        }
                        try {
                          yield this.int.wrap(sleep(8 * 1e3));
                        } catch (_a) {
                          break;
                        }
                      }
                    });
                  }
                  trackWs() {
                    return driver_no_vendor_awaiter(this, void 0, void 0, function* () {
                      const wsPath = `subscriptions/beat2?pos=${this.head.parentID}`;
                      const wsr = this.net.openWebSocketReader(wsPath);
                      try {
                        for (; ; ) {
                          const data = yield this.int.wrap(wsr.read());
                          const beat = JSON.parse(data);
                          if (!beat.obsolete && beat.id !== this.head.id && beat.number >= this.head.number) {
                            this.head = {
                              id: beat.id,
                              number: beat.number,
                              timestamp: beat.timestamp,
                              parentID: beat.parentID,
                              txsFeatures: beat.txsFeatures,
                              gasLimit: beat.gasLimit
                            };
                            this.cache.handleNewBlock(this.head, { k: beat.k, bits: beat.bloom });
                            this.emitNewHead();
                          }
                        }
                      } finally {
                        wsr.close();
                      }
                    });
                  }
                }
                var axios = __webpack_require__2(8416);
                var axios_default = __webpack_require__2.n(axios);
                var browser = __webpack_require__2(9347);
                class SimpleWebSocketReader {
                  constructor(url, timeout = 30 * 1e3) {
                    this.timeout = timeout;
                    this.callbacks = [];
                    this.ws = new browser(url);
                    this.ws.onmessage = (ev) => {
                      try {
                        const cbs = this.callbacks;
                        this.callbacks = [];
                        cbs.forEach((cb) => cb(ev.data));
                      } catch (err) {
                        this.setError(err);
                        this.ws.close();
                      }
                    };
                    this.ws.onerror = (ev) => {
                      this.setError(ev.error);
                      this.ws.close();
                    };
                    this.ws.onclose = () => {
                      this.setError(new Error("closed"));
                    };
                  }
                  read() {
                    return new Promise((resolve, reject) => {
                      if (this.error) {
                        return reject(this.error);
                      }
                      const timer = setTimeout(() => {
                        reject(new Error("ws read timeout"));
                      }, this.timeout);
                      this.callbacks.push((data, err) => {
                        clearTimeout(timer);
                        if (err) {
                          return reject(err);
                        }
                        resolve(data);
                      });
                    });
                  }
                  close() {
                    this.ws.close();
                  }
                  setError(err) {
                    if (!this.error) {
                      this.error = err;
                      const cbs = this.callbacks;
                      this.callbacks = [];
                      cbs.forEach((cb) => cb(null, err));
                    }
                  }
                }
                var url_url = __webpack_require__2(8575);
                class Agent {
                  constructor() {
                    return void 0;
                  }
                }
                var simple_net_awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                class SimpleNet {
                  constructor(baseURL, timeout = 30 * 1e3, wsTimeout = 30 * 1e3) {
                    this.baseURL = baseURL;
                    this.wsTimeout = wsTimeout;
                    this.axios = axios_default().create({
                      httpAgent: new Agent({ keepAlive: true }),
                      httpsAgent: new Agent({ keepAlive: true }),
                      baseURL,
                      timeout
                    });
                  }
                  http(method, path, params) {
                    return simple_net_awaiter(this, void 0, void 0, function* () {
                      params = params || {};
                      try {
                        const resp = yield this.axios.request({
                          method,
                          url: path,
                          data: params.body,
                          headers: params.headers,
                          params: params.query
                        });
                        if (params.validateResponseHeader) {
                          params.validateResponseHeader(resp.headers);
                        }
                        return resp.data;
                      } catch (err) {
                        if (err.isAxiosError) {
                          throw convertError(err);
                        }
                        throw new Error(`${method} ${(0, url_url.DB)(this.baseURL, path)}: ${err.message}`);
                      }
                    });
                  }
                  openWebSocketReader(path) {
                    const url = (0, url_url.DB)(this.baseURL, path).replace(/^http:/i, "ws:").replace(/^https:/i, "wss:");
                    return new SimpleWebSocketReader(url, this.wsTimeout);
                  }
                }
                function convertError(err) {
                  if (err.response) {
                    const resp = err.response;
                    if (typeof resp.data === "string") {
                      let text = resp.data.trim();
                      if (text.length > 50) {
                        text = text.slice(0, 50) + "...";
                      }
                      return new Error(`${resp.status} ${err.config.method} ${err.config.url}: ${text}`);
                    } else {
                      return new Error(`${resp.status} ${err.config.method} ${err.config.url}`);
                    }
                  } else {
                    return new Error(`${err.config.method} ${err.config.url}: ${err.message}`);
                  }
                }
                var esm_blake2b_Buffer = __webpack_require__2(8764)["Buffer"];
                const blake2b_blake = __webpack_require__2(1191);
                function blake2b_blake2b256(...data) {
                  const ctx = blake2b_blake.blake2bInit(32, null);
                  data.forEach((d) => {
                    if (esm_blake2b_Buffer.isBuffer(d)) {
                      blake2b_blake.blake2bUpdate(ctx, d);
                    } else {
                      blake2b_blake.blake2bUpdate(ctx, esm_blake2b_Buffer.from(d, "utf8"));
                    }
                  });
                  return esm_blake2b_Buffer.from(blake2b_blake.blake2bFinal(ctx));
                }
                var driver_awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                class LazyDriver {
                  constructor(signer) {
                    this.signer = signer;
                    this._driver = null;
                  }
                  get noVendor() {
                    if (!this._driver) {
                      throw new Error("thor driver is not ready");
                    }
                    return this._driver;
                  }
                  setNoVendor(driver) {
                    this._driver = driver;
                  }
                  get genesis() {
                    return this.noVendor.genesis;
                  }
                  get head() {
                    return this.noVendor.head;
                  }
                  pollHead() {
                    return this.noVendor.pollHead();
                  }
                  getBlock(revision) {
                    return this.noVendor.getBlock(revision);
                  }
                  getTransaction(id, allowPending) {
                    return this.noVendor.getTransaction(id, allowPending);
                  }
                  getReceipt(id) {
                    return this.noVendor.getReceipt(id);
                  }
                  getAccount(addr, revision) {
                    return this.noVendor.getAccount(addr, revision);
                  }
                  getCode(addr, revision) {
                    return this.noVendor.getCode(addr, revision);
                  }
                  getStorage(addr, key, revision) {
                    return this.noVendor.getStorage(addr, key, revision);
                  }
                  explain(arg, revision, cacheHints) {
                    return this.noVendor.explain(arg, revision, cacheHints);
                  }
                  filterEventLogs(arg) {
                    return this.noVendor.filterEventLogs(arg);
                  }
                  filterTransferLogs(arg) {
                    return this.noVendor.filterTransferLogs(arg);
                  }
                  signTx(msg, options) {
                    return driver_awaiter(this, void 0, void 0, function* () {
                      return this.signer.then((b) => b.signTx(msg, options));
                    });
                  }
                  signCert(msg, options) {
                    return driver_awaiter(this, void 0, void 0, function* () {
                      return this.signer.then((b) => b.signCert(msg, options));
                    });
                  }
                }
                const cache = {};
                function createNoVendor(node, genesis) {
                  const key = blake2b_blake2b256(JSON.stringify({
                    node,
                    genesis
                  })).toString("hex");
                  let driver = cache[key];
                  if (!driver) {
                    cache[key] = driver = new DriverNoVendor(new SimpleNet(node), genesis);
                  }
                  return driver;
                }
                function createFull(node, genesis, newSigner) {
                  const driver = new LazyDriver(newSigner(genesis.id));
                  driver.setNoVendor(createNoVendor(node, genesis));
                  return driver;
                }
                const script_loader_cache = {};
                function loadLibrary(src, libName) {
                  let lib = script_loader_cache[src];
                  if (!lib) {
                    const script = document.createElement("script");
                    script_loader_cache[src] = lib = new Promise((resolve, reject) => {
                      script.onload = () => resolve(window[libName]);
                      script.onerror = (err) => reject(new Error(err.toString()));
                    });
                    script.src = src;
                    document.body.appendChild(script);
                  }
                  return lib;
                }
                var randombytes_browser = __webpack_require__2(1798);
                var randombytes_browser_default = __webpack_require__2.n(randombytes_browser);
                var signer_awaiter = function(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                };
                const BUDDY_SRC = "https://unpkg.com/@vechain/connex-wallet-buddy@0.1";
                const BUDDY_LIB_NAME = "ConnexWalletBuddy";
                const createSync2 = (genesisId) => signer_awaiter(void 0, void 0, void 0, function* () {
                  return loadLibrary(BUDDY_SRC, BUDDY_LIB_NAME).then((lib) => lib.create(genesisId, () => randombytes_browser_default()(16).toString("hex"), (val) => blake2b_blake2b256(val).toString("hex")));
                });
                const createSync = (genesisId) => signer_awaiter(void 0, void 0, void 0, function* () {
                  const v1 = window.connex.vendor;
                  return Promise.resolve({
                    signTx: (msg, options) => {
                      const s1 = v1.sign("tx");
                      options.signer && s1.signer(options.signer);
                      options.gas && s1.gas(options.gas);
                      options.dependsOn && s1.dependsOn(options.dependsOn);
                      options.link && s1.link(options.link);
                      options.comment && s1.link(options.comment);
                      if (options.delegator) {
                        const url = options.delegator.url;
                        s1.delegate((unsignedTx) => signer_awaiter(void 0, void 0, void 0, function* () {
                          const res = yield fetch(url, {
                            method: "POST",
                            body: JSON.stringify(unsignedTx),
                            headers: {
                              "Content-Type": "application/json"
                            }
                          });
                          return res.json();
                        }));
                      }
                      options.onAccepted && options.onAccepted();
                      return s1.request(msg);
                    },
                    signCert: (msg, options) => {
                      const s1 = v1.sign("cert");
                      options.signer && s1.signer(options.signer);
                      options.link && s1.link(options.link);
                      options.onAccepted && options.onAccepted();
                      return s1.request(msg);
                    }
                  });
                });
                function normalizeNetwork(n) {
                  n = n || "main";
                  if (typeof n === "string") {
                    const gb = genesisBlocks[n];
                    if (!gb) {
                      throw new Error("invalid network");
                    }
                    return gb;
                  } else {
                    return n;
                  }
                }
                function normalizeGenesisId(id) {
                  id = id || "main";
                  if (/^0x[0-9a-f]{64}$/.test(id)) {
                    return id;
                  }
                  const gb = genesisBlocks[id];
                  if (gb) {
                    return gb.id;
                  }
                  throw new Error("invalid genesis id");
                }
                function normalizeSigner(genesisId, signer) {
                  switch (signer.toLocaleLowerCase()) {
                    case "sync":
                      if (!window.connex) {
                        throw new Error("Sync not found");
                      }
                      if (window.connex.thor.genesis.id !== genesisId) {
                        throw new Error("Network mismatch");
                      }
                      return createSync;
                    case "sync2":
                      return createSync2;
                    default:
                      throw new Error("unsupported signer");
                  }
                }
                class ThorClass {
                  constructor(opts) {
                    const genesis = normalizeNetwork(opts.network);
                    const driver = createNoVendor(opts.node, genesis);
                    const framework = new Framework(driver);
                    return {
                      get genesis() {
                        return framework.thor.genesis;
                      },
                      get status() {
                        return framework.thor.status;
                      },
                      get ticker() {
                        return framework.thor.ticker.bind(framework.thor);
                      },
                      get account() {
                        return framework.thor.account.bind(framework.thor);
                      },
                      get block() {
                        return framework.thor.block.bind(framework.thor);
                      },
                      get transaction() {
                        return framework.thor.transaction.bind(framework.thor);
                      },
                      get filter() {
                        return framework.thor.filter.bind(framework.thor);
                      },
                      get explain() {
                        return framework.thor.explain.bind(framework.thor);
                      }
                    };
                  }
                }
                class VendorClass {
                  constructor(genesisId, signer = "sync2") {
                    genesisId = normalizeGenesisId(genesisId);
                    const newSigner = normalizeSigner(genesisId, signer);
                    const driver = new LazyDriver(newSigner(genesisId));
                    const vendor = newVendor(driver);
                    return {
                      get sign() {
                        return vendor.sign.bind(vendor);
                      }
                    };
                  }
                }
                class ConnexClass {
                  constructor(opts) {
                    var _a;
                    const genesis = normalizeNetwork(opts.network);
                    const newSigner = normalizeSigner(genesis.id, (_a = opts.signer) !== null && _a !== void 0 ? _a : "sync2");
                    const driver = createFull(opts.node, genesis, newSigner);
                    const framework = new Framework(driver);
                    return {
                      get thor() {
                        return framework.thor;
                      },
                      get vendor() {
                        return framework.vendor;
                      }
                    };
                  }
                }
                ConnexClass.Thor = ThorClass;
                ConnexClass.Vendor = VendorClass;
                const esm = ConnexClass;
              }
            ),
            /***/
            9742: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                exports2.byteLength = byteLength;
                exports2.toByteArray = toByteArray;
                exports2.fromByteArray = fromByteArray;
                var lookup = [];
                var revLookup = [];
                var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
                var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                for (var i = 0, len = code.length; i < len; ++i) {
                  lookup[i] = code[i];
                  revLookup[code.charCodeAt(i)] = i;
                }
                revLookup["-".charCodeAt(0)] = 62;
                revLookup["_".charCodeAt(0)] = 63;
                function getLens(b64) {
                  var len2 = b64.length;
                  if (len2 % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                  }
                  var validLen = b64.indexOf("=");
                  if (validLen === -1)
                    validLen = len2;
                  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
                  return [validLen, placeHoldersLen];
                }
                function byteLength(b64) {
                  var lens = getLens(b64);
                  var validLen = lens[0];
                  var placeHoldersLen = lens[1];
                  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function _byteLength(b64, validLen, placeHoldersLen) {
                  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function toByteArray(b64) {
                  var tmp;
                  var lens = getLens(b64);
                  var validLen = lens[0];
                  var placeHoldersLen = lens[1];
                  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
                  var curByte = 0;
                  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
                  var i2;
                  for (i2 = 0; i2 < len2; i2 += 4) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
                    arr[curByte++] = tmp >> 16 & 255;
                    arr[curByte++] = tmp >> 8 & 255;
                    arr[curByte++] = tmp & 255;
                  }
                  if (placeHoldersLen === 2) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
                    arr[curByte++] = tmp & 255;
                  }
                  if (placeHoldersLen === 1) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
                    arr[curByte++] = tmp >> 8 & 255;
                    arr[curByte++] = tmp & 255;
                  }
                  return arr;
                }
                function tripletToBase64(num) {
                  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
                }
                function encodeChunk(uint8, start, end) {
                  var tmp;
                  var output = [];
                  for (var i2 = start; i2 < end; i2 += 3) {
                    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
                    output.push(tripletToBase64(tmp));
                  }
                  return output.join("");
                }
                function fromByteArray(uint8) {
                  var tmp;
                  var len2 = uint8.length;
                  var extraBytes = len2 % 3;
                  var parts = [];
                  var maxChunkLength = 16383;
                  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
                    parts.push(encodeChunk(
                      uint8,
                      i2,
                      i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
                    ));
                  }
                  if (extraBytes === 1) {
                    tmp = uint8[len2 - 1];
                    parts.push(
                      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
                    );
                  } else if (extraBytes === 2) {
                    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                    parts.push(
                      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
                    );
                  }
                  return parts.join("");
                }
              }
            ),
            /***/
            8442: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                const util = __webpack_require__2(9488);
                function ADD64AA(v2, a, b) {
                  const o0 = v2[a] + v2[b];
                  let o1 = v2[a + 1] + v2[b + 1];
                  if (o0 >= 4294967296) {
                    o1++;
                  }
                  v2[a] = o0;
                  v2[a + 1] = o1;
                }
                function ADD64AC(v2, a, b0, b1) {
                  let o0 = v2[a] + b0;
                  if (b0 < 0) {
                    o0 += 4294967296;
                  }
                  let o1 = v2[a + 1] + b1;
                  if (o0 >= 4294967296) {
                    o1++;
                  }
                  v2[a] = o0;
                  v2[a + 1] = o1;
                }
                function B2B_GET32(arr, i) {
                  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
                }
                function B2B_G(a, b, c, d, ix, iy) {
                  const x0 = m[ix];
                  const x1 = m[ix + 1];
                  const y0 = m[iy];
                  const y1 = m[iy + 1];
                  ADD64AA(v, a, b);
                  ADD64AC(v, a, x0, x1);
                  let xor0 = v[d] ^ v[a];
                  let xor1 = v[d + 1] ^ v[a + 1];
                  v[d] = xor1;
                  v[d + 1] = xor0;
                  ADD64AA(v, c, d);
                  xor0 = v[b] ^ v[c];
                  xor1 = v[b + 1] ^ v[c + 1];
                  v[b] = xor0 >>> 24 ^ xor1 << 8;
                  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
                  ADD64AA(v, a, b);
                  ADD64AC(v, a, y0, y1);
                  xor0 = v[d] ^ v[a];
                  xor1 = v[d + 1] ^ v[a + 1];
                  v[d] = xor0 >>> 16 ^ xor1 << 16;
                  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
                  ADD64AA(v, c, d);
                  xor0 = v[b] ^ v[c];
                  xor1 = v[b + 1] ^ v[c + 1];
                  v[b] = xor1 >>> 31 ^ xor0 << 1;
                  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
                }
                const BLAKE2B_IV32 = new Uint32Array([
                  4089235720,
                  1779033703,
                  2227873595,
                  3144134277,
                  4271175723,
                  1013904242,
                  1595750129,
                  2773480762,
                  2917565137,
                  1359893119,
                  725511199,
                  2600822924,
                  4215389547,
                  528734635,
                  327033209,
                  1541459225
                ]);
                const SIGMA8 = [
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  14,
                  10,
                  4,
                  8,
                  9,
                  15,
                  13,
                  6,
                  1,
                  12,
                  0,
                  2,
                  11,
                  7,
                  5,
                  3,
                  11,
                  8,
                  12,
                  0,
                  5,
                  2,
                  15,
                  13,
                  10,
                  14,
                  3,
                  6,
                  7,
                  1,
                  9,
                  4,
                  7,
                  9,
                  3,
                  1,
                  13,
                  12,
                  11,
                  14,
                  2,
                  6,
                  5,
                  10,
                  4,
                  0,
                  15,
                  8,
                  9,
                  0,
                  5,
                  7,
                  2,
                  4,
                  10,
                  15,
                  14,
                  1,
                  11,
                  12,
                  6,
                  8,
                  3,
                  13,
                  2,
                  12,
                  6,
                  10,
                  0,
                  11,
                  8,
                  3,
                  4,
                  13,
                  7,
                  5,
                  15,
                  14,
                  1,
                  9,
                  12,
                  5,
                  1,
                  15,
                  14,
                  13,
                  4,
                  10,
                  0,
                  7,
                  6,
                  3,
                  9,
                  2,
                  8,
                  11,
                  13,
                  11,
                  7,
                  14,
                  12,
                  1,
                  3,
                  9,
                  5,
                  0,
                  15,
                  4,
                  8,
                  6,
                  2,
                  10,
                  6,
                  15,
                  14,
                  9,
                  11,
                  3,
                  0,
                  8,
                  12,
                  2,
                  13,
                  7,
                  1,
                  4,
                  10,
                  5,
                  10,
                  2,
                  8,
                  4,
                  7,
                  6,
                  1,
                  5,
                  15,
                  11,
                  9,
                  14,
                  3,
                  12,
                  13,
                  0,
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  14,
                  10,
                  4,
                  8,
                  9,
                  15,
                  13,
                  6,
                  1,
                  12,
                  0,
                  2,
                  11,
                  7,
                  5,
                  3
                ];
                const SIGMA82 = new Uint8Array(
                  SIGMA8.map(function(x) {
                    return x * 2;
                  })
                );
                const v = new Uint32Array(32);
                const m = new Uint32Array(32);
                function blake2bCompress(ctx, last) {
                  let i = 0;
                  for (i = 0; i < 16; i++) {
                    v[i] = ctx.h[i];
                    v[i + 16] = BLAKE2B_IV32[i];
                  }
                  v[24] = v[24] ^ ctx.t;
                  v[25] = v[25] ^ ctx.t / 4294967296;
                  if (last) {
                    v[28] = ~v[28];
                    v[29] = ~v[29];
                  }
                  for (i = 0; i < 32; i++) {
                    m[i] = B2B_GET32(ctx.b, 4 * i);
                  }
                  for (i = 0; i < 12; i++) {
                    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
                    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
                    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
                    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
                    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
                    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
                    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
                    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
                  }
                  for (i = 0; i < 16; i++) {
                    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
                  }
                }
                function blake2bInit(outlen, key) {
                  if (outlen === 0 || outlen > 64) {
                    throw new Error("Illegal output length, expected 0 < length <= 64");
                  }
                  if (key && key.length > 64) {
                    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
                  }
                  const ctx = {
                    b: new Uint8Array(128),
                    h: new Uint32Array(16),
                    t: 0,
                    // input count
                    c: 0,
                    // pointer within buffer
                    outlen
                    // output length in bytes
                  };
                  for (let i = 0; i < 16; i++) {
                    ctx.h[i] = BLAKE2B_IV32[i];
                  }
                  const keylen = key ? key.length : 0;
                  ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
                  if (key) {
                    blake2bUpdate(ctx, key);
                    ctx.c = 128;
                  }
                  return ctx;
                }
                function blake2bUpdate(ctx, input) {
                  for (let i = 0; i < input.length; i++) {
                    if (ctx.c === 128) {
                      ctx.t += ctx.c;
                      blake2bCompress(ctx, false);
                      ctx.c = 0;
                    }
                    ctx.b[ctx.c++] = input[i];
                  }
                }
                function blake2bFinal(ctx) {
                  ctx.t += ctx.c;
                  while (ctx.c < 128) {
                    ctx.b[ctx.c++] = 0;
                  }
                  blake2bCompress(ctx, true);
                  const out = new Uint8Array(ctx.outlen);
                  for (let i = 0; i < ctx.outlen; i++) {
                    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
                  }
                  return out;
                }
                function blake2b(input, key, outlen) {
                  outlen = outlen || 64;
                  input = util.normalizeInput(input);
                  const ctx = blake2bInit(outlen, key);
                  blake2bUpdate(ctx, input);
                  return blake2bFinal(ctx);
                }
                function blake2bHex(input, key, outlen) {
                  const output = blake2b(input, key, outlen);
                  return util.toHex(output);
                }
                module2.exports = {
                  blake2b,
                  blake2bHex,
                  blake2bInit,
                  blake2bUpdate,
                  blake2bFinal
                };
              }
            ),
            /***/
            5297: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                const util = __webpack_require__2(9488);
                function B2S_GET32(v2, i) {
                  return v2[i] ^ v2[i + 1] << 8 ^ v2[i + 2] << 16 ^ v2[i + 3] << 24;
                }
                function B2S_G(a, b, c, d, x, y) {
                  v[a] = v[a] + v[b] + x;
                  v[d] = ROTR32(v[d] ^ v[a], 16);
                  v[c] = v[c] + v[d];
                  v[b] = ROTR32(v[b] ^ v[c], 12);
                  v[a] = v[a] + v[b] + y;
                  v[d] = ROTR32(v[d] ^ v[a], 8);
                  v[c] = v[c] + v[d];
                  v[b] = ROTR32(v[b] ^ v[c], 7);
                }
                function ROTR32(x, y) {
                  return x >>> y ^ x << 32 - y;
                }
                const BLAKE2S_IV = new Uint32Array([
                  1779033703,
                  3144134277,
                  1013904242,
                  2773480762,
                  1359893119,
                  2600822924,
                  528734635,
                  1541459225
                ]);
                const SIGMA = new Uint8Array([
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  14,
                  10,
                  4,
                  8,
                  9,
                  15,
                  13,
                  6,
                  1,
                  12,
                  0,
                  2,
                  11,
                  7,
                  5,
                  3,
                  11,
                  8,
                  12,
                  0,
                  5,
                  2,
                  15,
                  13,
                  10,
                  14,
                  3,
                  6,
                  7,
                  1,
                  9,
                  4,
                  7,
                  9,
                  3,
                  1,
                  13,
                  12,
                  11,
                  14,
                  2,
                  6,
                  5,
                  10,
                  4,
                  0,
                  15,
                  8,
                  9,
                  0,
                  5,
                  7,
                  2,
                  4,
                  10,
                  15,
                  14,
                  1,
                  11,
                  12,
                  6,
                  8,
                  3,
                  13,
                  2,
                  12,
                  6,
                  10,
                  0,
                  11,
                  8,
                  3,
                  4,
                  13,
                  7,
                  5,
                  15,
                  14,
                  1,
                  9,
                  12,
                  5,
                  1,
                  15,
                  14,
                  13,
                  4,
                  10,
                  0,
                  7,
                  6,
                  3,
                  9,
                  2,
                  8,
                  11,
                  13,
                  11,
                  7,
                  14,
                  12,
                  1,
                  3,
                  9,
                  5,
                  0,
                  15,
                  4,
                  8,
                  6,
                  2,
                  10,
                  6,
                  15,
                  14,
                  9,
                  11,
                  3,
                  0,
                  8,
                  12,
                  2,
                  13,
                  7,
                  1,
                  4,
                  10,
                  5,
                  10,
                  2,
                  8,
                  4,
                  7,
                  6,
                  1,
                  5,
                  15,
                  11,
                  9,
                  14,
                  3,
                  12,
                  13,
                  0
                ]);
                const v = new Uint32Array(16);
                const m = new Uint32Array(16);
                function blake2sCompress(ctx, last) {
                  let i = 0;
                  for (i = 0; i < 8; i++) {
                    v[i] = ctx.h[i];
                    v[i + 8] = BLAKE2S_IV[i];
                  }
                  v[12] ^= ctx.t;
                  v[13] ^= ctx.t / 4294967296;
                  if (last) {
                    v[14] = ~v[14];
                  }
                  for (i = 0; i < 16; i++) {
                    m[i] = B2S_GET32(ctx.b, 4 * i);
                  }
                  for (i = 0; i < 10; i++) {
                    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
                    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
                    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
                    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
                    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
                    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
                    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
                    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
                  }
                  for (i = 0; i < 8; i++) {
                    ctx.h[i] ^= v[i] ^ v[i + 8];
                  }
                }
                function blake2sInit(outlen, key) {
                  if (!(outlen > 0 && outlen <= 32)) {
                    throw new Error("Incorrect output length, should be in [1, 32]");
                  }
                  const keylen = key ? key.length : 0;
                  if (key && !(keylen > 0 && keylen <= 32)) {
                    throw new Error("Incorrect key length, should be in [1, 32]");
                  }
                  const ctx = {
                    h: new Uint32Array(BLAKE2S_IV),
                    // hash state
                    b: new Uint8Array(64),
                    // input block
                    c: 0,
                    // pointer within block
                    t: 0,
                    // input count
                    outlen
                    // output length in bytes
                  };
                  ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
                  if (keylen > 0) {
                    blake2sUpdate(ctx, key);
                    ctx.c = 64;
                  }
                  return ctx;
                }
                function blake2sUpdate(ctx, input) {
                  for (let i = 0; i < input.length; i++) {
                    if (ctx.c === 64) {
                      ctx.t += ctx.c;
                      blake2sCompress(ctx, false);
                      ctx.c = 0;
                    }
                    ctx.b[ctx.c++] = input[i];
                  }
                }
                function blake2sFinal(ctx) {
                  ctx.t += ctx.c;
                  while (ctx.c < 64) {
                    ctx.b[ctx.c++] = 0;
                  }
                  blake2sCompress(ctx, true);
                  const out = new Uint8Array(ctx.outlen);
                  for (let i = 0; i < ctx.outlen; i++) {
                    out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
                  }
                  return out;
                }
                function blake2s(input, key, outlen) {
                  outlen = outlen || 32;
                  input = util.normalizeInput(input);
                  const ctx = blake2sInit(outlen, key);
                  blake2sUpdate(ctx, input);
                  return blake2sFinal(ctx);
                }
                function blake2sHex(input, key, outlen) {
                  const output = blake2s(input, key, outlen);
                  return util.toHex(output);
                }
                module2.exports = {
                  blake2s,
                  blake2sHex,
                  blake2sInit,
                  blake2sUpdate,
                  blake2sFinal
                };
              }
            ),
            /***/
            1191: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                const b2b = __webpack_require__2(8442);
                const b2s = __webpack_require__2(5297);
                module2.exports = {
                  blake2b: b2b.blake2b,
                  blake2bHex: b2b.blake2bHex,
                  blake2bInit: b2b.blake2bInit,
                  blake2bUpdate: b2b.blake2bUpdate,
                  blake2bFinal: b2b.blake2bFinal,
                  blake2s: b2s.blake2s,
                  blake2sHex: b2s.blake2sHex,
                  blake2sInit: b2s.blake2sInit,
                  blake2sUpdate: b2s.blake2sUpdate,
                  blake2sFinal: b2s.blake2sFinal
                };
              }
            ),
            /***/
            9488: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var Buffer = __webpack_require__2(8764)["Buffer"];
                const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
                function normalizeInput(input) {
                  let ret;
                  if (input instanceof Uint8Array) {
                    ret = input;
                  } else if (input instanceof Buffer) {
                    ret = new Uint8Array(input);
                  } else if (typeof input === "string") {
                    ret = new Uint8Array(Buffer.from(input, "utf8"));
                  } else {
                    throw new Error(ERROR_MSG_INPUT);
                  }
                  return ret;
                }
                function toHex(bytes) {
                  return Array.prototype.map.call(bytes, function(n) {
                    return (n < 16 ? "0" : "") + n.toString(16);
                  }).join("");
                }
                function uint32ToHex(val) {
                  return (4294967296 + val).toString(16).substring(1);
                }
                function debugPrint(label, arr, size) {
                  let msg = "\n" + label + " = ";
                  for (let i = 0; i < arr.length; i += 2) {
                    if (size === 32) {
                      msg += uint32ToHex(arr[i]).toUpperCase();
                      msg += " ";
                      msg += uint32ToHex(arr[i + 1]).toUpperCase();
                    } else if (size === 64) {
                      msg += uint32ToHex(arr[i + 1]).toUpperCase();
                      msg += uint32ToHex(arr[i]).toUpperCase();
                    } else
                      throw new Error("Invalid size " + size);
                    if (i % 6 === 4) {
                      msg += "\n" + new Array(label.length + 4).join(" ");
                    } else if (i < arr.length - 2) {
                      msg += " ";
                    }
                  }
                  console.log(msg);
                }
                function testSpeed(hashFn, N, M) {
                  let startMs = (/* @__PURE__ */ new Date()).getTime();
                  const input = new Uint8Array(N);
                  for (let i = 0; i < N; i++) {
                    input[i] = i % 256;
                  }
                  const genMs = (/* @__PURE__ */ new Date()).getTime();
                  console.log("Generated random input in " + (genMs - startMs) + "ms");
                  startMs = genMs;
                  for (let i = 0; i < M; i++) {
                    const hashHex = hashFn(input);
                    const hashMs = (/* @__PURE__ */ new Date()).getTime();
                    const ms = hashMs - startMs;
                    startMs = hashMs;
                    console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
                    console.log(
                      Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
                    );
                  }
                }
                module2.exports = {
                  normalizeInput,
                  toHex,
                  debugPrint,
                  testSpeed
                };
              }
            ),
            /***/
            8764: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                var base64 = __webpack_require__2(9742);
                var ieee754 = __webpack_require__2(645);
                var customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
                exports2.Buffer = Buffer;
                exports2.SlowBuffer = SlowBuffer;
                exports2.INSPECT_MAX_BYTES = 50;
                var K_MAX_LENGTH = 2147483647;
                exports2.kMaxLength = K_MAX_LENGTH;
                Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
                if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                  console.error(
                    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
                  );
                }
                function typedArraySupport() {
                  try {
                    var arr = new Uint8Array(1);
                    var proto = { foo: function() {
                      return 42;
                    } };
                    Object.setPrototypeOf(proto, Uint8Array.prototype);
                    Object.setPrototypeOf(arr, proto);
                    return arr.foo() === 42;
                  } catch (e) {
                    return false;
                  }
                }
                Object.defineProperty(Buffer.prototype, "parent", {
                  enumerable: true,
                  get: function() {
                    if (!Buffer.isBuffer(this))
                      return void 0;
                    return this.buffer;
                  }
                });
                Object.defineProperty(Buffer.prototype, "offset", {
                  enumerable: true,
                  get: function() {
                    if (!Buffer.isBuffer(this))
                      return void 0;
                    return this.byteOffset;
                  }
                });
                function createBuffer(length) {
                  if (length > K_MAX_LENGTH) {
                    throw new RangeError('The value "' + length + '" is invalid for option "size"');
                  }
                  var buf = new Uint8Array(length);
                  Object.setPrototypeOf(buf, Buffer.prototype);
                  return buf;
                }
                function Buffer(arg, encodingOrOffset, length) {
                  if (typeof arg === "number") {
                    if (typeof encodingOrOffset === "string") {
                      throw new TypeError(
                        'The "string" argument must be of type string. Received type number'
                      );
                    }
                    return allocUnsafe(arg);
                  }
                  return from(arg, encodingOrOffset, length);
                }
                Buffer.poolSize = 8192;
                function from(value, encodingOrOffset, length) {
                  if (typeof value === "string") {
                    return fromString(value, encodingOrOffset);
                  }
                  if (ArrayBuffer.isView(value)) {
                    return fromArrayLike(value);
                  }
                  if (value == null) {
                    throw new TypeError(
                      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                    );
                  }
                  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                  }
                  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                  }
                  if (typeof value === "number") {
                    throw new TypeError(
                      'The "value" argument must not be of type number. Received type number'
                    );
                  }
                  var valueOf = value.valueOf && value.valueOf();
                  if (valueOf != null && valueOf !== value) {
                    return Buffer.from(valueOf, encodingOrOffset, length);
                  }
                  var b = fromObject(value);
                  if (b)
                    return b;
                  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                    return Buffer.from(
                      value[Symbol.toPrimitive]("string"),
                      encodingOrOffset,
                      length
                    );
                  }
                  throw new TypeError(
                    "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                  );
                }
                Buffer.from = function(value, encodingOrOffset, length) {
                  return from(value, encodingOrOffset, length);
                };
                Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
                Object.setPrototypeOf(Buffer, Uint8Array);
                function assertSize(size) {
                  if (typeof size !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                  } else if (size < 0) {
                    throw new RangeError('The value "' + size + '" is invalid for option "size"');
                  }
                }
                function alloc(size, fill, encoding) {
                  assertSize(size);
                  if (size <= 0) {
                    return createBuffer(size);
                  }
                  if (fill !== void 0) {
                    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                  }
                  return createBuffer(size);
                }
                Buffer.alloc = function(size, fill, encoding) {
                  return alloc(size, fill, encoding);
                };
                function allocUnsafe(size) {
                  assertSize(size);
                  return createBuffer(size < 0 ? 0 : checked(size) | 0);
                }
                Buffer.allocUnsafe = function(size) {
                  return allocUnsafe(size);
                };
                Buffer.allocUnsafeSlow = function(size) {
                  return allocUnsafe(size);
                };
                function fromString(string, encoding) {
                  if (typeof encoding !== "string" || encoding === "") {
                    encoding = "utf8";
                  }
                  if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                  var length = byteLength(string, encoding) | 0;
                  var buf = createBuffer(length);
                  var actual = buf.write(string, encoding);
                  if (actual !== length) {
                    buf = buf.slice(0, actual);
                  }
                  return buf;
                }
                function fromArrayLike(array) {
                  var length = array.length < 0 ? 0 : checked(array.length) | 0;
                  var buf = createBuffer(length);
                  for (var i = 0; i < length; i += 1) {
                    buf[i] = array[i] & 255;
                  }
                  return buf;
                }
                function fromArrayBuffer(array, byteOffset, length) {
                  if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                  }
                  if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                  }
                  var buf;
                  if (byteOffset === void 0 && length === void 0) {
                    buf = new Uint8Array(array);
                  } else if (length === void 0) {
                    buf = new Uint8Array(array, byteOffset);
                  } else {
                    buf = new Uint8Array(array, byteOffset, length);
                  }
                  Object.setPrototypeOf(buf, Buffer.prototype);
                  return buf;
                }
                function fromObject(obj) {
                  if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0;
                    var buf = createBuffer(len);
                    if (buf.length === 0) {
                      return buf;
                    }
                    obj.copy(buf, 0, 0, len);
                    return buf;
                  }
                  if (obj.length !== void 0) {
                    if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                      return createBuffer(0);
                    }
                    return fromArrayLike(obj);
                  }
                  if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data);
                  }
                }
                function checked(length) {
                  if (length >= K_MAX_LENGTH) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                  }
                  return length | 0;
                }
                function SlowBuffer(length) {
                  if (+length != length) {
                    length = 0;
                  }
                  return Buffer.alloc(+length);
                }
                Buffer.isBuffer = function isBuffer(b) {
                  return b != null && b._isBuffer === true && b !== Buffer.prototype;
                };
                Buffer.compare = function compare(a, b) {
                  if (isInstance(a, Uint8Array))
                    a = Buffer.from(a, a.offset, a.byteLength);
                  if (isInstance(b, Uint8Array))
                    b = Buffer.from(b, b.offset, b.byteLength);
                  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError(
                      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                    );
                  }
                  if (a === b)
                    return 0;
                  var x = a.length;
                  var y = b.length;
                  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                      x = a[i];
                      y = b[i];
                      break;
                    }
                  }
                  if (x < y)
                    return -1;
                  if (y < x)
                    return 1;
                  return 0;
                };
                Buffer.isEncoding = function isEncoding(encoding) {
                  switch (String(encoding).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return true;
                    default:
                      return false;
                  }
                };
                Buffer.concat = function concat(list, length) {
                  if (!Array.isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  }
                  if (list.length === 0) {
                    return Buffer.alloc(0);
                  }
                  var i;
                  if (length === void 0) {
                    length = 0;
                    for (i = 0; i < list.length; ++i) {
                      length += list[i].length;
                    }
                  }
                  var buffer = Buffer.allocUnsafe(length);
                  var pos = 0;
                  for (i = 0; i < list.length; ++i) {
                    var buf = list[i];
                    if (isInstance(buf, Uint8Array)) {
                      buf = Buffer.from(buf);
                    }
                    if (!Buffer.isBuffer(buf)) {
                      throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    buf.copy(buffer, pos);
                    pos += buf.length;
                  }
                  return buffer;
                };
                function byteLength(string, encoding) {
                  if (Buffer.isBuffer(string)) {
                    return string.length;
                  }
                  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                    return string.byteLength;
                  }
                  if (typeof string !== "string") {
                    throw new TypeError(
                      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
                    );
                  }
                  var len = string.length;
                  var mustMatch = arguments.length > 2 && arguments[2] === true;
                  if (!mustMatch && len === 0)
                    return 0;
                  var loweredCase = false;
                  for (; ; ) {
                    switch (encoding) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return len;
                      case "utf8":
                      case "utf-8":
                        return utf8ToBytes(string).length;
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return len * 2;
                      case "hex":
                        return len >>> 1;
                      case "base64":
                        return base64ToBytes(string).length;
                      default:
                        if (loweredCase) {
                          return mustMatch ? -1 : utf8ToBytes(string).length;
                        }
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                  }
                }
                Buffer.byteLength = byteLength;
                function slowToString(encoding, start, end) {
                  var loweredCase = false;
                  if (start === void 0 || start < 0) {
                    start = 0;
                  }
                  if (start > this.length) {
                    return "";
                  }
                  if (end === void 0 || end > this.length) {
                    end = this.length;
                  }
                  if (end <= 0) {
                    return "";
                  }
                  end >>>= 0;
                  start >>>= 0;
                  if (end <= start) {
                    return "";
                  }
                  if (!encoding)
                    encoding = "utf8";
                  while (true) {
                    switch (encoding) {
                      case "hex":
                        return hexSlice(this, start, end);
                      case "utf8":
                      case "utf-8":
                        return utf8Slice(this, start, end);
                      case "ascii":
                        return asciiSlice(this, start, end);
                      case "latin1":
                      case "binary":
                        return latin1Slice(this, start, end);
                      case "base64":
                        return base64Slice(this, start, end);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return utf16leSlice(this, start, end);
                      default:
                        if (loweredCase)
                          throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase();
                        loweredCase = true;
                    }
                  }
                }
                Buffer.prototype._isBuffer = true;
                function swap(b, n, m) {
                  var i = b[n];
                  b[n] = b[m];
                  b[m] = i;
                }
                Buffer.prototype.swap16 = function swap16() {
                  var len = this.length;
                  if (len % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                  }
                  for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1);
                  }
                  return this;
                };
                Buffer.prototype.swap32 = function swap32() {
                  var len = this.length;
                  if (len % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                  }
                  for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3);
                    swap(this, i + 1, i + 2);
                  }
                  return this;
                };
                Buffer.prototype.swap64 = function swap64() {
                  var len = this.length;
                  if (len % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                  }
                  for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7);
                    swap(this, i + 1, i + 6);
                    swap(this, i + 2, i + 5);
                    swap(this, i + 3, i + 4);
                  }
                  return this;
                };
                Buffer.prototype.toString = function toString() {
                  var length = this.length;
                  if (length === 0)
                    return "";
                  if (arguments.length === 0)
                    return utf8Slice(this, 0, length);
                  return slowToString.apply(this, arguments);
                };
                Buffer.prototype.toLocaleString = Buffer.prototype.toString;
                Buffer.prototype.equals = function equals(b) {
                  if (!Buffer.isBuffer(b))
                    throw new TypeError("Argument must be a Buffer");
                  if (this === b)
                    return true;
                  return Buffer.compare(this, b) === 0;
                };
                Buffer.prototype.inspect = function inspect() {
                  var str = "";
                  var max = exports2.INSPECT_MAX_BYTES;
                  str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                  if (this.length > max)
                    str += " ... ";
                  return "<Buffer " + str + ">";
                };
                if (customInspectSymbol) {
                  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
                }
                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                  if (isInstance(target, Uint8Array)) {
                    target = Buffer.from(target, target.offset, target.byteLength);
                  }
                  if (!Buffer.isBuffer(target)) {
                    throw new TypeError(
                      'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
                    );
                  }
                  if (start === void 0) {
                    start = 0;
                  }
                  if (end === void 0) {
                    end = target ? target.length : 0;
                  }
                  if (thisStart === void 0) {
                    thisStart = 0;
                  }
                  if (thisEnd === void 0) {
                    thisEnd = this.length;
                  }
                  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError("out of range index");
                  }
                  if (thisStart >= thisEnd && start >= end) {
                    return 0;
                  }
                  if (thisStart >= thisEnd) {
                    return -1;
                  }
                  if (start >= end) {
                    return 1;
                  }
                  start >>>= 0;
                  end >>>= 0;
                  thisStart >>>= 0;
                  thisEnd >>>= 0;
                  if (this === target)
                    return 0;
                  var x = thisEnd - thisStart;
                  var y = end - start;
                  var len = Math.min(x, y);
                  var thisCopy = this.slice(thisStart, thisEnd);
                  var targetCopy = target.slice(start, end);
                  for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                      x = thisCopy[i];
                      y = targetCopy[i];
                      break;
                    }
                  }
                  if (x < y)
                    return -1;
                  if (y < x)
                    return 1;
                  return 0;
                };
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                  if (buffer.length === 0)
                    return -1;
                  if (typeof byteOffset === "string") {
                    encoding = byteOffset;
                    byteOffset = 0;
                  } else if (byteOffset > 2147483647) {
                    byteOffset = 2147483647;
                  } else if (byteOffset < -2147483648) {
                    byteOffset = -2147483648;
                  }
                  byteOffset = +byteOffset;
                  if (numberIsNaN(byteOffset)) {
                    byteOffset = dir ? 0 : buffer.length - 1;
                  }
                  if (byteOffset < 0)
                    byteOffset = buffer.length + byteOffset;
                  if (byteOffset >= buffer.length) {
                    if (dir)
                      return -1;
                    else
                      byteOffset = buffer.length - 1;
                  } else if (byteOffset < 0) {
                    if (dir)
                      byteOffset = 0;
                    else
                      return -1;
                  }
                  if (typeof val === "string") {
                    val = Buffer.from(val, encoding);
                  }
                  if (Buffer.isBuffer(val)) {
                    if (val.length === 0) {
                      return -1;
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                  } else if (typeof val === "number") {
                    val = val & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                      if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                      } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                      }
                    }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                  }
                  throw new TypeError("val must be string, number or Buffer");
                }
                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                  var indexSize = 1;
                  var arrLength = arr.length;
                  var valLength = val.length;
                  if (encoding !== void 0) {
                    encoding = String(encoding).toLowerCase();
                    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                      if (arr.length < 2 || val.length < 2) {
                        return -1;
                      }
                      indexSize = 2;
                      arrLength /= 2;
                      valLength /= 2;
                      byteOffset /= 2;
                    }
                  }
                  function read(buf, i2) {
                    if (indexSize === 1) {
                      return buf[i2];
                    } else {
                      return buf.readUInt16BE(i2 * indexSize);
                    }
                  }
                  var i;
                  if (dir) {
                    var foundIndex = -1;
                    for (i = byteOffset; i < arrLength; i++) {
                      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1)
                          foundIndex = i;
                        if (i - foundIndex + 1 === valLength)
                          return foundIndex * indexSize;
                      } else {
                        if (foundIndex !== -1)
                          i -= i - foundIndex;
                        foundIndex = -1;
                      }
                    }
                  } else {
                    if (byteOffset + valLength > arrLength)
                      byteOffset = arrLength - valLength;
                    for (i = byteOffset; i >= 0; i--) {
                      var found = true;
                      for (var j = 0; j < valLength; j++) {
                        if (read(arr, i + j) !== read(val, j)) {
                          found = false;
                          break;
                        }
                      }
                      if (found)
                        return i;
                    }
                  }
                  return -1;
                }
                Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                  return this.indexOf(val, byteOffset, encoding) !== -1;
                };
                Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                };
                Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                };
                function hexWrite(buf, string, offset, length) {
                  offset = Number(offset) || 0;
                  var remaining = buf.length - offset;
                  if (!length) {
                    length = remaining;
                  } else {
                    length = Number(length);
                    if (length > remaining) {
                      length = remaining;
                    }
                  }
                  var strLen = string.length;
                  if (length > strLen / 2) {
                    length = strLen / 2;
                  }
                  for (var i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16);
                    if (numberIsNaN(parsed))
                      return i;
                    buf[offset + i] = parsed;
                  }
                  return i;
                }
                function utf8Write(buf, string, offset, length) {
                  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }
                function asciiWrite(buf, string, offset, length) {
                  return blitBuffer(asciiToBytes(string), buf, offset, length);
                }
                function latin1Write(buf, string, offset, length) {
                  return asciiWrite(buf, string, offset, length);
                }
                function base64Write(buf, string, offset, length) {
                  return blitBuffer(base64ToBytes(string), buf, offset, length);
                }
                function ucs2Write(buf, string, offset, length) {
                  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }
                Buffer.prototype.write = function write(string, offset, length, encoding) {
                  if (offset === void 0) {
                    encoding = "utf8";
                    length = this.length;
                    offset = 0;
                  } else if (length === void 0 && typeof offset === "string") {
                    encoding = offset;
                    length = this.length;
                    offset = 0;
                  } else if (isFinite(offset)) {
                    offset = offset >>> 0;
                    if (isFinite(length)) {
                      length = length >>> 0;
                      if (encoding === void 0)
                        encoding = "utf8";
                    } else {
                      encoding = length;
                      length = void 0;
                    }
                  } else {
                    throw new Error(
                      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                    );
                  }
                  var remaining = this.length - offset;
                  if (length === void 0 || length > remaining)
                    length = remaining;
                  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                  }
                  if (!encoding)
                    encoding = "utf8";
                  var loweredCase = false;
                  for (; ; ) {
                    switch (encoding) {
                      case "hex":
                        return hexWrite(this, string, offset, length);
                      case "utf8":
                      case "utf-8":
                        return utf8Write(this, string, offset, length);
                      case "ascii":
                        return asciiWrite(this, string, offset, length);
                      case "latin1":
                      case "binary":
                        return latin1Write(this, string, offset, length);
                      case "base64":
                        return base64Write(this, string, offset, length);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return ucs2Write(this, string, offset, length);
                      default:
                        if (loweredCase)
                          throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                  }
                };
                Buffer.prototype.toJSON = function toJSON() {
                  return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                  };
                };
                function base64Slice(buf, start, end) {
                  if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf);
                  } else {
                    return base64.fromByteArray(buf.slice(start, end));
                  }
                }
                function utf8Slice(buf, start, end) {
                  end = Math.min(buf.length, end);
                  var res = [];
                  var i = start;
                  while (i < end) {
                    var firstByte = buf[i];
                    var codePoint = null;
                    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                      var secondByte, thirdByte, fourthByte, tempCodePoint;
                      switch (bytesPerSequence) {
                        case 1:
                          if (firstByte < 128) {
                            codePoint = firstByte;
                          }
                          break;
                        case 2:
                          secondByte = buf[i + 1];
                          if ((secondByte & 192) === 128) {
                            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                            if (tempCodePoint > 127) {
                              codePoint = tempCodePoint;
                            }
                          }
                          break;
                        case 3:
                          secondByte = buf[i + 1];
                          thirdByte = buf[i + 2];
                          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                              codePoint = tempCodePoint;
                            }
                          }
                          break;
                        case 4:
                          secondByte = buf[i + 1];
                          thirdByte = buf[i + 2];
                          fourthByte = buf[i + 3];
                          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                              codePoint = tempCodePoint;
                            }
                          }
                      }
                    }
                    if (codePoint === null) {
                      codePoint = 65533;
                      bytesPerSequence = 1;
                    } else if (codePoint > 65535) {
                      codePoint -= 65536;
                      res.push(codePoint >>> 10 & 1023 | 55296);
                      codePoint = 56320 | codePoint & 1023;
                    }
                    res.push(codePoint);
                    i += bytesPerSequence;
                  }
                  return decodeCodePointsArray(res);
                }
                var MAX_ARGUMENTS_LENGTH = 4096;
                function decodeCodePointsArray(codePoints) {
                  var len = codePoints.length;
                  if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints);
                  }
                  var res = "";
                  var i = 0;
                  while (i < len) {
                    res += String.fromCharCode.apply(
                      String,
                      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                    );
                  }
                  return res;
                }
                function asciiSlice(buf, start, end) {
                  var ret = "";
                  end = Math.min(buf.length, end);
                  for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 127);
                  }
                  return ret;
                }
                function latin1Slice(buf, start, end) {
                  var ret = "";
                  end = Math.min(buf.length, end);
                  for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i]);
                  }
                  return ret;
                }
                function hexSlice(buf, start, end) {
                  var len = buf.length;
                  if (!start || start < 0)
                    start = 0;
                  if (!end || end < 0 || end > len)
                    end = len;
                  var out = "";
                  for (var i = start; i < end; ++i) {
                    out += hexSliceLookupTable[buf[i]];
                  }
                  return out;
                }
                function utf16leSlice(buf, start, end) {
                  var bytes = buf.slice(start, end);
                  var res = "";
                  for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                  }
                  return res;
                }
                Buffer.prototype.slice = function slice(start, end) {
                  var len = this.length;
                  start = ~~start;
                  end = end === void 0 ? len : ~~end;
                  if (start < 0) {
                    start += len;
                    if (start < 0)
                      start = 0;
                  } else if (start > len) {
                    start = len;
                  }
                  if (end < 0) {
                    end += len;
                    if (end < 0)
                      end = 0;
                  } else if (end > len) {
                    end = len;
                  }
                  if (end < start)
                    end = start;
                  var newBuf = this.subarray(start, end);
                  Object.setPrototypeOf(newBuf, Buffer.prototype);
                  return newBuf;
                };
                function checkOffset(offset, ext, length) {
                  if (offset % 1 !== 0 || offset < 0)
                    throw new RangeError("offset is not uint");
                  if (offset + ext > length)
                    throw new RangeError("Trying to access beyond buffer length");
                }
                Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var val = this[offset];
                  var mul = 1;
                  var i = 0;
                  while (++i < byteLength2 && (mul *= 256)) {
                    val += this[offset + i] * mul;
                  }
                  return val;
                };
                Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    checkOffset(offset, byteLength2, this.length);
                  }
                  var val = this[offset + --byteLength2];
                  var mul = 1;
                  while (byteLength2 > 0 && (mul *= 256)) {
                    val += this[offset + --byteLength2] * mul;
                  }
                  return val;
                };
                Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 1, this.length);
                  return this[offset];
                };
                Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  return this[offset] | this[offset + 1] << 8;
                };
                Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  return this[offset] << 8 | this[offset + 1];
                };
                Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
                };
                Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                };
                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var val = this[offset];
                  var mul = 1;
                  var i = 0;
                  while (++i < byteLength2 && (mul *= 256)) {
                    val += this[offset + i] * mul;
                  }
                  mul *= 128;
                  if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength2);
                  return val;
                };
                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var i = byteLength2;
                  var mul = 1;
                  var val = this[offset + --i];
                  while (i > 0 && (mul *= 256)) {
                    val += this[offset + --i] * mul;
                  }
                  mul *= 128;
                  if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength2);
                  return val;
                };
                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 1, this.length);
                  if (!(this[offset] & 128))
                    return this[offset];
                  return (255 - this[offset] + 1) * -1;
                };
                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  var val = this[offset] | this[offset + 1] << 8;
                  return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  var val = this[offset + 1] | this[offset] << 8;
                  return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                };
                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                };
                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return ieee754.read(this, offset, true, 23, 4);
                };
                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return ieee754.read(this, offset, false, 23, 4);
                };
                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 8, this.length);
                  return ieee754.read(this, offset, true, 52, 8);
                };
                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 8, this.length);
                  return ieee754.read(this, offset, false, 52, 8);
                };
                function checkInt(buf, value, offset, ext, max, min) {
                  if (!Buffer.isBuffer(buf))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                  if (value > max || value < min)
                    throw new RangeError('"value" argument is out of bounds');
                  if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                }
                Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                    checkInt(this, value, offset, byteLength2, maxBytes, 0);
                  }
                  var mul = 1;
                  var i = 0;
                  this[offset] = value & 255;
                  while (++i < byteLength2 && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                    checkInt(this, value, offset, byteLength2, maxBytes, 0);
                  }
                  var i = byteLength2 - 1;
                  var mul = 1;
                  this[offset + i] = value & 255;
                  while (--i >= 0 && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 1, 255, 0);
                  this[offset] = value & 255;
                  return offset + 1;
                };
                Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 65535, 0);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  return offset + 2;
                };
                Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 65535, 0);
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                  return offset + 2;
                };
                Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 4294967295, 0);
                  this[offset + 3] = value >>> 24;
                  this[offset + 2] = value >>> 16;
                  this[offset + 1] = value >>> 8;
                  this[offset] = value & 255;
                  return offset + 4;
                };
                Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 4294967295, 0);
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                  return offset + 4;
                };
                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength2 - 1);
                    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                  }
                  var i = 0;
                  var mul = 1;
                  var sub = 0;
                  this[offset] = value & 255;
                  while (++i < byteLength2 && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                      sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength2 - 1);
                    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                  }
                  var i = byteLength2 - 1;
                  var mul = 1;
                  var sub = 0;
                  this[offset + i] = value & 255;
                  while (--i >= 0 && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                      sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 1, 127, -128);
                  if (value < 0)
                    value = 255 + value + 1;
                  this[offset] = value & 255;
                  return offset + 1;
                };
                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 32767, -32768);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  return offset + 2;
                };
                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 32767, -32768);
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                  return offset + 2;
                };
                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 2147483647, -2147483648);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  this[offset + 2] = value >>> 16;
                  this[offset + 3] = value >>> 24;
                  return offset + 4;
                };
                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 2147483647, -2147483648);
                  if (value < 0)
                    value = 4294967295 + value + 1;
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                  return offset + 4;
                };
                function checkIEEE754(buf, value, offset, ext, max, min) {
                  if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                  if (offset < 0)
                    throw new RangeError("Index out of range");
                }
                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                  }
                  ieee754.write(buf, value, offset, littleEndian, 23, 4);
                  return offset + 4;
                }
                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                  return writeFloat(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                  return writeFloat(this, value, offset, false, noAssert);
                };
                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                  }
                  ieee754.write(buf, value, offset, littleEndian, 52, 8);
                  return offset + 8;
                }
                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                  return writeDouble(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                  return writeDouble(this, value, offset, false, noAssert);
                };
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                  if (!Buffer.isBuffer(target))
                    throw new TypeError("argument should be a Buffer");
                  if (!start)
                    start = 0;
                  if (!end && end !== 0)
                    end = this.length;
                  if (targetStart >= target.length)
                    targetStart = target.length;
                  if (!targetStart)
                    targetStart = 0;
                  if (end > 0 && end < start)
                    end = start;
                  if (end === start)
                    return 0;
                  if (target.length === 0 || this.length === 0)
                    return 0;
                  if (targetStart < 0) {
                    throw new RangeError("targetStart out of bounds");
                  }
                  if (start < 0 || start >= this.length)
                    throw new RangeError("Index out of range");
                  if (end < 0)
                    throw new RangeError("sourceEnd out of bounds");
                  if (end > this.length)
                    end = this.length;
                  if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start;
                  }
                  var len = end - start;
                  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(targetStart, start, end);
                  } else if (this === target && start < targetStart && targetStart < end) {
                    for (var i = len - 1; i >= 0; --i) {
                      target[i + targetStart] = this[i + start];
                    }
                  } else {
                    Uint8Array.prototype.set.call(
                      target,
                      this.subarray(start, end),
                      targetStart
                    );
                  }
                  return len;
                };
                Buffer.prototype.fill = function fill(val, start, end, encoding) {
                  if (typeof val === "string") {
                    if (typeof start === "string") {
                      encoding = start;
                      start = 0;
                      end = this.length;
                    } else if (typeof end === "string") {
                      encoding = end;
                      end = this.length;
                    }
                    if (encoding !== void 0 && typeof encoding !== "string") {
                      throw new TypeError("encoding must be a string");
                    }
                    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                      throw new TypeError("Unknown encoding: " + encoding);
                    }
                    if (val.length === 1) {
                      var code = val.charCodeAt(0);
                      if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                        val = code;
                      }
                    }
                  } else if (typeof val === "number") {
                    val = val & 255;
                  } else if (typeof val === "boolean") {
                    val = Number(val);
                  }
                  if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError("Out of range index");
                  }
                  if (end <= start) {
                    return this;
                  }
                  start = start >>> 0;
                  end = end === void 0 ? this.length : end >>> 0;
                  if (!val)
                    val = 0;
                  var i;
                  if (typeof val === "number") {
                    for (i = start; i < end; ++i) {
                      this[i] = val;
                    }
                  } else {
                    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                    var len = bytes.length;
                    if (len === 0) {
                      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                    }
                    for (i = 0; i < end - start; ++i) {
                      this[i + start] = bytes[i % len];
                    }
                  }
                  return this;
                };
                var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                function base64clean(str) {
                  str = str.split("=")[0];
                  str = str.trim().replace(INVALID_BASE64_RE, "");
                  if (str.length < 2)
                    return "";
                  while (str.length % 4 !== 0) {
                    str = str + "=";
                  }
                  return str;
                }
                function utf8ToBytes(string, units) {
                  units = units || Infinity;
                  var codePoint;
                  var length = string.length;
                  var leadSurrogate = null;
                  var bytes = [];
                  for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i);
                    if (codePoint > 55295 && codePoint < 57344) {
                      if (!leadSurrogate) {
                        if (codePoint > 56319) {
                          if ((units -= 3) > -1)
                            bytes.push(239, 191, 189);
                          continue;
                        } else if (i + 1 === length) {
                          if ((units -= 3) > -1)
                            bytes.push(239, 191, 189);
                          continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                      }
                      if (codePoint < 56320) {
                        if ((units -= 3) > -1)
                          bytes.push(239, 191, 189);
                        leadSurrogate = codePoint;
                        continue;
                      }
                      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                    } else if (leadSurrogate) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                    }
                    leadSurrogate = null;
                    if (codePoint < 128) {
                      if ((units -= 1) < 0)
                        break;
                      bytes.push(codePoint);
                    } else if (codePoint < 2048) {
                      if ((units -= 2) < 0)
                        break;
                      bytes.push(
                        codePoint >> 6 | 192,
                        codePoint & 63 | 128
                      );
                    } else if (codePoint < 65536) {
                      if ((units -= 3) < 0)
                        break;
                      bytes.push(
                        codePoint >> 12 | 224,
                        codePoint >> 6 & 63 | 128,
                        codePoint & 63 | 128
                      );
                    } else if (codePoint < 1114112) {
                      if ((units -= 4) < 0)
                        break;
                      bytes.push(
                        codePoint >> 18 | 240,
                        codePoint >> 12 & 63 | 128,
                        codePoint >> 6 & 63 | 128,
                        codePoint & 63 | 128
                      );
                    } else {
                      throw new Error("Invalid code point");
                    }
                  }
                  return bytes;
                }
                function asciiToBytes(str) {
                  var byteArray = [];
                  for (var i = 0; i < str.length; ++i) {
                    byteArray.push(str.charCodeAt(i) & 255);
                  }
                  return byteArray;
                }
                function utf16leToBytes(str, units) {
                  var c, hi, lo;
                  var byteArray = [];
                  for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0)
                      break;
                    c = str.charCodeAt(i);
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push(lo);
                    byteArray.push(hi);
                  }
                  return byteArray;
                }
                function base64ToBytes(str) {
                  return base64.toByteArray(base64clean(str));
                }
                function blitBuffer(src, dst, offset, length) {
                  for (var i = 0; i < length; ++i) {
                    if (i + offset >= dst.length || i >= src.length)
                      break;
                    dst[i + offset] = src[i];
                  }
                  return i;
                }
                function isInstance(obj, type) {
                  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
                }
                function numberIsNaN(obj) {
                  return obj !== obj;
                }
                var hexSliceLookupTable = function() {
                  var alphabet = "0123456789abcdef";
                  var table = new Array(256);
                  for (var i = 0; i < 16; ++i) {
                    var i16 = i * 16;
                    for (var j = 0; j < 16; ++j) {
                      table[i16 + j] = alphabet[i] + alphabet[j];
                    }
                  }
                  return table;
                }();
              }
            ),
            /***/
            645: (
              /***/
              (__unused_webpack_module, exports2) => {
                exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
                  var e, m;
                  var eLen = nBytes * 8 - mLen - 1;
                  var eMax = (1 << eLen) - 1;
                  var eBias = eMax >> 1;
                  var nBits = -7;
                  var i = isLE ? nBytes - 1 : 0;
                  var d = isLE ? -1 : 1;
                  var s = buffer[offset + i];
                  i += d;
                  e = s & (1 << -nBits) - 1;
                  s >>= -nBits;
                  nBits += eLen;
                  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
                  }
                  m = e & (1 << -nBits) - 1;
                  e >>= -nBits;
                  nBits += mLen;
                  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
                  }
                  if (e === 0) {
                    e = 1 - eBias;
                  } else if (e === eMax) {
                    return m ? NaN : (s ? -1 : 1) * Infinity;
                  } else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                  }
                  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                };
                exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                  var e, m, c;
                  var eLen = nBytes * 8 - mLen - 1;
                  var eMax = (1 << eLen) - 1;
                  var eBias = eMax >> 1;
                  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                  var i = isLE ? 0 : nBytes - 1;
                  var d = isLE ? 1 : -1;
                  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
                  value = Math.abs(value);
                  if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                  } else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                      e--;
                      c *= 2;
                    }
                    if (e + eBias >= 1) {
                      value += rt / c;
                    } else {
                      value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                      e++;
                      c /= 2;
                    }
                    if (e + eBias >= eMax) {
                      m = 0;
                      e = eMax;
                    } else if (e + eBias >= 1) {
                      m = (value * c - 1) * Math.pow(2, mLen);
                      e = e + eBias;
                    } else {
                      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                      e = 0;
                    }
                  }
                  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
                  }
                  e = e << mLen | m;
                  eLen += mLen;
                  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
                  }
                  buffer[offset + i - d] |= s * 128;
                };
              }
            ),
            /***/
            2587: (
              /***/
              (module2) => {
                "use strict";
                function hasOwnProperty(obj, prop) {
                  return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                module2.exports = function(qs, sep, eq, options) {
                  sep = sep || "&";
                  eq = eq || "=";
                  var obj = {};
                  if (typeof qs !== "string" || qs.length === 0) {
                    return obj;
                  }
                  var regexp = /\+/g;
                  qs = qs.split(sep);
                  var maxKeys = 1e3;
                  if (options && typeof options.maxKeys === "number") {
                    maxKeys = options.maxKeys;
                  }
                  var len = qs.length;
                  if (maxKeys > 0 && len > maxKeys) {
                    len = maxKeys;
                  }
                  for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
                    if (idx >= 0) {
                      kstr = x.substr(0, idx);
                      vstr = x.substr(idx + 1);
                    } else {
                      kstr = x;
                      vstr = "";
                    }
                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);
                    if (!hasOwnProperty(obj, k)) {
                      obj[k] = v;
                    } else if (Array.isArray(obj[k])) {
                      obj[k].push(v);
                    } else {
                      obj[k] = [obj[k], v];
                    }
                  }
                  return obj;
                };
              }
            ),
            /***/
            2361: (
              /***/
              (module2) => {
                "use strict";
                var stringifyPrimitive = function(v) {
                  switch (typeof v) {
                    case "string":
                      return v;
                    case "boolean":
                      return v ? "true" : "false";
                    case "number":
                      return isFinite(v) ? v : "";
                    default:
                      return "";
                  }
                };
                module2.exports = function(obj, sep, eq, name2) {
                  sep = sep || "&";
                  eq = eq || "=";
                  if (obj === null) {
                    obj = void 0;
                  }
                  if (typeof obj === "object") {
                    return Object.keys(obj).map(function(k) {
                      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                      if (Array.isArray(obj[k])) {
                        return obj[k].map(function(v) {
                          return ks + encodeURIComponent(stringifyPrimitive(v));
                        }).join(sep);
                      } else {
                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                      }
                    }).join(sep);
                  }
                  if (!name2)
                    return "";
                  return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
                };
              }
            ),
            /***/
            7673: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                exports2.decode = exports2.parse = __webpack_require__2(2587);
                exports2.encode = exports2.stringify = __webpack_require__2(2361);
              }
            ),
            /***/
            1798: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var MAX_BYTES = 65536;
                var MAX_UINT32 = 4294967295;
                function oldBrowser() {
                  throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
                }
                var Buffer = __webpack_require__2(9509).Buffer;
                var crypto2 = __webpack_require__2.g.crypto || __webpack_require__2.g.msCrypto;
                if (crypto2 && crypto2.getRandomValues) {
                  module2.exports = randomBytes;
                } else {
                  module2.exports = oldBrowser;
                }
                function randomBytes(size, cb) {
                  if (size > MAX_UINT32)
                    throw new RangeError("requested too many random bytes");
                  var bytes = Buffer.allocUnsafe(size);
                  if (size > 0) {
                    if (size > MAX_BYTES) {
                      for (var generated = 0; generated < size; generated += MAX_BYTES) {
                        crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
                      }
                    } else {
                      crypto2.getRandomValues(bytes);
                    }
                  }
                  if (typeof cb === "function") {
                    return process.nextTick(function() {
                      cb(null, bytes);
                    });
                  }
                  return bytes;
                }
              }
            ),
            /***/
            9509: (
              /***/
              (module2, exports2, __webpack_require__2) => {
                var buffer = __webpack_require__2(8764);
                var Buffer = buffer.Buffer;
                function copyProps(src, dst) {
                  for (var key in src) {
                    dst[key] = src[key];
                  }
                }
                if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                  module2.exports = buffer;
                } else {
                  copyProps(buffer, exports2);
                  exports2.Buffer = SafeBuffer;
                }
                function SafeBuffer(arg, encodingOrOffset, length) {
                  return Buffer(arg, encodingOrOffset, length);
                }
                SafeBuffer.prototype = Object.create(Buffer.prototype);
                copyProps(Buffer, SafeBuffer);
                SafeBuffer.from = function(arg, encodingOrOffset, length) {
                  if (typeof arg === "number") {
                    throw new TypeError("Argument must not be a number");
                  }
                  return Buffer(arg, encodingOrOffset, length);
                };
                SafeBuffer.alloc = function(size, fill, encoding) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  var buf = Buffer(size);
                  if (fill !== void 0) {
                    if (typeof encoding === "string") {
                      buf.fill(fill, encoding);
                    } else {
                      buf.fill(fill);
                    }
                  } else {
                    buf.fill(0);
                  }
                  return buf;
                };
                SafeBuffer.allocUnsafe = function(size) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  return Buffer(size);
                };
                SafeBuffer.allocUnsafeSlow = function(size) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  return buffer.SlowBuffer(size);
                };
              }
            ),
            /***/
            2511: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                module2 = __webpack_require__2.nmd(module2);
                var __WEBPACK_AMD_DEFINE_RESULT__;
                ;
                (function(root) {
                  var freeExports = exports2 && !exports2.nodeType && exports2;
                  var freeModule = module2 && !module2.nodeType && module2;
                  var freeGlobal = typeof __webpack_require__2.g == "object" && __webpack_require__2.g;
                  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                    root = freeGlobal;
                  }
                  var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                    "overflow": "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                  }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
                  function error(type) {
                    throw RangeError(errors[type]);
                  }
                  function map(array, fn) {
                    var length = array.length;
                    var result = [];
                    while (length--) {
                      result[length] = fn(array[length]);
                    }
                    return result;
                  }
                  function mapDomain(string, fn) {
                    var parts = string.split("@");
                    var result = "";
                    if (parts.length > 1) {
                      result = parts[0] + "@";
                      string = parts[1];
                    }
                    string = string.replace(regexSeparators, ".");
                    var labels = string.split(".");
                    var encoded = map(labels, fn).join(".");
                    return result + encoded;
                  }
                  function ucs2decode(string) {
                    var output = [], counter = 0, length = string.length, value, extra;
                    while (counter < length) {
                      value = string.charCodeAt(counter++);
                      if (value >= 55296 && value <= 56319 && counter < length) {
                        extra = string.charCodeAt(counter++);
                        if ((extra & 64512) == 56320) {
                          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                        } else {
                          output.push(value);
                          counter--;
                        }
                      } else {
                        output.push(value);
                      }
                    }
                    return output;
                  }
                  function ucs2encode(array) {
                    return map(array, function(value) {
                      var output = "";
                      if (value > 65535) {
                        value -= 65536;
                        output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                        value = 56320 | value & 1023;
                      }
                      output += stringFromCharCode(value);
                      return output;
                    }).join("");
                  }
                  function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) {
                      return codePoint - 22;
                    }
                    if (codePoint - 65 < 26) {
                      return codePoint - 65;
                    }
                    if (codePoint - 97 < 26) {
                      return codePoint - 97;
                    }
                    return base;
                  }
                  function digitToBasic(digit, flag) {
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                  }
                  function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                      delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                  }
                  function decode(input) {
                    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
                    basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                      basic = 0;
                    }
                    for (j = 0; j < basic; ++j) {
                      if (input.charCodeAt(j) >= 128) {
                        error("not-basic");
                      }
                      output.push(input.charCodeAt(j));
                    }
                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                      for (oldi = i, w = 1, k = base; ; k += base) {
                        if (index >= inputLength) {
                          error("invalid-input");
                        }
                        digit = basicToDigit(input.charCodeAt(index++));
                        if (digit >= base || digit > floor((maxInt - i) / w)) {
                          error("overflow");
                        }
                        i += digit * w;
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (digit < t) {
                          break;
                        }
                        baseMinusT = base - t;
                        if (w > floor(maxInt / baseMinusT)) {
                          error("overflow");
                        }
                        w *= baseMinusT;
                      }
                      out = output.length + 1;
                      bias = adapt(i - oldi, out, oldi == 0);
                      if (floor(i / out) > maxInt - n) {
                        error("overflow");
                      }
                      n += floor(i / out);
                      i %= out;
                      output.splice(i++, 0, n);
                    }
                    return ucs2encode(output);
                  }
                  function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                    input = ucs2decode(input);
                    inputLength = input.length;
                    n = initialN;
                    delta = 0;
                    bias = initialBias;
                    for (j = 0; j < inputLength; ++j) {
                      currentValue = input[j];
                      if (currentValue < 128) {
                        output.push(stringFromCharCode(currentValue));
                      }
                    }
                    handledCPCount = basicLength = output.length;
                    if (basicLength) {
                      output.push(delimiter);
                    }
                    while (handledCPCount < inputLength) {
                      for (m = maxInt, j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue >= n && currentValue < m) {
                          m = currentValue;
                        }
                      }
                      handledCPCountPlusOne = handledCPCount + 1;
                      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                        error("overflow");
                      }
                      delta += (m - n) * handledCPCountPlusOne;
                      n = m;
                      for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < n && ++delta > maxInt) {
                          error("overflow");
                        }
                        if (currentValue == n) {
                          for (q = delta, k = base; ; k += base) {
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                              break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(
                              stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                            );
                            q = floor(qMinusT / baseMinusT);
                          }
                          output.push(stringFromCharCode(digitToBasic(q, 0)));
                          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                          delta = 0;
                          ++handledCPCount;
                        }
                      }
                      ++delta;
                      ++n;
                    }
                    return output.join("");
                  }
                  function toUnicode(input) {
                    return mapDomain(input, function(string) {
                      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                  }
                  function toASCII(input) {
                    return mapDomain(input, function(string) {
                      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                    });
                  }
                  punycode = {
                    /**
                     * A string representing the current Punycode.js version number.
                     * @memberOf punycode
                     * @type String
                     */
                    "version": "1.3.2",
                    /**
                     * An object of methods to convert from JavaScript's internal character
                     * representation (UCS-2) to Unicode code points, and back.
                     * @see <https://mathiasbynens.be/notes/javascript-encoding>
                     * @memberOf punycode
                     * @type Object
                     */
                    "ucs2": {
                      "decode": ucs2decode,
                      "encode": ucs2encode
                    },
                    "decode": decode,
                    "encode": encode,
                    "toASCII": toASCII,
                    "toUnicode": toUnicode
                  };
                  if (true) {
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                      return punycode;
                    }).call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                  } else {
                  }
                })(this);
              }
            ),
            /***/
            8575: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                var __webpack_unused_export__;
                var punycode = __webpack_require__2(2511);
                var util = __webpack_require__2(2502);
                __webpack_unused_export__ = urlParse;
                exports2.DB = urlResolve;
                __webpack_unused_export__ = urlResolveObject;
                __webpack_unused_export__ = urlFormat;
                __webpack_unused_export__ = Url;
                function Url() {
                  this.protocol = null;
                  this.slashes = null;
                  this.auth = null;
                  this.host = null;
                  this.port = null;
                  this.hostname = null;
                  this.hash = null;
                  this.search = null;
                  this.query = null;
                  this.pathname = null;
                  this.path = null;
                  this.href = null;
                }
                var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
                  "javascript": true,
                  "javascript:": true
                }, hostlessProtocol = {
                  "javascript": true,
                  "javascript:": true
                }, slashedProtocol = {
                  "http": true,
                  "https": true,
                  "ftp": true,
                  "gopher": true,
                  "file": true,
                  "http:": true,
                  "https:": true,
                  "ftp:": true,
                  "gopher:": true,
                  "file:": true
                }, querystring = __webpack_require__2(7673);
                function urlParse(url, parseQueryString, slashesDenoteHost) {
                  if (url && util.isObject(url) && url instanceof Url)
                    return url;
                  var u = new Url();
                  u.parse(url, parseQueryString, slashesDenoteHost);
                  return u;
                }
                Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
                  if (!util.isString(url)) {
                    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
                  }
                  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
                  uSplit[0] = uSplit[0].replace(slashRegex, "/");
                  url = uSplit.join(splitter);
                  var rest = url;
                  rest = rest.trim();
                  if (!slashesDenoteHost && url.split("#").length === 1) {
                    var simplePath = simplePathPattern.exec(rest);
                    if (simplePath) {
                      this.path = rest;
                      this.href = rest;
                      this.pathname = simplePath[1];
                      if (simplePath[2]) {
                        this.search = simplePath[2];
                        if (parseQueryString) {
                          this.query = querystring.parse(this.search.substr(1));
                        } else {
                          this.query = this.search.substr(1);
                        }
                      } else if (parseQueryString) {
                        this.search = "";
                        this.query = {};
                      }
                      return this;
                    }
                  }
                  var proto = protocolPattern.exec(rest);
                  if (proto) {
                    proto = proto[0];
                    var lowerProto = proto.toLowerCase();
                    this.protocol = lowerProto;
                    rest = rest.substr(proto.length);
                  }
                  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var slashes = rest.substr(0, 2) === "//";
                    if (slashes && !(proto && hostlessProtocol[proto])) {
                      rest = rest.substr(2);
                      this.slashes = true;
                    }
                  }
                  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                    var hostEnd = -1;
                    for (var i = 0; i < hostEndingChars.length; i++) {
                      var hec = rest.indexOf(hostEndingChars[i]);
                      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                        hostEnd = hec;
                    }
                    var auth, atSign;
                    if (hostEnd === -1) {
                      atSign = rest.lastIndexOf("@");
                    } else {
                      atSign = rest.lastIndexOf("@", hostEnd);
                    }
                    if (atSign !== -1) {
                      auth = rest.slice(0, atSign);
                      rest = rest.slice(atSign + 1);
                      this.auth = decodeURIComponent(auth);
                    }
                    hostEnd = -1;
                    for (var i = 0; i < nonHostChars.length; i++) {
                      var hec = rest.indexOf(nonHostChars[i]);
                      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                        hostEnd = hec;
                    }
                    if (hostEnd === -1)
                      hostEnd = rest.length;
                    this.host = rest.slice(0, hostEnd);
                    rest = rest.slice(hostEnd);
                    this.parseHost();
                    this.hostname = this.hostname || "";
                    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                    if (!ipv6Hostname) {
                      var hostparts = this.hostname.split(/\./);
                      for (var i = 0, l = hostparts.length; i < l; i++) {
                        var part = hostparts[i];
                        if (!part)
                          continue;
                        if (!part.match(hostnamePartPattern)) {
                          var newpart = "";
                          for (var j = 0, k = part.length; j < k; j++) {
                            if (part.charCodeAt(j) > 127) {
                              newpart += "x";
                            } else {
                              newpart += part[j];
                            }
                          }
                          if (!newpart.match(hostnamePartPattern)) {
                            var validParts = hostparts.slice(0, i);
                            var notHost = hostparts.slice(i + 1);
                            var bit = part.match(hostnamePartStart);
                            if (bit) {
                              validParts.push(bit[1]);
                              notHost.unshift(bit[2]);
                            }
                            if (notHost.length) {
                              rest = "/" + notHost.join(".") + rest;
                            }
                            this.hostname = validParts.join(".");
                            break;
                          }
                        }
                      }
                    }
                    if (this.hostname.length > hostnameMaxLen) {
                      this.hostname = "";
                    } else {
                      this.hostname = this.hostname.toLowerCase();
                    }
                    if (!ipv6Hostname) {
                      this.hostname = punycode.toASCII(this.hostname);
                    }
                    var p = this.port ? ":" + this.port : "";
                    var h = this.hostname || "";
                    this.host = h + p;
                    this.href += this.host;
                    if (ipv6Hostname) {
                      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                      if (rest[0] !== "/") {
                        rest = "/" + rest;
                      }
                    }
                  }
                  if (!unsafeProtocol[lowerProto]) {
                    for (var i = 0, l = autoEscape.length; i < l; i++) {
                      var ae = autoEscape[i];
                      if (rest.indexOf(ae) === -1)
                        continue;
                      var esc = encodeURIComponent(ae);
                      if (esc === ae) {
                        esc = escape(ae);
                      }
                      rest = rest.split(ae).join(esc);
                    }
                  }
                  var hash = rest.indexOf("#");
                  if (hash !== -1) {
                    this.hash = rest.substr(hash);
                    rest = rest.slice(0, hash);
                  }
                  var qm = rest.indexOf("?");
                  if (qm !== -1) {
                    this.search = rest.substr(qm);
                    this.query = rest.substr(qm + 1);
                    if (parseQueryString) {
                      this.query = querystring.parse(this.query);
                    }
                    rest = rest.slice(0, qm);
                  } else if (parseQueryString) {
                    this.search = "";
                    this.query = {};
                  }
                  if (rest)
                    this.pathname = rest;
                  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                    this.pathname = "/";
                  }
                  if (this.pathname || this.search) {
                    var p = this.pathname || "";
                    var s = this.search || "";
                    this.path = p + s;
                  }
                  this.href = this.format();
                  return this;
                };
                function urlFormat(obj) {
                  if (util.isString(obj))
                    obj = urlParse(obj);
                  if (!(obj instanceof Url))
                    return Url.prototype.format.call(obj);
                  return obj.format();
                }
                Url.prototype.format = function() {
                  var auth = this.auth || "";
                  if (auth) {
                    auth = encodeURIComponent(auth);
                    auth = auth.replace(/%3A/i, ":");
                    auth += "@";
                  }
                  var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
                  if (this.host) {
                    host = auth + this.host;
                  } else if (this.hostname) {
                    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
                    if (this.port) {
                      host += ":" + this.port;
                    }
                  }
                  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
                    query = querystring.stringify(this.query);
                  }
                  var search = this.search || query && "?" + query || "";
                  if (protocol && protocol.substr(-1) !== ":")
                    protocol += ":";
                  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
                    host = "//" + (host || "");
                    if (pathname && pathname.charAt(0) !== "/")
                      pathname = "/" + pathname;
                  } else if (!host) {
                    host = "";
                  }
                  if (hash && hash.charAt(0) !== "#")
                    hash = "#" + hash;
                  if (search && search.charAt(0) !== "?")
                    search = "?" + search;
                  pathname = pathname.replace(/[?#]/g, function(match) {
                    return encodeURIComponent(match);
                  });
                  search = search.replace("#", "%23");
                  return protocol + host + pathname + search + hash;
                };
                function urlResolve(source, relative) {
                  return urlParse(source, false, true).resolve(relative);
                }
                Url.prototype.resolve = function(relative) {
                  return this.resolveObject(urlParse(relative, false, true)).format();
                };
                function urlResolveObject(source, relative) {
                  if (!source)
                    return relative;
                  return urlParse(source, false, true).resolveObject(relative);
                }
                Url.prototype.resolveObject = function(relative) {
                  if (util.isString(relative)) {
                    var rel = new Url();
                    rel.parse(relative, false, true);
                    relative = rel;
                  }
                  var result = new Url();
                  var tkeys = Object.keys(this);
                  for (var tk = 0; tk < tkeys.length; tk++) {
                    var tkey = tkeys[tk];
                    result[tkey] = this[tkey];
                  }
                  result.hash = relative.hash;
                  if (relative.href === "") {
                    result.href = result.format();
                    return result;
                  }
                  if (relative.slashes && !relative.protocol) {
                    var rkeys = Object.keys(relative);
                    for (var rk = 0; rk < rkeys.length; rk++) {
                      var rkey = rkeys[rk];
                      if (rkey !== "protocol")
                        result[rkey] = relative[rkey];
                    }
                    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                      result.path = result.pathname = "/";
                    }
                    result.href = result.format();
                    return result;
                  }
                  if (relative.protocol && relative.protocol !== result.protocol) {
                    if (!slashedProtocol[relative.protocol]) {
                      var keys = Object.keys(relative);
                      for (var v = 0; v < keys.length; v++) {
                        var k = keys[v];
                        result[k] = relative[k];
                      }
                      result.href = result.format();
                      return result;
                    }
                    result.protocol = relative.protocol;
                    if (!relative.host && !hostlessProtocol[relative.protocol]) {
                      var relPath = (relative.pathname || "").split("/");
                      while (relPath.length && !(relative.host = relPath.shift()))
                        ;
                      if (!relative.host)
                        relative.host = "";
                      if (!relative.hostname)
                        relative.hostname = "";
                      if (relPath[0] !== "")
                        relPath.unshift("");
                      if (relPath.length < 2)
                        relPath.unshift("");
                      result.pathname = relPath.join("/");
                    } else {
                      result.pathname = relative.pathname;
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    result.host = relative.host || "";
                    result.auth = relative.auth;
                    result.hostname = relative.hostname || relative.host;
                    result.port = relative.port;
                    if (result.pathname || result.search) {
                      var p = result.pathname || "";
                      var s = result.search || "";
                      result.path = p + s;
                    }
                    result.slashes = result.slashes || relative.slashes;
                    result.href = result.format();
                    return result;
                  }
                  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
                  if (psychotic) {
                    result.hostname = "";
                    result.port = null;
                    if (result.host) {
                      if (srcPath[0] === "")
                        srcPath[0] = result.host;
                      else
                        srcPath.unshift(result.host);
                    }
                    result.host = "";
                    if (relative.protocol) {
                      relative.hostname = null;
                      relative.port = null;
                      if (relative.host) {
                        if (relPath[0] === "")
                          relPath[0] = relative.host;
                        else
                          relPath.unshift(relative.host);
                      }
                      relative.host = null;
                    }
                    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
                  }
                  if (isRelAbs) {
                    result.host = relative.host || relative.host === "" ? relative.host : result.host;
                    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
                    result.search = relative.search;
                    result.query = relative.query;
                    srcPath = relPath;
                  } else if (relPath.length) {
                    if (!srcPath)
                      srcPath = [];
                    srcPath.pop();
                    srcPath = srcPath.concat(relPath);
                    result.search = relative.search;
                    result.query = relative.query;
                  } else if (!util.isNullOrUndefined(relative.search)) {
                    if (psychotic) {
                      result.hostname = result.host = srcPath.shift();
                      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                      if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                      }
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                    }
                    result.href = result.format();
                    return result;
                  }
                  if (!srcPath.length) {
                    result.pathname = null;
                    if (result.search) {
                      result.path = "/" + result.search;
                    } else {
                      result.path = null;
                    }
                    result.href = result.format();
                    return result;
                  }
                  var last = srcPath.slice(-1)[0];
                  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
                  var up = 0;
                  for (var i = srcPath.length; i >= 0; i--) {
                    last = srcPath[i];
                    if (last === ".") {
                      srcPath.splice(i, 1);
                    } else if (last === "..") {
                      srcPath.splice(i, 1);
                      up++;
                    } else if (up) {
                      srcPath.splice(i, 1);
                      up--;
                    }
                  }
                  if (!mustEndAbs && !removeAllDots) {
                    for (; up--; up) {
                      srcPath.unshift("..");
                    }
                  }
                  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
                    srcPath.unshift("");
                  }
                  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                    srcPath.push("");
                  }
                  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
                  if (psychotic) {
                    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                      result.auth = authInHost.shift();
                      result.host = result.hostname = authInHost.shift();
                    }
                  }
                  mustEndAbs = mustEndAbs || result.host && srcPath.length;
                  if (mustEndAbs && !isAbsolute) {
                    srcPath.unshift("");
                  }
                  if (!srcPath.length) {
                    result.pathname = null;
                    result.path = null;
                  } else {
                    result.pathname = srcPath.join("/");
                  }
                  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                  }
                  result.auth = relative.auth || result.auth;
                  result.slashes = result.slashes || relative.slashes;
                  result.href = result.format();
                  return result;
                };
                Url.prototype.parseHost = function() {
                  var host = this.host;
                  var port = portPattern.exec(host);
                  if (port) {
                    port = port[0];
                    if (port !== ":") {
                      this.port = port.substr(1);
                    }
                    host = host.substr(0, host.length - port.length);
                  }
                  if (host)
                    this.hostname = host;
                };
              }
            ),
            /***/
            2502: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = {
                  isString: function(arg) {
                    return typeof arg === "string";
                  },
                  isObject: function(arg) {
                    return typeof arg === "object" && arg !== null;
                  },
                  isNull: function(arg) {
                    return arg === null;
                  },
                  isNullOrUndefined: function(arg) {
                    return arg == null;
                  }
                };
              }
            ),
            /***/
            8416: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                module2.exports = __webpack_require__2(41);
              }
            ),
            /***/
            6347: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                var settle = __webpack_require__2(8762);
                var cookies = __webpack_require__2(6164);
                var buildURL = __webpack_require__2(51);
                var buildFullPath = __webpack_require__2(6672);
                var parseHeaders = __webpack_require__2(9942);
                var isURLSameOrigin = __webpack_require__2(3789);
                var createError = __webpack_require__2(2604);
                module2.exports = function xhrAdapter(config) {
                  return new Promise(function dispatchXhrRequest(resolve, reject) {
                    var requestData = config.data;
                    var requestHeaders = config.headers;
                    if (utils.isFormData(requestData)) {
                      delete requestHeaders["Content-Type"];
                    }
                    var request = new XMLHttpRequest();
                    if (config.auth) {
                      var username = config.auth.username || "";
                      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
                      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
                    }
                    var fullPath = buildFullPath(config.baseURL, config.url);
                    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
                    request.timeout = config.timeout;
                    request.onreadystatechange = function handleLoad() {
                      if (!request || request.readyState !== 4) {
                        return;
                      }
                      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                        return;
                      }
                      var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
                      var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
                      var response = {
                        data: responseData,
                        status: request.status,
                        statusText: request.statusText,
                        headers: responseHeaders,
                        config,
                        request
                      };
                      settle(resolve, reject, response);
                      request = null;
                    };
                    request.onabort = function handleAbort() {
                      if (!request) {
                        return;
                      }
                      reject(createError("Request aborted", config, "ECONNABORTED", request));
                      request = null;
                    };
                    request.onerror = function handleError() {
                      reject(createError("Network Error", config, null, request));
                      request = null;
                    };
                    request.ontimeout = function handleTimeout() {
                      var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
                      if (config.timeoutErrorMessage) {
                        timeoutErrorMessage = config.timeoutErrorMessage;
                      }
                      reject(createError(
                        timeoutErrorMessage,
                        config,
                        "ECONNABORTED",
                        request
                      ));
                      request = null;
                    };
                    if (utils.isStandardBrowserEnv()) {
                      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
                      if (xsrfValue) {
                        requestHeaders[config.xsrfHeaderName] = xsrfValue;
                      }
                    }
                    if ("setRequestHeader" in request) {
                      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                          delete requestHeaders[key];
                        } else {
                          request.setRequestHeader(key, val);
                        }
                      });
                    }
                    if (!utils.isUndefined(config.withCredentials)) {
                      request.withCredentials = !!config.withCredentials;
                    }
                    if (config.responseType) {
                      try {
                        request.responseType = config.responseType;
                      } catch (e) {
                        if (config.responseType !== "json") {
                          throw e;
                        }
                      }
                    }
                    if (typeof config.onDownloadProgress === "function") {
                      request.addEventListener("progress", config.onDownloadProgress);
                    }
                    if (typeof config.onUploadProgress === "function" && request.upload) {
                      request.upload.addEventListener("progress", config.onUploadProgress);
                    }
                    if (config.cancelToken) {
                      config.cancelToken.promise.then(function onCanceled(cancel) {
                        if (!request) {
                          return;
                        }
                        request.abort();
                        reject(cancel);
                        request = null;
                      });
                    }
                    if (!requestData) {
                      requestData = null;
                    }
                    request.send(requestData);
                  });
                };
              }
            ),
            /***/
            41: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                var bind = __webpack_require__2(1330);
                var Axios = __webpack_require__2(2819);
                var mergeConfig = __webpack_require__2(7711);
                var defaults = __webpack_require__2(6450);
                function createInstance(defaultConfig) {
                  var context = new Axios(defaultConfig);
                  var instance = bind(Axios.prototype.request, context);
                  utils.extend(instance, Axios.prototype, context);
                  utils.extend(instance, context);
                  return instance;
                }
                var axios = createInstance(defaults);
                axios.Axios = Axios;
                axios.create = function create(instanceConfig) {
                  return createInstance(mergeConfig(axios.defaults, instanceConfig));
                };
                axios.Cancel = __webpack_require__2(7623);
                axios.CancelToken = __webpack_require__2(3803);
                axios.isCancel = __webpack_require__2(9328);
                axios.all = function all(promises) {
                  return Promise.all(promises);
                };
                axios.spread = __webpack_require__2(348);
                axios.isAxiosError = __webpack_require__2(839);
                module2.exports = axios;
                module2.exports.default = axios;
              }
            ),
            /***/
            7623: (
              /***/
              (module2) => {
                "use strict";
                function Cancel(message) {
                  this.message = message;
                }
                Cancel.prototype.toString = function toString() {
                  return "Cancel" + (this.message ? ": " + this.message : "");
                };
                Cancel.prototype.__CANCEL__ = true;
                module2.exports = Cancel;
              }
            ),
            /***/
            3803: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var Cancel = __webpack_require__2(7623);
                function CancelToken(executor) {
                  if (typeof executor !== "function") {
                    throw new TypeError("executor must be a function.");
                  }
                  var resolvePromise;
                  this.promise = new Promise(function promiseExecutor(resolve) {
                    resolvePromise = resolve;
                  });
                  var token = this;
                  executor(function cancel(message) {
                    if (token.reason) {
                      return;
                    }
                    token.reason = new Cancel(message);
                    resolvePromise(token.reason);
                  });
                }
                CancelToken.prototype.throwIfRequested = function throwIfRequested() {
                  if (this.reason) {
                    throw this.reason;
                  }
                };
                CancelToken.source = function source() {
                  var cancel;
                  var token = new CancelToken(function executor(c) {
                    cancel = c;
                  });
                  return {
                    token,
                    cancel
                  };
                };
                module2.exports = CancelToken;
              }
            ),
            /***/
            9328: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function isCancel(value) {
                  return !!(value && value.__CANCEL__);
                };
              }
            ),
            /***/
            2819: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                var buildURL = __webpack_require__2(51);
                var InterceptorManager = __webpack_require__2(3973);
                var dispatchRequest = __webpack_require__2(1639);
                var mergeConfig = __webpack_require__2(7711);
                function Axios(instanceConfig) {
                  this.defaults = instanceConfig;
                  this.interceptors = {
                    request: new InterceptorManager(),
                    response: new InterceptorManager()
                  };
                }
                Axios.prototype.request = function request(config) {
                  if (typeof config === "string") {
                    config = arguments[1] || {};
                    config.url = arguments[0];
                  } else {
                    config = config || {};
                  }
                  config = mergeConfig(this.defaults, config);
                  if (config.method) {
                    config.method = config.method.toLowerCase();
                  } else if (this.defaults.method) {
                    config.method = this.defaults.method.toLowerCase();
                  } else {
                    config.method = "get";
                  }
                  var chain = [dispatchRequest, void 0];
                  var promise = Promise.resolve(config);
                  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
                    chain.unshift(interceptor.fulfilled, interceptor.rejected);
                  });
                  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
                    chain.push(interceptor.fulfilled, interceptor.rejected);
                  });
                  while (chain.length) {
                    promise = promise.then(chain.shift(), chain.shift());
                  }
                  return promise;
                };
                Axios.prototype.getUri = function getUri(config) {
                  config = mergeConfig(this.defaults, config);
                  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
                };
                utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
                  Axios.prototype[method] = function(url, config) {
                    return this.request(mergeConfig(config || {}, {
                      method,
                      url,
                      data: (config || {}).data
                    }));
                  };
                });
                utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
                  Axios.prototype[method] = function(url, data, config) {
                    return this.request(mergeConfig(config || {}, {
                      method,
                      url,
                      data
                    }));
                  };
                });
                module2.exports = Axios;
              }
            ),
            /***/
            3973: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                function InterceptorManager() {
                  this.handlers = [];
                }
                InterceptorManager.prototype.use = function use(fulfilled, rejected) {
                  this.handlers.push({
                    fulfilled,
                    rejected
                  });
                  return this.handlers.length - 1;
                };
                InterceptorManager.prototype.eject = function eject(id) {
                  if (this.handlers[id]) {
                    this.handlers[id] = null;
                  }
                };
                InterceptorManager.prototype.forEach = function forEach(fn) {
                  utils.forEach(this.handlers, function forEachHandler(h) {
                    if (h !== null) {
                      fn(h);
                    }
                  });
                };
                module2.exports = InterceptorManager;
              }
            ),
            /***/
            6672: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var isAbsoluteURL = __webpack_require__2(1275);
                var combineURLs = __webpack_require__2(2345);
                module2.exports = function buildFullPath(baseURL, requestedURL) {
                  if (baseURL && !isAbsoluteURL(requestedURL)) {
                    return combineURLs(baseURL, requestedURL);
                  }
                  return requestedURL;
                };
              }
            ),
            /***/
            2604: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var enhanceError = __webpack_require__2(5898);
                module2.exports = function createError(message, config, code, request, response) {
                  var error = new Error(message);
                  return enhanceError(error, config, code, request, response);
                };
              }
            ),
            /***/
            1639: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                var transformData = __webpack_require__2(2244);
                var isCancel = __webpack_require__2(9328);
                var defaults = __webpack_require__2(6450);
                function throwIfCancellationRequested(config) {
                  if (config.cancelToken) {
                    config.cancelToken.throwIfRequested();
                  }
                }
                module2.exports = function dispatchRequest(config) {
                  throwIfCancellationRequested(config);
                  config.headers = config.headers || {};
                  config.data = transformData(
                    config.data,
                    config.headers,
                    config.transformRequest
                  );
                  config.headers = utils.merge(
                    config.headers.common || {},
                    config.headers[config.method] || {},
                    config.headers
                  );
                  utils.forEach(
                    ["delete", "get", "head", "post", "put", "patch", "common"],
                    function cleanHeaderConfig(method) {
                      delete config.headers[method];
                    }
                  );
                  var adapter = config.adapter || defaults.adapter;
                  return adapter(config).then(function onAdapterResolution(response) {
                    throwIfCancellationRequested(config);
                    response.data = transformData(
                      response.data,
                      response.headers,
                      config.transformResponse
                    );
                    return response;
                  }, function onAdapterRejection(reason) {
                    if (!isCancel(reason)) {
                      throwIfCancellationRequested(config);
                      if (reason && reason.response) {
                        reason.response.data = transformData(
                          reason.response.data,
                          reason.response.headers,
                          config.transformResponse
                        );
                      }
                    }
                    return Promise.reject(reason);
                  });
                };
              }
            ),
            /***/
            5898: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function enhanceError(error, config, code, request, response) {
                  error.config = config;
                  if (code) {
                    error.code = code;
                  }
                  error.request = request;
                  error.response = response;
                  error.isAxiosError = true;
                  error.toJSON = function toJSON() {
                    return {
                      // Standard
                      message: this.message,
                      name: this.name,
                      // Microsoft
                      description: this.description,
                      number: this.number,
                      // Mozilla
                      fileName: this.fileName,
                      lineNumber: this.lineNumber,
                      columnNumber: this.columnNumber,
                      stack: this.stack,
                      // Axios
                      config: this.config,
                      code: this.code
                    };
                  };
                  return error;
                };
              }
            ),
            /***/
            7711: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                module2.exports = function mergeConfig(config1, config2) {
                  config2 = config2 || {};
                  var config = {};
                  var valueFromConfig2Keys = ["url", "method", "data"];
                  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
                  var defaultToConfig2Keys = [
                    "baseURL",
                    "transformRequest",
                    "transformResponse",
                    "paramsSerializer",
                    "timeout",
                    "timeoutMessage",
                    "withCredentials",
                    "adapter",
                    "responseType",
                    "xsrfCookieName",
                    "xsrfHeaderName",
                    "onUploadProgress",
                    "onDownloadProgress",
                    "decompress",
                    "maxContentLength",
                    "maxBodyLength",
                    "maxRedirects",
                    "transport",
                    "httpAgent",
                    "httpsAgent",
                    "cancelToken",
                    "socketPath",
                    "responseEncoding"
                  ];
                  var directMergeKeys = ["validateStatus"];
                  function getMergedValue(target, source) {
                    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
                      return utils.merge(target, source);
                    } else if (utils.isPlainObject(source)) {
                      return utils.merge({}, source);
                    } else if (utils.isArray(source)) {
                      return source.slice();
                    }
                    return source;
                  }
                  function mergeDeepProperties(prop) {
                    if (!utils.isUndefined(config2[prop])) {
                      config[prop] = getMergedValue(config1[prop], config2[prop]);
                    } else if (!utils.isUndefined(config1[prop])) {
                      config[prop] = getMergedValue(void 0, config1[prop]);
                    }
                  }
                  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
                    if (!utils.isUndefined(config2[prop])) {
                      config[prop] = getMergedValue(void 0, config2[prop]);
                    }
                  });
                  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
                  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
                    if (!utils.isUndefined(config2[prop])) {
                      config[prop] = getMergedValue(void 0, config2[prop]);
                    } else if (!utils.isUndefined(config1[prop])) {
                      config[prop] = getMergedValue(void 0, config1[prop]);
                    }
                  });
                  utils.forEach(directMergeKeys, function merge(prop) {
                    if (prop in config2) {
                      config[prop] = getMergedValue(config1[prop], config2[prop]);
                    } else if (prop in config1) {
                      config[prop] = getMergedValue(void 0, config1[prop]);
                    }
                  });
                  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
                  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
                    return axiosKeys.indexOf(key) === -1;
                  });
                  utils.forEach(otherKeys, mergeDeepProperties);
                  return config;
                };
              }
            ),
            /***/
            8762: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var createError = __webpack_require__2(2604);
                module2.exports = function settle(resolve, reject, response) {
                  var validateStatus = response.config.validateStatus;
                  if (!response.status || !validateStatus || validateStatus(response.status)) {
                    resolve(response);
                  } else {
                    reject(createError(
                      "Request failed with status code " + response.status,
                      response.config,
                      null,
                      response.request,
                      response
                    ));
                  }
                };
              }
            ),
            /***/
            2244: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                module2.exports = function transformData(data, headers, fns) {
                  utils.forEach(fns, function transform(fn) {
                    data = fn(data, headers);
                  });
                  return data;
                };
              }
            ),
            /***/
            6450: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                var normalizeHeaderName = __webpack_require__2(2854);
                var DEFAULT_CONTENT_TYPE = {
                  "Content-Type": "application/x-www-form-urlencoded"
                };
                function setContentTypeIfUnset(headers, value) {
                  if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
                    headers["Content-Type"] = value;
                  }
                }
                function getDefaultAdapter() {
                  var adapter;
                  if (typeof XMLHttpRequest !== "undefined") {
                    adapter = __webpack_require__2(6347);
                  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
                    adapter = __webpack_require__2(6347);
                  }
                  return adapter;
                }
                var defaults = {
                  adapter: getDefaultAdapter(),
                  transformRequest: [function transformRequest(data, headers) {
                    normalizeHeaderName(headers, "Accept");
                    normalizeHeaderName(headers, "Content-Type");
                    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
                      return data;
                    }
                    if (utils.isArrayBufferView(data)) {
                      return data.buffer;
                    }
                    if (utils.isURLSearchParams(data)) {
                      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
                      return data.toString();
                    }
                    if (utils.isObject(data)) {
                      setContentTypeIfUnset(headers, "application/json;charset=utf-8");
                      return JSON.stringify(data);
                    }
                    return data;
                  }],
                  transformResponse: [function transformResponse(data) {
                    if (typeof data === "string") {
                      try {
                        data = JSON.parse(data);
                      } catch (e) {
                      }
                    }
                    return data;
                  }],
                  /**
                   * A timeout in milliseconds to abort a request. If set to 0 (default) a
                   * timeout is not created.
                   */
                  timeout: 0,
                  xsrfCookieName: "XSRF-TOKEN",
                  xsrfHeaderName: "X-XSRF-TOKEN",
                  maxContentLength: -1,
                  maxBodyLength: -1,
                  validateStatus: function validateStatus(status) {
                    return status >= 200 && status < 300;
                  }
                };
                defaults.headers = {
                  common: {
                    "Accept": "application/json, text/plain, */*"
                  }
                };
                utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
                  defaults.headers[method] = {};
                });
                utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
                  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
                });
                module2.exports = defaults;
              }
            ),
            /***/
            1330: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function bind(fn, thisArg) {
                  return function wrap() {
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; i++) {
                      args[i] = arguments[i];
                    }
                    return fn.apply(thisArg, args);
                  };
                };
              }
            ),
            /***/
            51: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                function encode(val) {
                  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
                }
                module2.exports = function buildURL(url, params, paramsSerializer) {
                  if (!params) {
                    return url;
                  }
                  var serializedParams;
                  if (paramsSerializer) {
                    serializedParams = paramsSerializer(params);
                  } else if (utils.isURLSearchParams(params)) {
                    serializedParams = params.toString();
                  } else {
                    var parts = [];
                    utils.forEach(params, function serialize(val, key) {
                      if (val === null || typeof val === "undefined") {
                        return;
                      }
                      if (utils.isArray(val)) {
                        key = key + "[]";
                      } else {
                        val = [val];
                      }
                      utils.forEach(val, function parseValue(v) {
                        if (utils.isDate(v)) {
                          v = v.toISOString();
                        } else if (utils.isObject(v)) {
                          v = JSON.stringify(v);
                        }
                        parts.push(encode(key) + "=" + encode(v));
                      });
                    });
                    serializedParams = parts.join("&");
                  }
                  if (serializedParams) {
                    var hashmarkIndex = url.indexOf("#");
                    if (hashmarkIndex !== -1) {
                      url = url.slice(0, hashmarkIndex);
                    }
                    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
                  }
                  return url;
                };
              }
            ),
            /***/
            2345: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function combineURLs(baseURL, relativeURL) {
                  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
                };
              }
            ),
            /***/
            6164: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                module2.exports = utils.isStandardBrowserEnv() ? (
                  // Standard browser envs support document.cookie
                  /* @__PURE__ */ function standardBrowserEnv() {
                    return {
                      write: function write(name2, value, expires, path, domain, secure) {
                        var cookie = [];
                        cookie.push(name2 + "=" + encodeURIComponent(value));
                        if (utils.isNumber(expires)) {
                          cookie.push("expires=" + new Date(expires).toGMTString());
                        }
                        if (utils.isString(path)) {
                          cookie.push("path=" + path);
                        }
                        if (utils.isString(domain)) {
                          cookie.push("domain=" + domain);
                        }
                        if (secure === true) {
                          cookie.push("secure");
                        }
                        document.cookie = cookie.join("; ");
                      },
                      read: function read(name2) {
                        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
                        return match ? decodeURIComponent(match[3]) : null;
                      },
                      remove: function remove(name2) {
                        this.write(name2, "", Date.now() - 864e5);
                      }
                    };
                  }()
                ) : (
                  // Non standard browser env (web workers, react-native) lack needed support.
                  /* @__PURE__ */ function nonStandardBrowserEnv() {
                    return {
                      write: function write() {
                      },
                      read: function read() {
                        return null;
                      },
                      remove: function remove() {
                      }
                    };
                  }()
                );
              }
            ),
            /***/
            1275: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function isAbsoluteURL(url) {
                  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
                };
              }
            ),
            /***/
            839: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function isAxiosError(payload) {
                  return typeof payload === "object" && payload.isAxiosError === true;
                };
              }
            ),
            /***/
            3789: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                module2.exports = utils.isStandardBrowserEnv() ? (
                  // Standard browser envs have full support of the APIs needed to test
                  // whether the request URL is of the same origin as current location.
                  function standardBrowserEnv() {
                    var msie = /(msie|trident)/i.test(navigator.userAgent);
                    var urlParsingNode = document.createElement("a");
                    var originURL;
                    function resolveURL(url) {
                      var href = url;
                      if (msie) {
                        urlParsingNode.setAttribute("href", href);
                        href = urlParsingNode.href;
                      }
                      urlParsingNode.setAttribute("href", href);
                      return {
                        href: urlParsingNode.href,
                        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                        host: urlParsingNode.host,
                        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                        hostname: urlParsingNode.hostname,
                        port: urlParsingNode.port,
                        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
                      };
                    }
                    originURL = resolveURL(window.location.href);
                    return function isURLSameOrigin(requestURL) {
                      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
                      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
                    };
                  }()
                ) : (
                  // Non standard browser envs (web workers, react-native) lack needed support.
                  /* @__PURE__ */ function nonStandardBrowserEnv() {
                    return function isURLSameOrigin() {
                      return true;
                    };
                  }()
                );
              }
            ),
            /***/
            2854: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                module2.exports = function normalizeHeaderName(headers, normalizedName) {
                  utils.forEach(headers, function processHeader(value, name2) {
                    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
                      headers[normalizedName] = value;
                      delete headers[name2];
                    }
                  });
                };
              }
            ),
            /***/
            9942: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var utils = __webpack_require__2(9053);
                var ignoreDuplicateOf = [
                  "age",
                  "authorization",
                  "content-length",
                  "content-type",
                  "etag",
                  "expires",
                  "from",
                  "host",
                  "if-modified-since",
                  "if-unmodified-since",
                  "last-modified",
                  "location",
                  "max-forwards",
                  "proxy-authorization",
                  "referer",
                  "retry-after",
                  "user-agent"
                ];
                module2.exports = function parseHeaders(headers) {
                  var parsed = {};
                  var key;
                  var val;
                  var i;
                  if (!headers) {
                    return parsed;
                  }
                  utils.forEach(headers.split("\n"), function parser(line) {
                    i = line.indexOf(":");
                    key = utils.trim(line.substr(0, i)).toLowerCase();
                    val = utils.trim(line.substr(i + 1));
                    if (key) {
                      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                        return;
                      }
                      if (key === "set-cookie") {
                        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
                      } else {
                        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
                      }
                    }
                  });
                  return parsed;
                };
              }
            ),
            /***/
            348: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function spread(callback) {
                  return function wrap(arr) {
                    return callback.apply(null, arr);
                  };
                };
              }
            ),
            /***/
            9053: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                var bind = __webpack_require__2(1330);
                var toString = Object.prototype.toString;
                function isArray(val) {
                  return toString.call(val) === "[object Array]";
                }
                function isUndefined(val) {
                  return typeof val === "undefined";
                }
                function isBuffer(val) {
                  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
                }
                function isArrayBuffer(val) {
                  return toString.call(val) === "[object ArrayBuffer]";
                }
                function isFormData(val) {
                  return typeof FormData !== "undefined" && val instanceof FormData;
                }
                function isArrayBufferView(val) {
                  var result;
                  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                    result = ArrayBuffer.isView(val);
                  } else {
                    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
                  }
                  return result;
                }
                function isString(val) {
                  return typeof val === "string";
                }
                function isNumber(val) {
                  return typeof val === "number";
                }
                function isObject(val) {
                  return val !== null && typeof val === "object";
                }
                function isPlainObject(val) {
                  if (toString.call(val) !== "[object Object]") {
                    return false;
                  }
                  var prototype = Object.getPrototypeOf(val);
                  return prototype === null || prototype === Object.prototype;
                }
                function isDate(val) {
                  return toString.call(val) === "[object Date]";
                }
                function isFile(val) {
                  return toString.call(val) === "[object File]";
                }
                function isBlob(val) {
                  return toString.call(val) === "[object Blob]";
                }
                function isFunction(val) {
                  return toString.call(val) === "[object Function]";
                }
                function isStream(val) {
                  return isObject(val) && isFunction(val.pipe);
                }
                function isURLSearchParams(val) {
                  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
                }
                function trim(str) {
                  return str.replace(/^\s*/, "").replace(/\s*$/, "");
                }
                function isStandardBrowserEnv() {
                  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
                    return false;
                  }
                  return typeof window !== "undefined" && typeof document !== "undefined";
                }
                function forEach(obj, fn) {
                  if (obj === null || typeof obj === "undefined") {
                    return;
                  }
                  if (typeof obj !== "object") {
                    obj = [obj];
                  }
                  if (isArray(obj)) {
                    for (var i = 0, l = obj.length; i < l; i++) {
                      fn.call(null, obj[i], i, obj);
                    }
                  } else {
                    for (var key in obj) {
                      if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        fn.call(null, obj[key], key, obj);
                      }
                    }
                  }
                }
                function merge() {
                  var result = {};
                  function assignValue(val, key) {
                    if (isPlainObject(result[key]) && isPlainObject(val)) {
                      result[key] = merge(result[key], val);
                    } else if (isPlainObject(val)) {
                      result[key] = merge({}, val);
                    } else if (isArray(val)) {
                      result[key] = val.slice();
                    } else {
                      result[key] = val;
                    }
                  }
                  for (var i = 0, l = arguments.length; i < l; i++) {
                    forEach(arguments[i], assignValue);
                  }
                  return result;
                }
                function extend(a, b, thisArg) {
                  forEach(b, function assignValue(val, key) {
                    if (thisArg && typeof val === "function") {
                      a[key] = bind(val, thisArg);
                    } else {
                      a[key] = val;
                    }
                  });
                  return a;
                }
                function stripBOM(content) {
                  if (content.charCodeAt(0) === 65279) {
                    content = content.slice(1);
                  }
                  return content;
                }
                module2.exports = {
                  isArray,
                  isArrayBuffer,
                  isBuffer,
                  isFormData,
                  isArrayBufferView,
                  isString,
                  isNumber,
                  isObject,
                  isPlainObject,
                  isUndefined,
                  isDate,
                  isFile,
                  isBlob,
                  isFunction,
                  isStream,
                  isURLSearchParams,
                  isStandardBrowserEnv,
                  forEach,
                  merge,
                  extend,
                  trim,
                  stripBOM
                };
              }
            ),
            /***/
            4491: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                ;
                (function(globalObject) {
                  "use strict";
                  var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
                  function clone(configObject) {
                    var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
                      decimalSeparator: ".",
                      groupSeparator: ",",
                      groupSize: 3,
                      secondaryGroupSize: 0,
                      fractionGroupSeparator: "",
                      // non-breaking space
                      fractionGroupSize: 0
                    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
                    function BigNumber2(n, b) {
                      var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
                      if (!(x instanceof BigNumber2)) {
                        return new BigNumber2(n, b);
                      }
                      if (b == null) {
                        if (n instanceof BigNumber2) {
                          x.s = n.s;
                          x.e = n.e;
                          x.c = (n = n.c) ? n.slice() : n;
                          return;
                        }
                        isNum = typeof n == "number";
                        if (isNum && n * 0 == 0) {
                          x.s = 1 / n < 0 ? (n = -n, -1) : 1;
                          if (n === ~~n) {
                            for (e = 0, i = n; i >= 10; i /= 10, e++)
                              ;
                            x.e = e;
                            x.c = [n];
                            return;
                          }
                          str = n + "";
                        } else {
                          if (!isNumeric.test(str = n + ""))
                            return parseNumeric(x, str, isNum);
                          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                        }
                        if ((e = str.indexOf(".")) > -1)
                          str = str.replace(".", "");
                        if ((i = str.search(/e/i)) > 0) {
                          if (e < 0)
                            e = i;
                          e += +str.slice(i + 1);
                          str = str.substring(0, i);
                        } else if (e < 0) {
                          e = str.length;
                        }
                      } else {
                        intCheck(b, 2, ALPHABET.length, "Base");
                        str = n + "";
                        if (b == 10) {
                          x = new BigNumber2(n instanceof BigNumber2 ? n : str);
                          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                        }
                        isNum = typeof n == "number";
                        if (isNum) {
                          if (n * 0 != 0)
                            return parseNumeric(x, str, isNum, b);
                          x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;
                          if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                            throw Error(tooManyDigits + n);
                          }
                          isNum = false;
                        } else {
                          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                        }
                        alphabet = ALPHABET.slice(0, b);
                        e = i = 0;
                        for (len = str.length; i < len; i++) {
                          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                            if (c == ".") {
                              if (i > e) {
                                e = len;
                                continue;
                              }
                            } else if (!caseChanged) {
                              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                                caseChanged = true;
                                i = -1;
                                e = 0;
                                continue;
                              }
                            }
                            return parseNumeric(x, n + "", isNum, b);
                          }
                        }
                        str = convertBase(str, b, 10, x.s);
                        if ((e = str.indexOf(".")) > -1)
                          str = str.replace(".", "");
                        else
                          e = str.length;
                      }
                      for (i = 0; str.charCodeAt(i) === 48; i++)
                        ;
                      for (len = str.length; str.charCodeAt(--len) === 48; )
                        ;
                      str = str.slice(i, ++len);
                      if (str) {
                        len -= i;
                        if (isNum && BigNumber2.DEBUG && len > 15 && (n > MAX_SAFE_INTEGER || n !== mathfloor(n))) {
                          throw Error(tooManyDigits + x.s * n);
                        }
                        e = e - i - 1;
                        if (e > MAX_EXP) {
                          x.c = x.e = null;
                        } else if (e < MIN_EXP) {
                          x.c = [x.e = 0];
                        } else {
                          x.e = e;
                          x.c = [];
                          i = (e + 1) % LOG_BASE;
                          if (e < 0)
                            i += LOG_BASE;
                          if (i < len) {
                            if (i)
                              x.c.push(+str.slice(0, i));
                            for (len -= LOG_BASE; i < len; ) {
                              x.c.push(+str.slice(i, i += LOG_BASE));
                            }
                            str = str.slice(i);
                            i = LOG_BASE - str.length;
                          } else {
                            i -= len;
                          }
                          for (; i--; str += "0")
                            ;
                          x.c.push(+str);
                        }
                      } else {
                        x.c = [x.e = 0];
                      }
                    }
                    BigNumber2.clone = clone;
                    BigNumber2.ROUND_UP = 0;
                    BigNumber2.ROUND_DOWN = 1;
                    BigNumber2.ROUND_CEIL = 2;
                    BigNumber2.ROUND_FLOOR = 3;
                    BigNumber2.ROUND_HALF_UP = 4;
                    BigNumber2.ROUND_HALF_DOWN = 5;
                    BigNumber2.ROUND_HALF_EVEN = 6;
                    BigNumber2.ROUND_HALF_CEIL = 7;
                    BigNumber2.ROUND_HALF_FLOOR = 8;
                    BigNumber2.EUCLID = 9;
                    BigNumber2.config = BigNumber2.set = function(obj) {
                      var p, v;
                      if (obj != null) {
                        if (typeof obj == "object") {
                          if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                            v = obj[p];
                            intCheck(v, 0, MAX, p);
                            DECIMAL_PLACES = v;
                          }
                          if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                            v = obj[p];
                            intCheck(v, 0, 8, p);
                            ROUNDING_MODE = v;
                          }
                          if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                            v = obj[p];
                            if (isArray(v)) {
                              intCheck(v[0], -MAX, 0, p);
                              intCheck(v[1], 0, MAX, p);
                              TO_EXP_NEG = v[0];
                              TO_EXP_POS = v[1];
                            } else {
                              intCheck(v, -MAX, MAX, p);
                              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                            }
                          }
                          if (obj.hasOwnProperty(p = "RANGE")) {
                            v = obj[p];
                            if (isArray(v)) {
                              intCheck(v[0], -MAX, -1, p);
                              intCheck(v[1], 1, MAX, p);
                              MIN_EXP = v[0];
                              MAX_EXP = v[1];
                            } else {
                              intCheck(v, -MAX, MAX, p);
                              if (v) {
                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                              } else {
                                throw Error(bignumberError + p + " cannot be zero: " + v);
                              }
                            }
                          }
                          if (obj.hasOwnProperty(p = "CRYPTO")) {
                            v = obj[p];
                            if (v === !!v) {
                              if (v) {
                                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                                  CRYPTO = v;
                                } else {
                                  CRYPTO = !v;
                                  throw Error(bignumberError + "crypto unavailable");
                                }
                              } else {
                                CRYPTO = v;
                              }
                            } else {
                              throw Error(bignumberError + p + " not true or false: " + v);
                            }
                          }
                          if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                            v = obj[p];
                            intCheck(v, 0, 9, p);
                            MODULO_MODE = v;
                          }
                          if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                            v = obj[p];
                            intCheck(v, 0, MAX, p);
                            POW_PRECISION = v;
                          }
                          if (obj.hasOwnProperty(p = "FORMAT")) {
                            v = obj[p];
                            if (typeof v == "object")
                              FORMAT = v;
                            else
                              throw Error(bignumberError + p + " not an object: " + v);
                          }
                          if (obj.hasOwnProperty(p = "ALPHABET")) {
                            v = obj[p];
                            if (typeof v == "string" && !/^.$|\.|(.).*\1/.test(v)) {
                              ALPHABET = v;
                            } else {
                              throw Error(bignumberError + p + " invalid: " + v);
                            }
                          }
                        } else {
                          throw Error(bignumberError + "Object expected: " + obj);
                        }
                      }
                      return {
                        DECIMAL_PLACES,
                        ROUNDING_MODE,
                        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
                        RANGE: [MIN_EXP, MAX_EXP],
                        CRYPTO,
                        MODULO_MODE,
                        POW_PRECISION,
                        FORMAT,
                        ALPHABET
                      };
                    };
                    BigNumber2.isBigNumber = function(v) {
                      return v instanceof BigNumber2 || v && v._isBigNumber === true || false;
                    };
                    BigNumber2.maximum = BigNumber2.max = function() {
                      return maxOrMin(arguments, P.lt);
                    };
                    BigNumber2.minimum = BigNumber2.min = function() {
                      return maxOrMin(arguments, P.gt);
                    };
                    BigNumber2.random = function() {
                      var pow2_53 = 9007199254740992;
                      var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
                        return mathfloor(Math.random() * pow2_53);
                      } : function() {
                        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
                      };
                      return function(dp) {
                        var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
                        if (dp == null)
                          dp = DECIMAL_PLACES;
                        else
                          intCheck(dp, 0, MAX);
                        k = mathceil(dp / LOG_BASE);
                        if (CRYPTO) {
                          if (crypto.getRandomValues) {
                            a = crypto.getRandomValues(new Uint32Array(k *= 2));
                            for (; i < k; ) {
                              v = a[i] * 131072 + (a[i + 1] >>> 11);
                              if (v >= 9e15) {
                                b = crypto.getRandomValues(new Uint32Array(2));
                                a[i] = b[0];
                                a[i + 1] = b[1];
                              } else {
                                c.push(v % 1e14);
                                i += 2;
                              }
                            }
                            i = k / 2;
                          } else if (crypto.randomBytes) {
                            a = crypto.randomBytes(k *= 7);
                            for (; i < k; ) {
                              v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                              if (v >= 9e15) {
                                crypto.randomBytes(7).copy(a, i);
                              } else {
                                c.push(v % 1e14);
                                i += 7;
                              }
                            }
                            i = k / 7;
                          } else {
                            CRYPTO = false;
                            throw Error(bignumberError + "crypto unavailable");
                          }
                        }
                        if (!CRYPTO) {
                          for (; i < k; ) {
                            v = random53bitInt();
                            if (v < 9e15)
                              c[i++] = v % 1e14;
                          }
                        }
                        k = c[--i];
                        dp %= LOG_BASE;
                        if (k && dp) {
                          v = POWS_TEN[LOG_BASE - dp];
                          c[i] = mathfloor(k / v) * v;
                        }
                        for (; c[i] === 0; c.pop(), i--)
                          ;
                        if (i < 0) {
                          c = [e = 0];
                        } else {
                          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                            ;
                          for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                            ;
                          if (i < LOG_BASE)
                            e -= LOG_BASE - i;
                        }
                        rand.e = e;
                        rand.c = c;
                        return rand;
                      };
                    }();
                    convertBase = /* @__PURE__ */ function() {
                      var decimal = "0123456789";
                      function toBaseOut(str, baseIn, baseOut, alphabet) {
                        var j, arr = [0], arrL, i = 0, len = str.length;
                        for (; i < len; ) {
                          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                            ;
                          arr[0] += alphabet.indexOf(str.charAt(i++));
                          for (j = 0; j < arr.length; j++) {
                            if (arr[j] > baseOut - 1) {
                              if (arr[j + 1] == null)
                                arr[j + 1] = 0;
                              arr[j + 1] += arr[j] / baseOut | 0;
                              arr[j] %= baseOut;
                            }
                          }
                        }
                        return arr.reverse();
                      }
                      return function(str, baseIn, baseOut, sign, callerIsToString) {
                        var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                        if (i >= 0) {
                          k = POW_PRECISION;
                          POW_PRECISION = 0;
                          str = str.replace(".", "");
                          y = new BigNumber2(baseIn);
                          x = y.pow(str.length - i);
                          POW_PRECISION = k;
                          y.c = toBaseOut(
                            toFixedPoint(coeffToString(x.c), x.e, "0"),
                            10,
                            baseOut,
                            decimal
                          );
                          y.e = y.c.length;
                        }
                        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
                        e = k = xc.length;
                        for (; xc[--k] == 0; xc.pop())
                          ;
                        if (!xc[0])
                          return alphabet.charAt(0);
                        if (i < 0) {
                          --e;
                        } else {
                          x.c = xc;
                          x.e = e;
                          x.s = sign;
                          x = div(x, y, dp, rm, baseOut);
                          xc = x.c;
                          r = x.r;
                          e = x.e;
                        }
                        d = e + dp + 1;
                        i = xc[d];
                        k = baseOut / 2;
                        r = r || d < 0 || xc[d + 1] != null;
                        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
                        if (d < 1 || !xc[0]) {
                          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                        } else {
                          xc.length = d;
                          if (r) {
                            for (--baseOut; ++xc[--d] > baseOut; ) {
                              xc[d] = 0;
                              if (!d) {
                                ++e;
                                xc = [1].concat(xc);
                              }
                            }
                          }
                          for (k = xc.length; !xc[--k]; )
                            ;
                          for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                            ;
                          str = toFixedPoint(str, e, alphabet.charAt(0));
                        }
                        return str;
                      };
                    }();
                    div = /* @__PURE__ */ function() {
                      function multiply(x, k, base) {
                        var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
                        for (x = x.slice(); i--; ) {
                          xlo = x[i] % SQRT_BASE;
                          xhi = x[i] / SQRT_BASE | 0;
                          m = khi * xlo + xhi * klo;
                          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                          x[i] = temp % base;
                        }
                        if (carry)
                          x = [carry].concat(x);
                        return x;
                      }
                      function compare2(a, b, aL, bL) {
                        var i, cmp;
                        if (aL != bL) {
                          cmp = aL > bL ? 1 : -1;
                        } else {
                          for (i = cmp = 0; i < aL; i++) {
                            if (a[i] != b[i]) {
                              cmp = a[i] > b[i] ? 1 : -1;
                              break;
                            }
                          }
                        }
                        return cmp;
                      }
                      function subtract(a, b, aL, base) {
                        var i = 0;
                        for (; aL--; ) {
                          a[aL] -= i;
                          i = a[aL] < b[aL] ? 1 : 0;
                          a[aL] = i * base + a[aL] - b[aL];
                        }
                        for (; !a[0] && a.length > 1; a.splice(0, 1))
                          ;
                      }
                      return function(x, y, dp, rm, base) {
                        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                        if (!xc || !xc[0] || !yc || !yc[0]) {
                          return new BigNumber2(
                            // Return NaN if either NaN, or both Infinity or 0.
                            !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                              // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                              xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                            )
                          );
                        }
                        q = new BigNumber2(s);
                        qc = q.c = [];
                        e = x.e - y.e;
                        s = dp + e + 1;
                        if (!base) {
                          base = BASE;
                          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                          s = s / LOG_BASE | 0;
                        }
                        for (i = 0; yc[i] == (xc[i] || 0); i++)
                          ;
                        if (yc[i] > (xc[i] || 0))
                          e--;
                        if (s < 0) {
                          qc.push(1);
                          more = true;
                        } else {
                          xL = xc.length;
                          yL = yc.length;
                          i = 0;
                          s += 2;
                          n = mathfloor(base / (yc[0] + 1));
                          if (n > 1) {
                            yc = multiply(yc, n, base);
                            xc = multiply(xc, n, base);
                            yL = yc.length;
                            xL = xc.length;
                          }
                          xi = yL;
                          rem = xc.slice(0, yL);
                          remL = rem.length;
                          for (; remL < yL; rem[remL++] = 0)
                            ;
                          yz = yc.slice();
                          yz = [0].concat(yz);
                          yc0 = yc[0];
                          if (yc[1] >= base / 2)
                            yc0++;
                          do {
                            n = 0;
                            cmp = compare2(yc, rem, yL, remL);
                            if (cmp < 0) {
                              rem0 = rem[0];
                              if (yL != remL)
                                rem0 = rem0 * base + (rem[1] || 0);
                              n = mathfloor(rem0 / yc0);
                              if (n > 1) {
                                if (n >= base)
                                  n = base - 1;
                                prod = multiply(yc, n, base);
                                prodL = prod.length;
                                remL = rem.length;
                                while (compare2(prod, rem, prodL, remL) == 1) {
                                  n--;
                                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                  prodL = prod.length;
                                  cmp = 1;
                                }
                              } else {
                                if (n == 0) {
                                  cmp = n = 1;
                                }
                                prod = yc.slice();
                                prodL = prod.length;
                              }
                              if (prodL < remL)
                                prod = [0].concat(prod);
                              subtract(rem, prod, remL, base);
                              remL = rem.length;
                              if (cmp == -1) {
                                while (compare2(yc, rem, yL, remL) < 1) {
                                  n++;
                                  subtract(rem, yL < remL ? yz : yc, remL, base);
                                  remL = rem.length;
                                }
                              }
                            } else if (cmp === 0) {
                              n++;
                              rem = [0];
                            }
                            qc[i++] = n;
                            if (rem[0]) {
                              rem[remL++] = xc[xi] || 0;
                            } else {
                              rem = [xc[xi]];
                              remL = 1;
                            }
                          } while ((xi++ < xL || rem[0] != null) && s--);
                          more = rem[0] != null;
                          if (!qc[0])
                            qc.splice(0, 1);
                        }
                        if (base == BASE) {
                          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                            ;
                          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
                        } else {
                          q.e = e;
                          q.r = +more;
                        }
                        return q;
                      };
                    }();
                    function format(n, i, rm, id) {
                      var c0, e, ne, len, str;
                      if (rm == null)
                        rm = ROUNDING_MODE;
                      else
                        intCheck(rm, 0, 8);
                      if (!n.c)
                        return n.toString();
                      c0 = n.c[0];
                      ne = n.e;
                      if (i == null) {
                        str = coeffToString(n.c);
                        str = id == 1 || id == 2 && ne <= TO_EXP_NEG ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
                      } else {
                        n = round(new BigNumber2(n), i, rm);
                        e = n.e;
                        str = coeffToString(n.c);
                        len = str.length;
                        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                          for (; len < i; str += "0", len++)
                            ;
                          str = toExponential(str, e);
                        } else {
                          i -= ne;
                          str = toFixedPoint(str, e, "0");
                          if (e + 1 > len) {
                            if (--i > 0)
                              for (str += "."; i--; str += "0")
                                ;
                          } else {
                            i += e - len;
                            if (i > 0) {
                              if (e + 1 == len)
                                str += ".";
                              for (; i--; str += "0")
                                ;
                            }
                          }
                        }
                      }
                      return n.s < 0 && c0 ? "-" + str : str;
                    }
                    function maxOrMin(args, method) {
                      var m, n, i = 0;
                      if (isArray(args[0]))
                        args = args[0];
                      m = new BigNumber2(args[0]);
                      for (; ++i < args.length; ) {
                        n = new BigNumber2(args[i]);
                        if (!n.s) {
                          m = n;
                          break;
                        } else if (method.call(m, n)) {
                          m = n;
                        }
                      }
                      return m;
                    }
                    function normalise(n, c, e) {
                      var i = 1, j = c.length;
                      for (; !c[--j]; c.pop())
                        ;
                      for (j = c[0]; j >= 10; j /= 10, i++)
                        ;
                      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
                        n.c = n.e = null;
                      } else if (e < MIN_EXP) {
                        n.c = [n.e = 0];
                      } else {
                        n.e = e;
                        n.c = c;
                      }
                      return n;
                    }
                    parseNumeric = /* @__PURE__ */ function() {
                      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
                      return function(x, str, isNum, b) {
                        var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
                        if (isInfinityOrNaN.test(s)) {
                          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                          x.c = x.e = null;
                        } else {
                          if (!isNum) {
                            s = s.replace(basePrefix, function(m, p1, p2) {
                              base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                              return !b || b == base ? p1 : m;
                            });
                            if (b) {
                              base = b;
                              s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                            }
                            if (str != s)
                              return new BigNumber2(s, base);
                          }
                          if (BigNumber2.DEBUG) {
                            throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
                          }
                          x.c = x.e = x.s = null;
                        }
                      };
                    }();
                    function round(x, sd, rm, r) {
                      var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
                      if (xc) {
                        out: {
                          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                            ;
                          i = sd - d;
                          if (i < 0) {
                            i += LOG_BASE;
                            j = sd;
                            n = xc[ni = 0];
                            rd = n / pows10[d - j - 1] % 10 | 0;
                          } else {
                            ni = mathceil((i + 1) / LOG_BASE);
                            if (ni >= xc.length) {
                              if (r) {
                                for (; xc.length <= ni; xc.push(0))
                                  ;
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                              } else {
                                break out;
                              }
                            } else {
                              n = k = xc[ni];
                              for (d = 1; k >= 10; k /= 10, d++)
                                ;
                              i %= LOG_BASE;
                              j = i - LOG_BASE + d;
                              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                            }
                          }
                          r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                          if (sd < 1 || !xc[0]) {
                            xc.length = 0;
                            if (r) {
                              sd -= x.e + 1;
                              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                              x.e = -sd || 0;
                            } else {
                              xc[0] = x.e = 0;
                            }
                            return x;
                          }
                          if (i == 0) {
                            xc.length = ni;
                            k = 1;
                            ni--;
                          } else {
                            xc.length = ni + 1;
                            k = pows10[LOG_BASE - i];
                            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                          }
                          if (r) {
                            for (; ; ) {
                              if (ni == 0) {
                                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                                  ;
                                j = xc[0] += k;
                                for (k = 1; j >= 10; j /= 10, k++)
                                  ;
                                if (i != k) {
                                  x.e++;
                                  if (xc[0] == BASE)
                                    xc[0] = 1;
                                }
                                break;
                              } else {
                                xc[ni] += k;
                                if (xc[ni] != BASE)
                                  break;
                                xc[ni--] = 0;
                                k = 1;
                              }
                            }
                          }
                          for (i = xc.length; xc[--i] === 0; xc.pop())
                            ;
                        }
                        if (x.e > MAX_EXP) {
                          x.c = x.e = null;
                        } else if (x.e < MIN_EXP) {
                          x.c = [x.e = 0];
                        }
                      }
                      return x;
                    }
                    P.absoluteValue = P.abs = function() {
                      var x = new BigNumber2(this);
                      if (x.s < 0)
                        x.s = 1;
                      return x;
                    };
                    P.comparedTo = function(y, b) {
                      return compare(this, new BigNumber2(y, b));
                    };
                    P.decimalPlaces = P.dp = function(dp, rm) {
                      var c, n, v, x = this;
                      if (dp != null) {
                        intCheck(dp, 0, MAX);
                        if (rm == null)
                          rm = ROUNDING_MODE;
                        else
                          intCheck(rm, 0, 8);
                        return round(new BigNumber2(x), dp + x.e + 1, rm);
                      }
                      if (!(c = x.c))
                        return null;
                      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
                      if (v = c[v])
                        for (; v % 10 == 0; v /= 10, n--)
                          ;
                      if (n < 0)
                        n = 0;
                      return n;
                    };
                    P.dividedBy = P.div = function(y, b) {
                      return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
                    };
                    P.dividedToIntegerBy = P.idiv = function(y, b) {
                      return div(this, new BigNumber2(y, b), 0, 1);
                    };
                    P.exponentiatedBy = P.pow = function(n, m) {
                      var half, isModExp, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
                      n = new BigNumber2(n);
                      if (n.c && !n.isInteger()) {
                        throw Error(bignumberError + "Exponent not an integer: " + n);
                      }
                      if (m != null)
                        m = new BigNumber2(m);
                      nIsBig = n.e > 14;
                      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
                        y = new BigNumber2(Math.pow(+x.valueOf(), nIsBig ? 2 - isOdd(n) : +n));
                        return m ? y.mod(m) : y;
                      }
                      nIsNeg = n.s < 0;
                      if (m) {
                        if (m.c ? !m.c[0] : !m.s)
                          return new BigNumber2(NaN);
                        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
                        if (isModExp)
                          x = x.mod(m);
                      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
                        k = x.s < 0 && isOdd(n) ? -0 : 0;
                        if (x.e > -1)
                          k = 1 / k;
                        return new BigNumber2(nIsNeg ? 1 / k : k);
                      } else if (POW_PRECISION) {
                        k = mathceil(POW_PRECISION / LOG_BASE + 2);
                      }
                      if (nIsBig) {
                        half = new BigNumber2(0.5);
                        nIsOdd = isOdd(n);
                      } else {
                        nIsOdd = n % 2;
                      }
                      if (nIsNeg)
                        n.s = 1;
                      y = new BigNumber2(ONE);
                      for (; ; ) {
                        if (nIsOdd) {
                          y = y.times(x);
                          if (!y.c)
                            break;
                          if (k) {
                            if (y.c.length > k)
                              y.c.length = k;
                          } else if (isModExp) {
                            y = y.mod(m);
                          }
                        }
                        if (nIsBig) {
                          n = n.times(half);
                          round(n, n.e + 1, 1);
                          if (!n.c[0])
                            break;
                          nIsBig = n.e > 14;
                          nIsOdd = isOdd(n);
                        } else {
                          n = mathfloor(n / 2);
                          if (!n)
                            break;
                          nIsOdd = n % 2;
                        }
                        x = x.times(x);
                        if (k) {
                          if (x.c && x.c.length > k)
                            x.c.length = k;
                        } else if (isModExp) {
                          x = x.mod(m);
                        }
                      }
                      if (isModExp)
                        return y;
                      if (nIsNeg)
                        y = ONE.div(y);
                      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
                    };
                    P.integerValue = function(rm) {
                      var n = new BigNumber2(this);
                      if (rm == null)
                        rm = ROUNDING_MODE;
                      else
                        intCheck(rm, 0, 8);
                      return round(n, n.e + 1, rm);
                    };
                    P.isEqualTo = P.eq = function(y, b) {
                      return compare(this, new BigNumber2(y, b)) === 0;
                    };
                    P.isFinite = function() {
                      return !!this.c;
                    };
                    P.isGreaterThan = P.gt = function(y, b) {
                      return compare(this, new BigNumber2(y, b)) > 0;
                    };
                    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
                      return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
                    };
                    P.isInteger = function() {
                      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
                    };
                    P.isLessThan = P.lt = function(y, b) {
                      return compare(this, new BigNumber2(y, b)) < 0;
                    };
                    P.isLessThanOrEqualTo = P.lte = function(y, b) {
                      return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
                    };
                    P.isNaN = function() {
                      return !this.s;
                    };
                    P.isNegative = function() {
                      return this.s < 0;
                    };
                    P.isPositive = function() {
                      return this.s > 0;
                    };
                    P.isZero = function() {
                      return !!this.c && this.c[0] == 0;
                    };
                    P.minus = function(y, b) {
                      var i, j, t, xLTy, x = this, a = x.s;
                      y = new BigNumber2(y, b);
                      b = y.s;
                      if (!a || !b)
                        return new BigNumber2(NaN);
                      if (a != b) {
                        y.s = -b;
                        return x.plus(y);
                      }
                      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                      if (!xe || !ye) {
                        if (!xc || !yc)
                          return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
                        if (!xc[0] || !yc[0]) {
                          return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                            // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                            ROUNDING_MODE == 3 ? -0 : 0
                          ));
                        }
                      }
                      xe = bitFloor(xe);
                      ye = bitFloor(ye);
                      xc = xc.slice();
                      if (a = xe - ye) {
                        if (xLTy = a < 0) {
                          a = -a;
                          t = xc;
                        } else {
                          ye = xe;
                          t = yc;
                        }
                        t.reverse();
                        for (b = a; b--; t.push(0))
                          ;
                        t.reverse();
                      } else {
                        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
                        for (a = b = 0; b < j; b++) {
                          if (xc[b] != yc[b]) {
                            xLTy = xc[b] < yc[b];
                            break;
                          }
                        }
                      }
                      if (xLTy)
                        t = xc, xc = yc, yc = t, y.s = -y.s;
                      b = (j = yc.length) - (i = xc.length);
                      if (b > 0)
                        for (; b--; xc[i++] = 0)
                          ;
                      b = BASE - 1;
                      for (; j > a; ) {
                        if (xc[--j] < yc[j]) {
                          for (i = j; i && !xc[--i]; xc[i] = b)
                            ;
                          --xc[i];
                          xc[j] += BASE;
                        }
                        xc[j] -= yc[j];
                      }
                      for (; xc[0] == 0; xc.splice(0, 1), --ye)
                        ;
                      if (!xc[0]) {
                        y.s = ROUNDING_MODE == 3 ? -1 : 1;
                        y.c = [y.e = 0];
                        return y;
                      }
                      return normalise(y, xc, ye);
                    };
                    P.modulo = P.mod = function(y, b) {
                      var q, s, x = this;
                      y = new BigNumber2(y, b);
                      if (!x.c || !y.s || y.c && !y.c[0]) {
                        return new BigNumber2(NaN);
                      } else if (!y.c || x.c && !x.c[0]) {
                        return new BigNumber2(x);
                      }
                      if (MODULO_MODE == 9) {
                        s = y.s;
                        y.s = 1;
                        q = div(x, y, 0, 3);
                        y.s = s;
                        q.s *= s;
                      } else {
                        q = div(x, y, 0, MODULO_MODE);
                      }
                      y = x.minus(q.times(y));
                      if (!y.c[0] && MODULO_MODE == 1)
                        y.s = x.s;
                      return y;
                    };
                    P.multipliedBy = P.times = function(y, b) {
                      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
                      if (!xc || !yc || !xc[0] || !yc[0]) {
                        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                          y.c = y.e = y.s = null;
                        } else {
                          y.s *= x.s;
                          if (!xc || !yc) {
                            y.c = y.e = null;
                          } else {
                            y.c = [0];
                            y.e = 0;
                          }
                        }
                        return y;
                      }
                      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
                      y.s *= x.s;
                      xcL = xc.length;
                      ycL = yc.length;
                      if (xcL < ycL)
                        zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
                      for (i = xcL + ycL, zc = []; i--; zc.push(0))
                        ;
                      base = BASE;
                      sqrtBase = SQRT_BASE;
                      for (i = ycL; --i >= 0; ) {
                        c = 0;
                        ylo = yc[i] % sqrtBase;
                        yhi = yc[i] / sqrtBase | 0;
                        for (k = xcL, j = i + k; j > i; ) {
                          xlo = xc[--k] % sqrtBase;
                          xhi = xc[k] / sqrtBase | 0;
                          m = yhi * xlo + xhi * ylo;
                          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                          zc[j--] = xlo % base;
                        }
                        zc[j] = c;
                      }
                      if (c) {
                        ++e;
                      } else {
                        zc.splice(0, 1);
                      }
                      return normalise(y, zc, e);
                    };
                    P.negated = function() {
                      var x = new BigNumber2(this);
                      x.s = -x.s || null;
                      return x;
                    };
                    P.plus = function(y, b) {
                      var t, x = this, a = x.s;
                      y = new BigNumber2(y, b);
                      b = y.s;
                      if (!a || !b)
                        return new BigNumber2(NaN);
                      if (a != b) {
                        y.s = -b;
                        return x.minus(y);
                      }
                      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                      if (!xe || !ye) {
                        if (!xc || !yc)
                          return new BigNumber2(a / 0);
                        if (!xc[0] || !yc[0])
                          return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
                      }
                      xe = bitFloor(xe);
                      ye = bitFloor(ye);
                      xc = xc.slice();
                      if (a = xe - ye) {
                        if (a > 0) {
                          ye = xe;
                          t = yc;
                        } else {
                          a = -a;
                          t = xc;
                        }
                        t.reverse();
                        for (; a--; t.push(0))
                          ;
                        t.reverse();
                      }
                      a = xc.length;
                      b = yc.length;
                      if (a - b < 0)
                        t = yc, yc = xc, xc = t, b = a;
                      for (a = 0; b; ) {
                        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
                      }
                      if (a) {
                        xc = [a].concat(xc);
                        ++ye;
                      }
                      return normalise(y, xc, ye);
                    };
                    P.precision = P.sd = function(sd, rm) {
                      var c, n, v, x = this;
                      if (sd != null && sd !== !!sd) {
                        intCheck(sd, 1, MAX);
                        if (rm == null)
                          rm = ROUNDING_MODE;
                        else
                          intCheck(rm, 0, 8);
                        return round(new BigNumber2(x), sd, rm);
                      }
                      if (!(c = x.c))
                        return null;
                      v = c.length - 1;
                      n = v * LOG_BASE + 1;
                      if (v = c[v]) {
                        for (; v % 10 == 0; v /= 10, n--)
                          ;
                        for (v = c[0]; v >= 10; v /= 10, n++)
                          ;
                      }
                      if (sd && x.e + 1 > n)
                        n = x.e + 1;
                      return n;
                    };
                    P.shiftedBy = function(k) {
                      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
                      return this.times("1e" + k);
                    };
                    P.squareRoot = P.sqrt = function() {
                      var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
                      if (s !== 1 || !c || !c[0]) {
                        return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                      }
                      s = Math.sqrt(+x);
                      if (s == 0 || s == 1 / 0) {
                        n = coeffToString(c);
                        if ((n.length + e) % 2 == 0)
                          n += "0";
                        s = Math.sqrt(n);
                        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
                        if (s == 1 / 0) {
                          n = "1e" + e;
                        } else {
                          n = s.toExponential();
                          n = n.slice(0, n.indexOf("e") + 1) + e;
                        }
                        r = new BigNumber2(n);
                      } else {
                        r = new BigNumber2(s + "");
                      }
                      if (r.c[0]) {
                        e = r.e;
                        s = e + dp;
                        if (s < 3)
                          s = 0;
                        for (; ; ) {
                          t = r;
                          r = half.times(t.plus(div(x, t, dp, 1)));
                          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                            if (r.e < e)
                              --s;
                            n = n.slice(s - 3, s + 1);
                            if (n == "9999" || !rep && n == "4999") {
                              if (!rep) {
                                round(t, t.e + DECIMAL_PLACES + 2, 0);
                                if (t.times(t).eq(x)) {
                                  r = t;
                                  break;
                                }
                              }
                              dp += 4;
                              s += 4;
                              rep = 1;
                            } else {
                              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                                round(r, r.e + DECIMAL_PLACES + 2, 1);
                                m = !r.times(r).eq(x);
                              }
                              break;
                            }
                          }
                        }
                      }
                      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
                    };
                    P.toExponential = function(dp, rm) {
                      if (dp != null) {
                        intCheck(dp, 0, MAX);
                        dp++;
                      }
                      return format(this, dp, rm, 1);
                    };
                    P.toFixed = function(dp, rm) {
                      if (dp != null) {
                        intCheck(dp, 0, MAX);
                        dp = dp + this.e + 1;
                      }
                      return format(this, dp, rm);
                    };
                    P.toFormat = function(dp, rm) {
                      var str = this.toFixed(dp, rm);
                      if (this.c) {
                        var i, arr = str.split("."), g1 = +FORMAT.groupSize, g2 = +FORMAT.secondaryGroupSize, groupSeparator = FORMAT.groupSeparator, intPart = arr[0], fractionPart = arr[1], isNeg = this.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                        if (g2)
                          i = g1, g1 = g2, g2 = i, len -= i;
                        if (g1 > 0 && len > 0) {
                          i = len % g1 || g1;
                          intPart = intDigits.substr(0, i);
                          for (; i < len; i += g1) {
                            intPart += groupSeparator + intDigits.substr(i, g1);
                          }
                          if (g2 > 0)
                            intPart += groupSeparator + intDigits.slice(i);
                          if (isNeg)
                            intPart = "-" + intPart;
                        }
                        str = fractionPart ? intPart + FORMAT.decimalSeparator + ((g2 = +FORMAT.fractionGroupSize) ? fractionPart.replace(
                          new RegExp("\\d{" + g2 + "}\\B", "g"),
                          "$&" + FORMAT.fractionGroupSeparator
                        ) : fractionPart) : intPart;
                      }
                      return str;
                    };
                    P.toFraction = function(md) {
                      var arr, d, d0, d1, d2, e, exp, n, n0, n1, q, s, x = this, xc = x.c;
                      if (md != null) {
                        n = new BigNumber2(md);
                        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                          throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + md);
                        }
                      }
                      if (!xc)
                        return x.toString();
                      d = new BigNumber2(ONE);
                      n1 = d0 = new BigNumber2(ONE);
                      d1 = n0 = new BigNumber2(ONE);
                      s = coeffToString(xc);
                      e = d.e = s.length - x.e - 1;
                      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
                      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
                      exp = MAX_EXP;
                      MAX_EXP = 1 / 0;
                      n = new BigNumber2(s);
                      n0.c[0] = 0;
                      for (; ; ) {
                        q = div(n, d, 0, 1);
                        d2 = d0.plus(q.times(d1));
                        if (d2.comparedTo(md) == 1)
                          break;
                        d0 = d1;
                        d1 = d2;
                        n1 = n0.plus(q.times(d2 = n1));
                        n0 = d2;
                        d = n.minus(q.times(d2 = d));
                        n = d2;
                      }
                      d2 = div(md.minus(d0), d1, 0, 1);
                      n0 = n0.plus(d2.times(n1));
                      d0 = d0.plus(d2.times(d1));
                      n0.s = n1.s = x.s;
                      e *= 2;
                      arr = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
                        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
                      ) < 1 ? [n1.toString(), d1.toString()] : [n0.toString(), d0.toString()];
                      MAX_EXP = exp;
                      return arr;
                    };
                    P.toNumber = function() {
                      return +this;
                    };
                    P.toPrecision = function(sd, rm) {
                      if (sd != null)
                        intCheck(sd, 1, MAX);
                      return format(this, sd, rm, 2);
                    };
                    P.toString = function(b) {
                      var str, n = this, s = n.s, e = n.e;
                      if (e === null) {
                        if (s) {
                          str = "Infinity";
                          if (s < 0)
                            str = "-" + str;
                        } else {
                          str = "NaN";
                        }
                      } else {
                        str = coeffToString(n.c);
                        if (b == null) {
                          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
                        } else {
                          intCheck(b, 2, ALPHABET.length, "Base");
                          str = convertBase(toFixedPoint(str, e, "0"), 10, b, s, true);
                        }
                        if (s < 0 && n.c[0])
                          str = "-" + str;
                      }
                      return str;
                    };
                    P.valueOf = P.toJSON = function() {
                      var str, n = this, e = n.e;
                      if (e === null)
                        return n.toString();
                      str = coeffToString(n.c);
                      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
                      return n.s < 0 ? "-" + str : str;
                    };
                    P._isBigNumber = true;
                    if (configObject != null)
                      BigNumber2.set(configObject);
                    return BigNumber2;
                  }
                  function bitFloor(n) {
                    var i = n | 0;
                    return n > 0 || n === i ? i : i - 1;
                  }
                  function coeffToString(a) {
                    var s, z, i = 1, j = a.length, r = a[0] + "";
                    for (; i < j; ) {
                      s = a[i++] + "";
                      z = LOG_BASE - s.length;
                      for (; z--; s = "0" + s)
                        ;
                      r += s;
                    }
                    for (j = r.length; r.charCodeAt(--j) === 48; )
                      ;
                    return r.slice(0, j + 1 || 1);
                  }
                  function compare(x, y) {
                    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
                    if (!i || !j)
                      return null;
                    a = xc && !xc[0];
                    b = yc && !yc[0];
                    if (a || b)
                      return a ? b ? 0 : -j : i;
                    if (i != j)
                      return i;
                    a = i < 0;
                    b = k == l;
                    if (!xc || !yc)
                      return b ? 0 : !xc ^ a ? 1 : -1;
                    if (!b)
                      return k > l ^ a ? 1 : -1;
                    j = (k = xc.length) < (l = yc.length) ? k : l;
                    for (i = 0; i < j; i++)
                      if (xc[i] != yc[i])
                        return xc[i] > yc[i] ^ a ? 1 : -1;
                    return k == l ? 0 : k > l ^ a ? 1 : -1;
                  }
                  function intCheck(n, min, max, name2) {
                    if (n < min || n > max || n !== (n < 0 ? mathceil(n) : mathfloor(n))) {
                      throw Error(bignumberError + (name2 || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + n);
                    }
                  }
                  function isArray(obj) {
                    return Object.prototype.toString.call(obj) == "[object Array]";
                  }
                  function isOdd(n) {
                    var k = n.c.length - 1;
                    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
                  }
                  function toExponential(str, e) {
                    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
                  }
                  function toFixedPoint(str, e, z) {
                    var len, zs;
                    if (e < 0) {
                      for (zs = z + "."; ++e; zs += z)
                        ;
                      str = zs + str;
                    } else {
                      len = str.length;
                      if (++e > len) {
                        for (zs = z, e -= len; --e; zs += z)
                          ;
                        str += zs;
                      } else if (e < len) {
                        str = str.slice(0, e) + "." + str.slice(e);
                      }
                    }
                    return str;
                  }
                  BigNumber = clone();
                  BigNumber["default"] = BigNumber.BigNumber = BigNumber;
                  if (true) {
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                      return BigNumber;
                    }).call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                  } else {
                  }
                })(this);
              }
            ),
            /***/
            7318: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                const util = __webpack_require__2(1022);
                function ADD64AA(v2, a, b) {
                  const o0 = v2[a] + v2[b];
                  let o1 = v2[a + 1] + v2[b + 1];
                  if (o0 >= 4294967296) {
                    o1++;
                  }
                  v2[a] = o0;
                  v2[a + 1] = o1;
                }
                function ADD64AC(v2, a, b0, b1) {
                  let o0 = v2[a] + b0;
                  if (b0 < 0) {
                    o0 += 4294967296;
                  }
                  let o1 = v2[a + 1] + b1;
                  if (o0 >= 4294967296) {
                    o1++;
                  }
                  v2[a] = o0;
                  v2[a + 1] = o1;
                }
                function B2B_GET32(arr, i) {
                  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
                }
                function B2B_G(a, b, c, d, ix, iy) {
                  const x0 = m[ix];
                  const x1 = m[ix + 1];
                  const y0 = m[iy];
                  const y1 = m[iy + 1];
                  ADD64AA(v, a, b);
                  ADD64AC(v, a, x0, x1);
                  let xor0 = v[d] ^ v[a];
                  let xor1 = v[d + 1] ^ v[a + 1];
                  v[d] = xor1;
                  v[d + 1] = xor0;
                  ADD64AA(v, c, d);
                  xor0 = v[b] ^ v[c];
                  xor1 = v[b + 1] ^ v[c + 1];
                  v[b] = xor0 >>> 24 ^ xor1 << 8;
                  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
                  ADD64AA(v, a, b);
                  ADD64AC(v, a, y0, y1);
                  xor0 = v[d] ^ v[a];
                  xor1 = v[d + 1] ^ v[a + 1];
                  v[d] = xor0 >>> 16 ^ xor1 << 16;
                  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
                  ADD64AA(v, c, d);
                  xor0 = v[b] ^ v[c];
                  xor1 = v[b + 1] ^ v[c + 1];
                  v[b] = xor1 >>> 31 ^ xor0 << 1;
                  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
                }
                const BLAKE2B_IV32 = new Uint32Array([
                  4089235720,
                  1779033703,
                  2227873595,
                  3144134277,
                  4271175723,
                  1013904242,
                  1595750129,
                  2773480762,
                  2917565137,
                  1359893119,
                  725511199,
                  2600822924,
                  4215389547,
                  528734635,
                  327033209,
                  1541459225
                ]);
                const SIGMA8 = [
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  14,
                  10,
                  4,
                  8,
                  9,
                  15,
                  13,
                  6,
                  1,
                  12,
                  0,
                  2,
                  11,
                  7,
                  5,
                  3,
                  11,
                  8,
                  12,
                  0,
                  5,
                  2,
                  15,
                  13,
                  10,
                  14,
                  3,
                  6,
                  7,
                  1,
                  9,
                  4,
                  7,
                  9,
                  3,
                  1,
                  13,
                  12,
                  11,
                  14,
                  2,
                  6,
                  5,
                  10,
                  4,
                  0,
                  15,
                  8,
                  9,
                  0,
                  5,
                  7,
                  2,
                  4,
                  10,
                  15,
                  14,
                  1,
                  11,
                  12,
                  6,
                  8,
                  3,
                  13,
                  2,
                  12,
                  6,
                  10,
                  0,
                  11,
                  8,
                  3,
                  4,
                  13,
                  7,
                  5,
                  15,
                  14,
                  1,
                  9,
                  12,
                  5,
                  1,
                  15,
                  14,
                  13,
                  4,
                  10,
                  0,
                  7,
                  6,
                  3,
                  9,
                  2,
                  8,
                  11,
                  13,
                  11,
                  7,
                  14,
                  12,
                  1,
                  3,
                  9,
                  5,
                  0,
                  15,
                  4,
                  8,
                  6,
                  2,
                  10,
                  6,
                  15,
                  14,
                  9,
                  11,
                  3,
                  0,
                  8,
                  12,
                  2,
                  13,
                  7,
                  1,
                  4,
                  10,
                  5,
                  10,
                  2,
                  8,
                  4,
                  7,
                  6,
                  1,
                  5,
                  15,
                  11,
                  9,
                  14,
                  3,
                  12,
                  13,
                  0,
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  14,
                  10,
                  4,
                  8,
                  9,
                  15,
                  13,
                  6,
                  1,
                  12,
                  0,
                  2,
                  11,
                  7,
                  5,
                  3
                ];
                const SIGMA82 = new Uint8Array(
                  SIGMA8.map(function(x) {
                    return x * 2;
                  })
                );
                const v = new Uint32Array(32);
                const m = new Uint32Array(32);
                function blake2bCompress(ctx, last) {
                  let i = 0;
                  for (i = 0; i < 16; i++) {
                    v[i] = ctx.h[i];
                    v[i + 16] = BLAKE2B_IV32[i];
                  }
                  v[24] = v[24] ^ ctx.t;
                  v[25] = v[25] ^ ctx.t / 4294967296;
                  if (last) {
                    v[28] = ~v[28];
                    v[29] = ~v[29];
                  }
                  for (i = 0; i < 32; i++) {
                    m[i] = B2B_GET32(ctx.b, 4 * i);
                  }
                  for (i = 0; i < 12; i++) {
                    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
                    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
                    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
                    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
                    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
                    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
                    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
                    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
                  }
                  for (i = 0; i < 16; i++) {
                    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
                  }
                }
                function blake2bInit(outlen, key) {
                  if (outlen === 0 || outlen > 64) {
                    throw new Error("Illegal output length, expected 0 < length <= 64");
                  }
                  if (key && key.length > 64) {
                    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
                  }
                  const ctx = {
                    b: new Uint8Array(128),
                    h: new Uint32Array(16),
                    t: 0,
                    // input count
                    c: 0,
                    // pointer within buffer
                    outlen
                    // output length in bytes
                  };
                  for (let i = 0; i < 16; i++) {
                    ctx.h[i] = BLAKE2B_IV32[i];
                  }
                  const keylen = key ? key.length : 0;
                  ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
                  if (key) {
                    blake2bUpdate(ctx, key);
                    ctx.c = 128;
                  }
                  return ctx;
                }
                function blake2bUpdate(ctx, input) {
                  for (let i = 0; i < input.length; i++) {
                    if (ctx.c === 128) {
                      ctx.t += ctx.c;
                      blake2bCompress(ctx, false);
                      ctx.c = 0;
                    }
                    ctx.b[ctx.c++] = input[i];
                  }
                }
                function blake2bFinal(ctx) {
                  ctx.t += ctx.c;
                  while (ctx.c < 128) {
                    ctx.b[ctx.c++] = 0;
                  }
                  blake2bCompress(ctx, true);
                  const out = new Uint8Array(ctx.outlen);
                  for (let i = 0; i < ctx.outlen; i++) {
                    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
                  }
                  return out;
                }
                function blake2b(input, key, outlen) {
                  outlen = outlen || 64;
                  input = util.normalizeInput(input);
                  const ctx = blake2bInit(outlen, key);
                  blake2bUpdate(ctx, input);
                  return blake2bFinal(ctx);
                }
                function blake2bHex(input, key, outlen) {
                  const output = blake2b(input, key, outlen);
                  return util.toHex(output);
                }
                module2.exports = {
                  blake2b,
                  blake2bHex,
                  blake2bInit,
                  blake2bUpdate,
                  blake2bFinal
                };
              }
            ),
            /***/
            8855: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                const util = __webpack_require__2(1022);
                function B2S_GET32(v2, i) {
                  return v2[i] ^ v2[i + 1] << 8 ^ v2[i + 2] << 16 ^ v2[i + 3] << 24;
                }
                function B2S_G(a, b, c, d, x, y) {
                  v[a] = v[a] + v[b] + x;
                  v[d] = ROTR32(v[d] ^ v[a], 16);
                  v[c] = v[c] + v[d];
                  v[b] = ROTR32(v[b] ^ v[c], 12);
                  v[a] = v[a] + v[b] + y;
                  v[d] = ROTR32(v[d] ^ v[a], 8);
                  v[c] = v[c] + v[d];
                  v[b] = ROTR32(v[b] ^ v[c], 7);
                }
                function ROTR32(x, y) {
                  return x >>> y ^ x << 32 - y;
                }
                const BLAKE2S_IV = new Uint32Array([
                  1779033703,
                  3144134277,
                  1013904242,
                  2773480762,
                  1359893119,
                  2600822924,
                  528734635,
                  1541459225
                ]);
                const SIGMA = new Uint8Array([
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  14,
                  10,
                  4,
                  8,
                  9,
                  15,
                  13,
                  6,
                  1,
                  12,
                  0,
                  2,
                  11,
                  7,
                  5,
                  3,
                  11,
                  8,
                  12,
                  0,
                  5,
                  2,
                  15,
                  13,
                  10,
                  14,
                  3,
                  6,
                  7,
                  1,
                  9,
                  4,
                  7,
                  9,
                  3,
                  1,
                  13,
                  12,
                  11,
                  14,
                  2,
                  6,
                  5,
                  10,
                  4,
                  0,
                  15,
                  8,
                  9,
                  0,
                  5,
                  7,
                  2,
                  4,
                  10,
                  15,
                  14,
                  1,
                  11,
                  12,
                  6,
                  8,
                  3,
                  13,
                  2,
                  12,
                  6,
                  10,
                  0,
                  11,
                  8,
                  3,
                  4,
                  13,
                  7,
                  5,
                  15,
                  14,
                  1,
                  9,
                  12,
                  5,
                  1,
                  15,
                  14,
                  13,
                  4,
                  10,
                  0,
                  7,
                  6,
                  3,
                  9,
                  2,
                  8,
                  11,
                  13,
                  11,
                  7,
                  14,
                  12,
                  1,
                  3,
                  9,
                  5,
                  0,
                  15,
                  4,
                  8,
                  6,
                  2,
                  10,
                  6,
                  15,
                  14,
                  9,
                  11,
                  3,
                  0,
                  8,
                  12,
                  2,
                  13,
                  7,
                  1,
                  4,
                  10,
                  5,
                  10,
                  2,
                  8,
                  4,
                  7,
                  6,
                  1,
                  5,
                  15,
                  11,
                  9,
                  14,
                  3,
                  12,
                  13,
                  0
                ]);
                const v = new Uint32Array(16);
                const m = new Uint32Array(16);
                function blake2sCompress(ctx, last) {
                  let i = 0;
                  for (i = 0; i < 8; i++) {
                    v[i] = ctx.h[i];
                    v[i + 8] = BLAKE2S_IV[i];
                  }
                  v[12] ^= ctx.t;
                  v[13] ^= ctx.t / 4294967296;
                  if (last) {
                    v[14] = ~v[14];
                  }
                  for (i = 0; i < 16; i++) {
                    m[i] = B2S_GET32(ctx.b, 4 * i);
                  }
                  for (i = 0; i < 10; i++) {
                    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
                    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
                    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
                    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
                    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
                    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
                    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
                    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
                  }
                  for (i = 0; i < 8; i++) {
                    ctx.h[i] ^= v[i] ^ v[i + 8];
                  }
                }
                function blake2sInit(outlen, key) {
                  if (!(outlen > 0 && outlen <= 32)) {
                    throw new Error("Incorrect output length, should be in [1, 32]");
                  }
                  const keylen = key ? key.length : 0;
                  if (key && !(keylen > 0 && keylen <= 32)) {
                    throw new Error("Incorrect key length, should be in [1, 32]");
                  }
                  const ctx = {
                    h: new Uint32Array(BLAKE2S_IV),
                    // hash state
                    b: new Uint8Array(64),
                    // input block
                    c: 0,
                    // pointer within block
                    t: 0,
                    // input count
                    outlen
                    // output length in bytes
                  };
                  ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
                  if (keylen > 0) {
                    blake2sUpdate(ctx, key);
                    ctx.c = 64;
                  }
                  return ctx;
                }
                function blake2sUpdate(ctx, input) {
                  for (let i = 0; i < input.length; i++) {
                    if (ctx.c === 64) {
                      ctx.t += ctx.c;
                      blake2sCompress(ctx, false);
                      ctx.c = 0;
                    }
                    ctx.b[ctx.c++] = input[i];
                  }
                }
                function blake2sFinal(ctx) {
                  ctx.t += ctx.c;
                  while (ctx.c < 64) {
                    ctx.b[ctx.c++] = 0;
                  }
                  blake2sCompress(ctx, true);
                  const out = new Uint8Array(ctx.outlen);
                  for (let i = 0; i < ctx.outlen; i++) {
                    out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
                  }
                  return out;
                }
                function blake2s(input, key, outlen) {
                  outlen = outlen || 32;
                  input = util.normalizeInput(input);
                  const ctx = blake2sInit(outlen, key);
                  blake2sUpdate(ctx, input);
                  return blake2sFinal(ctx);
                }
                function blake2sHex(input, key, outlen) {
                  const output = blake2s(input, key, outlen);
                  return util.toHex(output);
                }
                module2.exports = {
                  blake2s,
                  blake2sHex,
                  blake2sInit,
                  blake2sUpdate,
                  blake2sFinal
                };
              }
            ),
            /***/
            1161: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                const b2b = __webpack_require__2(7318);
                const b2s = __webpack_require__2(8855);
                module2.exports = {
                  blake2b: b2b.blake2b,
                  blake2bHex: b2b.blake2bHex,
                  blake2bInit: b2b.blake2bInit,
                  blake2bUpdate: b2b.blake2bUpdate,
                  blake2bFinal: b2b.blake2bFinal,
                  blake2s: b2s.blake2s,
                  blake2sHex: b2s.blake2sHex,
                  blake2sInit: b2s.blake2sInit,
                  blake2sUpdate: b2s.blake2sUpdate,
                  blake2sFinal: b2s.blake2sFinal
                };
              }
            ),
            /***/
            1022: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var Buffer = __webpack_require__2(8764)["Buffer"];
                const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
                function normalizeInput(input) {
                  let ret;
                  if (input instanceof Uint8Array) {
                    ret = input;
                  } else if (input instanceof Buffer) {
                    ret = new Uint8Array(input);
                  } else if (typeof input === "string") {
                    ret = new Uint8Array(Buffer.from(input, "utf8"));
                  } else {
                    throw new Error(ERROR_MSG_INPUT);
                  }
                  return ret;
                }
                function toHex(bytes) {
                  return Array.prototype.map.call(bytes, function(n) {
                    return (n < 16 ? "0" : "") + n.toString(16);
                  }).join("");
                }
                function uint32ToHex(val) {
                  return (4294967296 + val).toString(16).substring(1);
                }
                function debugPrint(label, arr, size) {
                  let msg = "\n" + label + " = ";
                  for (let i = 0; i < arr.length; i += 2) {
                    if (size === 32) {
                      msg += uint32ToHex(arr[i]).toUpperCase();
                      msg += " ";
                      msg += uint32ToHex(arr[i + 1]).toUpperCase();
                    } else if (size === 64) {
                      msg += uint32ToHex(arr[i + 1]).toUpperCase();
                      msg += uint32ToHex(arr[i]).toUpperCase();
                    } else
                      throw new Error("Invalid size " + size);
                    if (i % 6 === 4) {
                      msg += "\n" + new Array(label.length + 4).join(" ");
                    } else if (i < arr.length - 2) {
                      msg += " ";
                    }
                  }
                  console.log(msg);
                }
                function testSpeed(hashFn, N, M) {
                  let startMs = (/* @__PURE__ */ new Date()).getTime();
                  const input = new Uint8Array(N);
                  for (let i = 0; i < N; i++) {
                    input[i] = i % 256;
                  }
                  const genMs = (/* @__PURE__ */ new Date()).getTime();
                  console.log("Generated random input in " + (genMs - startMs) + "ms");
                  startMs = genMs;
                  for (let i = 0; i < M; i++) {
                    const hashHex = hashFn(input);
                    const hashMs = (/* @__PURE__ */ new Date()).getTime();
                    const ms = hashMs - startMs;
                    startMs = hashMs;
                    console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
                    console.log(
                      Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
                    );
                  }
                }
                module2.exports = {
                  normalizeInput,
                  toHex,
                  debugPrint,
                  testSpeed
                };
              }
            ),
            /***/
            9347: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var ws = null;
                if (typeof WebSocket !== "undefined") {
                  ws = WebSocket;
                } else if (typeof MozWebSocket !== "undefined") {
                  ws = MozWebSocket;
                } else if (typeof __webpack_require__2.g !== "undefined") {
                  ws = __webpack_require__2.g.WebSocket || __webpack_require__2.g.MozWebSocket;
                } else if (typeof window !== "undefined") {
                  ws = window.WebSocket || window.MozWebSocket;
                } else if (typeof self !== "undefined") {
                  ws = self.WebSocket || self.MozWebSocket;
                }
                module2.exports = ws;
              }
            ),
            /***/
            9992: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                const Yallist = __webpack_require__2(7279);
                const MAX = Symbol("max");
                const LENGTH = Symbol("length");
                const LENGTH_CALCULATOR = Symbol("lengthCalculator");
                const ALLOW_STALE = Symbol("allowStale");
                const MAX_AGE = Symbol("maxAge");
                const DISPOSE = Symbol("dispose");
                const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
                const LRU_LIST = Symbol("lruList");
                const CACHE = Symbol("cache");
                const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
                const naiveLength = () => 1;
                class LRUCache {
                  constructor(options) {
                    if (typeof options === "number")
                      options = { max: options };
                    if (!options)
                      options = {};
                    if (options.max && (typeof options.max !== "number" || options.max < 0))
                      throw new TypeError("max must be a non-negative number");
                    const max = this[MAX] = options.max || Infinity;
                    const lc = options.length || naiveLength;
                    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
                    this[ALLOW_STALE] = options.stale || false;
                    if (options.maxAge && typeof options.maxAge !== "number")
                      throw new TypeError("maxAge must be a number");
                    this[MAX_AGE] = options.maxAge || 0;
                    this[DISPOSE] = options.dispose;
                    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
                    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
                    this.reset();
                  }
                  // resize the cache when the max changes.
                  set max(mL) {
                    if (typeof mL !== "number" || mL < 0)
                      throw new TypeError("max must be a non-negative number");
                    this[MAX] = mL || Infinity;
                    trim(this);
                  }
                  get max() {
                    return this[MAX];
                  }
                  set allowStale(allowStale) {
                    this[ALLOW_STALE] = !!allowStale;
                  }
                  get allowStale() {
                    return this[ALLOW_STALE];
                  }
                  set maxAge(mA) {
                    if (typeof mA !== "number")
                      throw new TypeError("maxAge must be a non-negative number");
                    this[MAX_AGE] = mA;
                    trim(this);
                  }
                  get maxAge() {
                    return this[MAX_AGE];
                  }
                  // resize the cache when the lengthCalculator changes.
                  set lengthCalculator(lC) {
                    if (typeof lC !== "function")
                      lC = naiveLength;
                    if (lC !== this[LENGTH_CALCULATOR]) {
                      this[LENGTH_CALCULATOR] = lC;
                      this[LENGTH] = 0;
                      this[LRU_LIST].forEach((hit) => {
                        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                        this[LENGTH] += hit.length;
                      });
                    }
                    trim(this);
                  }
                  get lengthCalculator() {
                    return this[LENGTH_CALCULATOR];
                  }
                  get length() {
                    return this[LENGTH];
                  }
                  get itemCount() {
                    return this[LRU_LIST].length;
                  }
                  rforEach(fn, thisp) {
                    thisp = thisp || this;
                    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
                      const prev = walker.prev;
                      forEachStep(this, fn, walker, thisp);
                      walker = prev;
                    }
                  }
                  forEach(fn, thisp) {
                    thisp = thisp || this;
                    for (let walker = this[LRU_LIST].head; walker !== null; ) {
                      const next = walker.next;
                      forEachStep(this, fn, walker, thisp);
                      walker = next;
                    }
                  }
                  keys() {
                    return this[LRU_LIST].toArray().map((k) => k.key);
                  }
                  values() {
                    return this[LRU_LIST].toArray().map((k) => k.value);
                  }
                  reset() {
                    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
                      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
                    }
                    this[CACHE] = /* @__PURE__ */ new Map();
                    this[LRU_LIST] = new Yallist();
                    this[LENGTH] = 0;
                  }
                  dump() {
                    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
                      k: hit.key,
                      v: hit.value,
                      e: hit.now + (hit.maxAge || 0)
                    }).toArray().filter((h) => h);
                  }
                  dumpLru() {
                    return this[LRU_LIST];
                  }
                  set(key, value, maxAge) {
                    maxAge = maxAge || this[MAX_AGE];
                    if (maxAge && typeof maxAge !== "number")
                      throw new TypeError("maxAge must be a number");
                    const now = maxAge ? Date.now() : 0;
                    const len = this[LENGTH_CALCULATOR](value, key);
                    if (this[CACHE].has(key)) {
                      if (len > this[MAX]) {
                        del(this, this[CACHE].get(key));
                        return false;
                      }
                      const node = this[CACHE].get(key);
                      const item = node.value;
                      if (this[DISPOSE]) {
                        if (!this[NO_DISPOSE_ON_SET])
                          this[DISPOSE](key, item.value);
                      }
                      item.now = now;
                      item.maxAge = maxAge;
                      item.value = value;
                      this[LENGTH] += len - item.length;
                      item.length = len;
                      this.get(key);
                      trim(this);
                      return true;
                    }
                    const hit = new Entry(key, value, len, now, maxAge);
                    if (hit.length > this[MAX]) {
                      if (this[DISPOSE])
                        this[DISPOSE](key, value);
                      return false;
                    }
                    this[LENGTH] += hit.length;
                    this[LRU_LIST].unshift(hit);
                    this[CACHE].set(key, this[LRU_LIST].head);
                    trim(this);
                    return true;
                  }
                  has(key) {
                    if (!this[CACHE].has(key))
                      return false;
                    const hit = this[CACHE].get(key).value;
                    return !isStale(this, hit);
                  }
                  get(key) {
                    return get(this, key, true);
                  }
                  peek(key) {
                    return get(this, key, false);
                  }
                  pop() {
                    const node = this[LRU_LIST].tail;
                    if (!node)
                      return null;
                    del(this, node);
                    return node.value;
                  }
                  del(key) {
                    del(this, this[CACHE].get(key));
                  }
                  load(arr) {
                    this.reset();
                    const now = Date.now();
                    for (let l = arr.length - 1; l >= 0; l--) {
                      const hit = arr[l];
                      const expiresAt = hit.e || 0;
                      if (expiresAt === 0)
                        this.set(hit.k, hit.v);
                      else {
                        const maxAge = expiresAt - now;
                        if (maxAge > 0) {
                          this.set(hit.k, hit.v, maxAge);
                        }
                      }
                    }
                  }
                  prune() {
                    this[CACHE].forEach((value, key) => get(this, key, false));
                  }
                }
                const get = (self2, key, doUse) => {
                  const node = self2[CACHE].get(key);
                  if (node) {
                    const hit = node.value;
                    if (isStale(self2, hit)) {
                      del(self2, node);
                      if (!self2[ALLOW_STALE])
                        return void 0;
                    } else {
                      if (doUse) {
                        if (self2[UPDATE_AGE_ON_GET])
                          node.value.now = Date.now();
                        self2[LRU_LIST].unshiftNode(node);
                      }
                    }
                    return hit.value;
                  }
                };
                const isStale = (self2, hit) => {
                  if (!hit || !hit.maxAge && !self2[MAX_AGE])
                    return false;
                  const diff = Date.now() - hit.now;
                  return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
                };
                const trim = (self2) => {
                  if (self2[LENGTH] > self2[MAX]) {
                    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
                      const prev = walker.prev;
                      del(self2, walker);
                      walker = prev;
                    }
                  }
                };
                const del = (self2, node) => {
                  if (node) {
                    const hit = node.value;
                    if (self2[DISPOSE])
                      self2[DISPOSE](hit.key, hit.value);
                    self2[LENGTH] -= hit.length;
                    self2[CACHE].delete(hit.key);
                    self2[LRU_LIST].removeNode(node);
                  }
                };
                class Entry {
                  constructor(key, value, length, now, maxAge) {
                    this.key = key;
                    this.value = value;
                    this.length = length;
                    this.now = now;
                    this.maxAge = maxAge || 0;
                  }
                }
                const forEachStep = (self2, fn, node, thisp) => {
                  let hit = node.value;
                  if (isStale(self2, hit)) {
                    del(self2, node);
                    if (!self2[ALLOW_STALE])
                      hit = void 0;
                  }
                  if (hit)
                    fn.call(thisp, hit.value, hit.key, self2);
                };
                module2.exports = LRUCache;
              }
            ),
            /***/
            862: (
              /***/
              (module2) => {
                "use strict";
                module2.exports = function(Yallist) {
                  Yallist.prototype[Symbol.iterator] = function* () {
                    for (let walker = this.head; walker; walker = walker.next) {
                      yield walker.value;
                    }
                  };
                };
              }
            ),
            /***/
            7279: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                "use strict";
                module2.exports = Yallist;
                Yallist.Node = Node;
                Yallist.create = Yallist;
                function Yallist(list) {
                  var self2 = this;
                  if (!(self2 instanceof Yallist)) {
                    self2 = new Yallist();
                  }
                  self2.tail = null;
                  self2.head = null;
                  self2.length = 0;
                  if (list && typeof list.forEach === "function") {
                    list.forEach(function(item) {
                      self2.push(item);
                    });
                  } else if (arguments.length > 0) {
                    for (var i = 0, l = arguments.length; i < l; i++) {
                      self2.push(arguments[i]);
                    }
                  }
                  return self2;
                }
                Yallist.prototype.removeNode = function(node) {
                  if (node.list !== this) {
                    throw new Error("removing node which does not belong to this list");
                  }
                  var next = node.next;
                  var prev = node.prev;
                  if (next) {
                    next.prev = prev;
                  }
                  if (prev) {
                    prev.next = next;
                  }
                  if (node === this.head) {
                    this.head = next;
                  }
                  if (node === this.tail) {
                    this.tail = prev;
                  }
                  node.list.length--;
                  node.next = null;
                  node.prev = null;
                  node.list = null;
                };
                Yallist.prototype.unshiftNode = function(node) {
                  if (node === this.head) {
                    return;
                  }
                  if (node.list) {
                    node.list.removeNode(node);
                  }
                  var head = this.head;
                  node.list = this;
                  node.next = head;
                  if (head) {
                    head.prev = node;
                  }
                  this.head = node;
                  if (!this.tail) {
                    this.tail = node;
                  }
                  this.length++;
                };
                Yallist.prototype.pushNode = function(node) {
                  if (node === this.tail) {
                    return;
                  }
                  if (node.list) {
                    node.list.removeNode(node);
                  }
                  var tail = this.tail;
                  node.list = this;
                  node.prev = tail;
                  if (tail) {
                    tail.next = node;
                  }
                  this.tail = node;
                  if (!this.head) {
                    this.head = node;
                  }
                  this.length++;
                };
                Yallist.prototype.push = function() {
                  for (var i = 0, l = arguments.length; i < l; i++) {
                    push(this, arguments[i]);
                  }
                  return this.length;
                };
                Yallist.prototype.unshift = function() {
                  for (var i = 0, l = arguments.length; i < l; i++) {
                    unshift(this, arguments[i]);
                  }
                  return this.length;
                };
                Yallist.prototype.pop = function() {
                  if (!this.tail) {
                    return void 0;
                  }
                  var res = this.tail.value;
                  this.tail = this.tail.prev;
                  if (this.tail) {
                    this.tail.next = null;
                  } else {
                    this.head = null;
                  }
                  this.length--;
                  return res;
                };
                Yallist.prototype.shift = function() {
                  if (!this.head) {
                    return void 0;
                  }
                  var res = this.head.value;
                  this.head = this.head.next;
                  if (this.head) {
                    this.head.prev = null;
                  } else {
                    this.tail = null;
                  }
                  this.length--;
                  return res;
                };
                Yallist.prototype.forEach = function(fn, thisp) {
                  thisp = thisp || this;
                  for (var walker = this.head, i = 0; walker !== null; i++) {
                    fn.call(thisp, walker.value, i, this);
                    walker = walker.next;
                  }
                };
                Yallist.prototype.forEachReverse = function(fn, thisp) {
                  thisp = thisp || this;
                  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
                    fn.call(thisp, walker.value, i, this);
                    walker = walker.prev;
                  }
                };
                Yallist.prototype.get = function(n) {
                  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
                    walker = walker.next;
                  }
                  if (i === n && walker !== null) {
                    return walker.value;
                  }
                };
                Yallist.prototype.getReverse = function(n) {
                  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
                    walker = walker.prev;
                  }
                  if (i === n && walker !== null) {
                    return walker.value;
                  }
                };
                Yallist.prototype.map = function(fn, thisp) {
                  thisp = thisp || this;
                  var res = new Yallist();
                  for (var walker = this.head; walker !== null; ) {
                    res.push(fn.call(thisp, walker.value, this));
                    walker = walker.next;
                  }
                  return res;
                };
                Yallist.prototype.mapReverse = function(fn, thisp) {
                  thisp = thisp || this;
                  var res = new Yallist();
                  for (var walker = this.tail; walker !== null; ) {
                    res.push(fn.call(thisp, walker.value, this));
                    walker = walker.prev;
                  }
                  return res;
                };
                Yallist.prototype.reduce = function(fn, initial) {
                  var acc;
                  var walker = this.head;
                  if (arguments.length > 1) {
                    acc = initial;
                  } else if (this.head) {
                    walker = this.head.next;
                    acc = this.head.value;
                  } else {
                    throw new TypeError("Reduce of empty list with no initial value");
                  }
                  for (var i = 0; walker !== null; i++) {
                    acc = fn(acc, walker.value, i);
                    walker = walker.next;
                  }
                  return acc;
                };
                Yallist.prototype.reduceReverse = function(fn, initial) {
                  var acc;
                  var walker = this.tail;
                  if (arguments.length > 1) {
                    acc = initial;
                  } else if (this.tail) {
                    walker = this.tail.prev;
                    acc = this.tail.value;
                  } else {
                    throw new TypeError("Reduce of empty list with no initial value");
                  }
                  for (var i = this.length - 1; walker !== null; i--) {
                    acc = fn(acc, walker.value, i);
                    walker = walker.prev;
                  }
                  return acc;
                };
                Yallist.prototype.toArray = function() {
                  var arr = new Array(this.length);
                  for (var i = 0, walker = this.head; walker !== null; i++) {
                    arr[i] = walker.value;
                    walker = walker.next;
                  }
                  return arr;
                };
                Yallist.prototype.toArrayReverse = function() {
                  var arr = new Array(this.length);
                  for (var i = 0, walker = this.tail; walker !== null; i++) {
                    arr[i] = walker.value;
                    walker = walker.prev;
                  }
                  return arr;
                };
                Yallist.prototype.slice = function(from, to) {
                  to = to || this.length;
                  if (to < 0) {
                    to += this.length;
                  }
                  from = from || 0;
                  if (from < 0) {
                    from += this.length;
                  }
                  var ret = new Yallist();
                  if (to < from || to < 0) {
                    return ret;
                  }
                  if (from < 0) {
                    from = 0;
                  }
                  if (to > this.length) {
                    to = this.length;
                  }
                  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
                    walker = walker.next;
                  }
                  for (; walker !== null && i < to; i++, walker = walker.next) {
                    ret.push(walker.value);
                  }
                  return ret;
                };
                Yallist.prototype.sliceReverse = function(from, to) {
                  to = to || this.length;
                  if (to < 0) {
                    to += this.length;
                  }
                  from = from || 0;
                  if (from < 0) {
                    from += this.length;
                  }
                  var ret = new Yallist();
                  if (to < from || to < 0) {
                    return ret;
                  }
                  if (from < 0) {
                    from = 0;
                  }
                  if (to > this.length) {
                    to = this.length;
                  }
                  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
                    walker = walker.prev;
                  }
                  for (; walker !== null && i > from; i--, walker = walker.prev) {
                    ret.push(walker.value);
                  }
                  return ret;
                };
                Yallist.prototype.reverse = function() {
                  var head = this.head;
                  var tail = this.tail;
                  for (var walker = head; walker !== null; walker = walker.prev) {
                    var p = walker.prev;
                    walker.prev = walker.next;
                    walker.next = p;
                  }
                  this.head = tail;
                  this.tail = head;
                  return this;
                };
                function push(self2, item) {
                  self2.tail = new Node(item, self2.tail, null, self2);
                  if (!self2.head) {
                    self2.head = self2.tail;
                  }
                  self2.length++;
                }
                function unshift(self2, item) {
                  self2.head = new Node(item, null, self2.head, self2);
                  if (!self2.tail) {
                    self2.tail = self2.head;
                  }
                  self2.length++;
                }
                function Node(value, prev, next, list) {
                  if (!(this instanceof Node)) {
                    return new Node(value, prev, next, list);
                  }
                  this.list = list;
                  this.value = value;
                  if (prev) {
                    prev.next = this;
                    this.prev = prev;
                  } else {
                    this.prev = null;
                  }
                  if (next) {
                    next.prev = this;
                    this.next = next;
                  } else {
                    this.next = null;
                  }
                }
                try {
                  __webpack_require__2(862)(Yallist);
                } catch (er) {
                }
              }
            ),
            /***/
            3609: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.version = "4.0.27-5";
              }
            ),
            /***/
            8707: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                var bignumber_1 = __webpack_require__2(4759);
                var AddressZero = "0x0000000000000000000000000000000000000000";
                exports2.AddressZero = AddressZero;
                var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
                exports2.HashZero = HashZero;
                var EtherSymbol = "";
                exports2.EtherSymbol = EtherSymbol;
                var NegativeOne = bignumber_1.bigNumberify(-1);
                exports2.NegativeOne = NegativeOne;
                var Zero = bignumber_1.bigNumberify(0);
                exports2.Zero = Zero;
                var One = bignumber_1.bigNumberify(1);
                exports2.One = One;
                var Two = bignumber_1.bigNumberify(2);
                exports2.Two = Two;
                var WeiPerEther = bignumber_1.bigNumberify("1000000000000000000");
                exports2.WeiPerEther = WeiPerEther;
                var MaxUint256 = bignumber_1.bigNumberify("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
                exports2.MaxUint256 = MaxUint256;
              }
            ),
            /***/
            6459: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                var _version_1 = __webpack_require__2(3609);
                exports2.UNKNOWN_ERROR = "UNKNOWN_ERROR";
                exports2.NOT_IMPLEMENTED = "NOT_IMPLEMENTED";
                exports2.MISSING_NEW = "MISSING_NEW";
                exports2.CALL_EXCEPTION = "CALL_EXCEPTION";
                exports2.INVALID_ARGUMENT = "INVALID_ARGUMENT";
                exports2.MISSING_ARGUMENT = "MISSING_ARGUMENT";
                exports2.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT";
                exports2.NUMERIC_FAULT = "NUMERIC_FAULT";
                exports2.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS";
                exports2.NONCE_EXPIRED = "NONCE_EXPIRED";
                exports2.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED";
                exports2.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION";
                var _permanentCensorErrors = false;
                var _censorErrors = false;
                function throwError(message, code, params) {
                  if (_censorErrors) {
                    throw new Error("unknown error");
                  }
                  if (!code) {
                    code = exports2.UNKNOWN_ERROR;
                  }
                  if (!params) {
                    params = {};
                  }
                  var messageDetails = [];
                  Object.keys(params).forEach(function(key) {
                    try {
                      messageDetails.push(key + "=" + JSON.stringify(params[key]));
                    } catch (error2) {
                      messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
                    }
                  });
                  messageDetails.push("version=" + _version_1.version);
                  var reason = message;
                  if (messageDetails.length) {
                    message += " (" + messageDetails.join(", ") + ")";
                  }
                  var error = new Error(message);
                  error.reason = reason;
                  error.code = code;
                  Object.keys(params).forEach(function(key) {
                    error[key] = params[key];
                  });
                  throw error;
                }
                exports2.throwError = throwError;
                function checkNew(self2, kind) {
                  if (!(self2 instanceof kind)) {
                    throwError("missing new", exports2.MISSING_NEW, { name: kind.name });
                  }
                }
                exports2.checkNew = checkNew;
                function checkArgumentCount(count, expectedCount, suffix) {
                  if (!suffix) {
                    suffix = "";
                  }
                  if (count < expectedCount) {
                    throwError("missing argument" + suffix, exports2.MISSING_ARGUMENT, { count, expectedCount });
                  }
                  if (count > expectedCount) {
                    throwError("too many arguments" + suffix, exports2.UNEXPECTED_ARGUMENT, { count, expectedCount });
                  }
                }
                exports2.checkArgumentCount = checkArgumentCount;
                function setCensorship(censorship, permanent) {
                  if (_permanentCensorErrors) {
                    throwError("error censorship permanent", exports2.UNSUPPORTED_OPERATION, { operation: "setCensorship" });
                  }
                  _censorErrors = !!censorship;
                  _permanentCensorErrors = !!permanent;
                }
                exports2.setCensorship = setCensorship;
                function checkNormalize() {
                  try {
                    ["NFD", "NFC", "NFKD", "NFKC"].forEach(function(form) {
                      try {
                        "test".normalize(form);
                      } catch (error) {
                        throw new Error("missing " + form);
                      }
                    });
                    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
                      throw new Error("broken implementation");
                    }
                  } catch (error) {
                    throwError("platform missing String.prototype.normalize", exports2.UNSUPPORTED_OPERATION, { operation: "String.prototype.normalize", form: error.message });
                  }
                }
                exports2.checkNormalize = checkNormalize;
                var LogLevels = { debug: 1, "default": 2, info: 2, warn: 3, error: 4, off: 5 };
                var LogLevel = LogLevels["default"];
                function setLogLevel(logLevel) {
                  var level = LogLevels[logLevel];
                  if (level == null) {
                    warn("invliad log level - " + logLevel);
                    return;
                  }
                  LogLevel = level;
                }
                exports2.setLogLevel = setLogLevel;
                function log(logLevel, args) {
                  if (LogLevel > LogLevels[logLevel]) {
                    return;
                  }
                  console.log.apply(console, args);
                }
                function warn() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  log("warn", args);
                }
                exports2.warn = warn;
                function info() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  log("info", args);
                }
                exports2.info = info;
              }
            ),
            /***/
            2046: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var __extends = this && this.__extends || function() {
                  var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                    d.__proto__ = b;
                  } || function(d, b) {
                    for (var p in b)
                      if (b.hasOwnProperty(p))
                        d[p] = b[p];
                  };
                  return function(d, b) {
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                  };
                }();
                var __importStar = this && this.__importStar || function(mod) {
                  if (mod && mod.__esModule)
                    return mod;
                  var result = {};
                  if (mod != null) {
                    for (var k in mod)
                      if (Object.hasOwnProperty.call(mod, k))
                        result[k] = mod[k];
                  }
                  result["default"] = mod;
                  return result;
                };
                Object.defineProperty(exports2, "__esModule", { value: true });
                var constants_1 = __webpack_require__2(8707);
                var errors = __importStar(__webpack_require__2(6459));
                var address_1 = __webpack_require__2(5638);
                var bignumber_1 = __webpack_require__2(4759);
                var bytes_1 = __webpack_require__2(8458);
                var utf8_1 = __webpack_require__2(1165);
                var properties_1 = __webpack_require__2(8184);
                var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
                var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
                var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
                exports2.defaultCoerceFunc = function(type, value) {
                  var match = type.match(paramTypeNumber);
                  if (match && parseInt(match[2]) <= 48) {
                    return value.toNumber();
                  }
                  return value;
                };
                var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
                var regexIdentifier = new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");
                function verifyType(type) {
                  if (type.match(/^uint($|[^1-9])/)) {
                    type = "uint256" + type.substring(4);
                  } else if (type.match(/^int($|[^1-9])/)) {
                    type = "int256" + type.substring(3);
                  }
                  return type;
                }
                function parseParam(param, allowIndexed) {
                  var originalParam = param;
                  function throwError(i2) {
                    throw new Error('unexpected character "' + originalParam[i2] + '" at position ' + i2 + ' in "' + originalParam + '"');
                  }
                  param = param.replace(/\s/g, " ");
                  var parent = { type: "", name: "", state: { allowType: true } };
                  var node = parent;
                  for (var i = 0; i < param.length; i++) {
                    var c = param[i];
                    switch (c) {
                      case "(":
                        if (!node.state.allowParams) {
                          throwError(i);
                        }
                        node.state.allowType = false;
                        node.type = verifyType(node.type);
                        node.components = [{ type: "", name: "", parent: node, state: { allowType: true } }];
                        node = node.components[0];
                        break;
                      case ")":
                        delete node.state;
                        if (allowIndexed && node.name === "indexed") {
                          node.indexed = true;
                          node.name = "";
                        }
                        node.type = verifyType(node.type);
                        var child = node;
                        node = node.parent;
                        if (!node) {
                          throwError(i);
                        }
                        delete child.parent;
                        node.state.allowParams = false;
                        node.state.allowName = true;
                        node.state.allowArray = true;
                        break;
                      case ",":
                        delete node.state;
                        if (allowIndexed && node.name === "indexed") {
                          node.indexed = true;
                          node.name = "";
                        }
                        node.type = verifyType(node.type);
                        var sibling = { type: "", name: "", parent: node.parent, state: { allowType: true } };
                        node.parent.components.push(sibling);
                        delete node.parent;
                        node = sibling;
                        break;
                      case " ":
                        if (node.state.allowType) {
                          if (node.type !== "") {
                            node.type = verifyType(node.type);
                            delete node.state.allowType;
                            node.state.allowName = true;
                            node.state.allowParams = true;
                          }
                        }
                        if (node.state.allowName) {
                          if (node.name !== "") {
                            if (allowIndexed && node.name === "indexed") {
                              node.indexed = true;
                              node.name = "";
                            } else {
                              node.state.allowName = false;
                            }
                          }
                        }
                        break;
                      case "[":
                        if (!node.state.allowArray) {
                          throwError(i);
                        }
                        node.type += c;
                        node.state.allowArray = false;
                        node.state.allowName = false;
                        node.state.readArray = true;
                        break;
                      case "]":
                        if (!node.state.readArray) {
                          throwError(i);
                        }
                        node.type += c;
                        node.state.readArray = false;
                        node.state.allowArray = true;
                        node.state.allowName = true;
                        break;
                      default:
                        if (node.state.allowType) {
                          node.type += c;
                          node.state.allowParams = true;
                          node.state.allowArray = true;
                        } else if (node.state.allowName) {
                          node.name += c;
                          delete node.state.allowArray;
                        } else if (node.state.readArray) {
                          node.type += c;
                        } else {
                          throwError(i);
                        }
                    }
                  }
                  if (node.parent) {
                    throw new Error("unexpected eof");
                  }
                  delete parent.state;
                  if (allowIndexed && node.name === "indexed") {
                    node.indexed = true;
                    node.name = "";
                  }
                  parent.type = verifyType(parent.type);
                  return parent;
                }
                function parseSignatureEvent(fragment) {
                  var abi = {
                    anonymous: false,
                    inputs: [],
                    name: "",
                    type: "event"
                  };
                  var match = fragment.match(regexParen);
                  if (!match) {
                    throw new Error("invalid event: " + fragment);
                  }
                  abi.name = match[1].trim();
                  splitNesting(match[2]).forEach(function(param) {
                    param = parseParam(param, true);
                    param.indexed = !!param.indexed;
                    abi.inputs.push(param);
                  });
                  match[3].split(" ").forEach(function(modifier) {
                    switch (modifier) {
                      case "anonymous":
                        abi.anonymous = true;
                        break;
                      case "":
                        break;
                      default:
                        errors.info("unknown modifier: " + modifier);
                    }
                  });
                  if (abi.name && !abi.name.match(regexIdentifier)) {
                    throw new Error('invalid identifier: "' + abi.name + '"');
                  }
                  return abi;
                }
                function parseSignatureFunction(fragment) {
                  var abi = {
                    constant: false,
                    gas: null,
                    inputs: [],
                    name: "",
                    outputs: [],
                    payable: false,
                    stateMutability: null,
                    type: "function"
                  };
                  var comps = fragment.split("@");
                  if (comps.length !== 1) {
                    if (comps.length > 2) {
                      throw new Error("invalid signature");
                    }
                    if (!comps[1].match(/^[0-9]+$/)) {
                      throw new Error("invalid signature gas");
                    }
                    abi.gas = bignumber_1.bigNumberify(comps[1]);
                    fragment = comps[0];
                  }
                  comps = fragment.split(" returns ");
                  var left = comps[0].match(regexParen);
                  if (!left) {
                    throw new Error("invalid signature");
                  }
                  abi.name = left[1].trim();
                  if (!abi.name.match(regexIdentifier)) {
                    throw new Error('invalid identifier: "' + left[1] + '"');
                  }
                  splitNesting(left[2]).forEach(function(param) {
                    abi.inputs.push(parseParam(param));
                  });
                  left[3].split(" ").forEach(function(modifier) {
                    switch (modifier) {
                      case "constant":
                        abi.constant = true;
                        break;
                      case "payable":
                        abi.payable = true;
                        abi.stateMutability = "payable";
                        break;
                      case "pure":
                        abi.constant = true;
                        abi.stateMutability = "pure";
                        break;
                      case "view":
                        abi.constant = true;
                        abi.stateMutability = "view";
                        break;
                      case "external":
                      case "public":
                      case "":
                        break;
                      default:
                        errors.info("unknown modifier: " + modifier);
                    }
                  });
                  if (comps.length > 1) {
                    var right = comps[1].match(regexParen);
                    if (right[1].trim() != "" || right[3].trim() != "") {
                      throw new Error("unexpected tokens");
                    }
                    splitNesting(right[2]).forEach(function(param) {
                      abi.outputs.push(parseParam(param));
                    });
                  }
                  if (abi.name === "constructor") {
                    abi.type = "constructor";
                    if (abi.outputs.length) {
                      throw new Error("constructor may not have outputs");
                    }
                    delete abi.name;
                    delete abi.outputs;
                  }
                  return abi;
                }
                function parseParamType(type) {
                  return parseParam(type, true);
                }
                exports2.parseParamType = parseParamType;
                function formatParamType(paramType) {
                  return getParamCoder(exports2.defaultCoerceFunc, paramType).type;
                }
                exports2.formatParamType = formatParamType;
                function formatSignature(fragment) {
                  return fragment.name + "(" + fragment.inputs.map(function(i) {
                    return formatParamType(i);
                  }).join(",") + ")";
                }
                exports2.formatSignature = formatSignature;
                function parseSignature(fragment) {
                  if (typeof fragment === "string") {
                    fragment = fragment.replace(/\s/g, " ");
                    fragment = fragment.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
                    fragment = fragment.trim();
                    if (fragment.substring(0, 6) === "event ") {
                      return parseSignatureEvent(fragment.substring(6).trim());
                    } else {
                      if (fragment.substring(0, 9) === "function ") {
                        fragment = fragment.substring(9);
                      }
                      return parseSignatureFunction(fragment.trim());
                    }
                  }
                  throw new Error("unknown signature");
                }
                exports2.parseSignature = parseSignature;
                var Coder = (
                  /** @class */
                  /* @__PURE__ */ function() {
                    function Coder2(coerceFunc, name2, type, localName, dynamic) {
                      this.coerceFunc = coerceFunc;
                      this.name = name2;
                      this.type = type;
                      this.localName = localName;
                      this.dynamic = dynamic;
                    }
                    return Coder2;
                  }()
                );
                var CoderAnonymous = (
                  /** @class */
                  function(_super) {
                    __extends(CoderAnonymous2, _super);
                    function CoderAnonymous2(coder) {
                      var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, void 0, coder.dynamic) || this;
                      properties_1.defineReadOnly(_this, "coder", coder);
                      return _this;
                    }
                    CoderAnonymous2.prototype.encode = function(value) {
                      return this.coder.encode(value);
                    };
                    CoderAnonymous2.prototype.decode = function(data, offset) {
                      return this.coder.decode(data, offset);
                    };
                    return CoderAnonymous2;
                  }(Coder)
                );
                var CoderNull = (
                  /** @class */
                  function(_super) {
                    __extends(CoderNull2, _super);
                    function CoderNull2(coerceFunc, localName) {
                      return _super.call(this, coerceFunc, "null", "", localName, false) || this;
                    }
                    CoderNull2.prototype.encode = function(value) {
                      return bytes_1.arrayify([]);
                    };
                    CoderNull2.prototype.decode = function(data, offset) {
                      if (offset > data.length) {
                        throw new Error("invalid null");
                      }
                      return {
                        consumed: 0,
                        value: this.coerceFunc("null", void 0)
                      };
                    };
                    return CoderNull2;
                  }(Coder)
                );
                var CoderNumber = (
                  /** @class */
                  function(_super) {
                    __extends(CoderNumber2, _super);
                    function CoderNumber2(coerceFunc, size, signed, localName) {
                      var _this = this;
                      var name2 = (signed ? "int" : "uint") + size * 8;
                      _this = _super.call(this, coerceFunc, name2, name2, localName, false) || this;
                      _this.size = size;
                      _this.signed = signed;
                      return _this;
                    }
                    CoderNumber2.prototype.encode = function(value) {
                      try {
                        var v = bignumber_1.bigNumberify(value);
                        if (this.signed) {
                          var bounds = constants_1.MaxUint256.maskn(this.size * 8 - 1);
                          if (v.gt(bounds)) {
                            throw new Error("out-of-bounds");
                          }
                          bounds = bounds.add(constants_1.One).mul(constants_1.NegativeOne);
                          if (v.lt(bounds)) {
                            throw new Error("out-of-bounds");
                          }
                        } else if (v.lt(constants_1.Zero) || v.gt(constants_1.MaxUint256.maskn(this.size * 8))) {
                          throw new Error("out-of-bounds");
                        }
                        v = v.toTwos(this.size * 8).maskn(this.size * 8);
                        if (this.signed) {
                          v = v.fromTwos(this.size * 8).toTwos(256);
                        }
                        return bytes_1.padZeros(bytes_1.arrayify(v), 32);
                      } catch (error) {
                        errors.throwError("invalid number value", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: this.name,
                          value
                        });
                      }
                      return null;
                    };
                    CoderNumber2.prototype.decode = function(data, offset) {
                      if (data.length < offset + 32) {
                        errors.throwError("insufficient data for " + this.name + " type", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: this.name,
                          value: bytes_1.hexlify(data.slice(offset, offset + 32))
                        });
                      }
                      var junkLength = 32 - this.size;
                      var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));
                      if (this.signed) {
                        value = value.fromTwos(this.size * 8);
                      } else {
                        value = value.maskn(this.size * 8);
                      }
                      return {
                        consumed: 32,
                        value: this.coerceFunc(this.name, value)
                      };
                    };
                    return CoderNumber2;
                  }(Coder)
                );
                var uint256Coder = new CoderNumber(function(type, value) {
                  return value;
                }, 32, false, "none");
                var CoderBoolean = (
                  /** @class */
                  function(_super) {
                    __extends(CoderBoolean2, _super);
                    function CoderBoolean2(coerceFunc, localName) {
                      return _super.call(this, coerceFunc, "bool", "bool", localName, false) || this;
                    }
                    CoderBoolean2.prototype.encode = function(value) {
                      return uint256Coder.encode(!!value ? 1 : 0);
                    };
                    CoderBoolean2.prototype.decode = function(data, offset) {
                      try {
                        var result = uint256Coder.decode(data, offset);
                      } catch (error) {
                        if (error.reason === "insufficient data for uint256 type") {
                          errors.throwError("insufficient data for boolean type", errors.INVALID_ARGUMENT, {
                            arg: this.localName,
                            coderType: "boolean",
                            value: error.value
                          });
                        }
                        throw error;
                      }
                      return {
                        consumed: result.consumed,
                        value: this.coerceFunc("bool", !result.value.isZero())
                      };
                    };
                    return CoderBoolean2;
                  }(Coder)
                );
                var CoderFixedBytes = (
                  /** @class */
                  function(_super) {
                    __extends(CoderFixedBytes2, _super);
                    function CoderFixedBytes2(coerceFunc, length, localName) {
                      var _this = this;
                      var name2 = "bytes" + length;
                      _this = _super.call(this, coerceFunc, name2, name2, localName, false) || this;
                      _this.length = length;
                      return _this;
                    }
                    CoderFixedBytes2.prototype.encode = function(value) {
                      var result = new Uint8Array(32);
                      try {
                        var data = bytes_1.arrayify(value);
                        if (data.length !== this.length) {
                          throw new Error("incorrect data length");
                        }
                        result.set(data);
                      } catch (error) {
                        errors.throwError("invalid " + this.name + " value", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: this.name,
                          value: error.value || value
                        });
                      }
                      return result;
                    };
                    CoderFixedBytes2.prototype.decode = function(data, offset) {
                      if (data.length < offset + 32) {
                        errors.throwError("insufficient data for " + name + " type", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: this.name,
                          value: bytes_1.hexlify(data.slice(offset, offset + 32))
                        });
                      }
                      return {
                        consumed: 32,
                        value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))
                      };
                    };
                    return CoderFixedBytes2;
                  }(Coder)
                );
                var CoderAddress = (
                  /** @class */
                  function(_super) {
                    __extends(CoderAddress2, _super);
                    function CoderAddress2(coerceFunc, localName) {
                      return _super.call(this, coerceFunc, "address", "address", localName, false) || this;
                    }
                    CoderAddress2.prototype.encode = function(value) {
                      var result = new Uint8Array(32);
                      try {
                        result.set(bytes_1.arrayify(address_1.getAddress(value, false)), 12);
                      } catch (error) {
                        errors.throwError("invalid address", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: "address",
                          value
                        });
                      }
                      return result;
                    };
                    CoderAddress2.prototype.decode = function(data, offset) {
                      if (data.length < offset + 32) {
                        errors.throwError("insufficuent data for address type", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: "address",
                          value: bytes_1.hexlify(data.slice(offset, offset + 32))
                        });
                      }
                      return {
                        consumed: 32,
                        value: this.coerceFunc("address", address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32)), false))
                      };
                    };
                    return CoderAddress2;
                  }(Coder)
                );
                function _encodeDynamicBytes(value) {
                  var dataLength = 32 * Math.ceil(value.length / 32);
                  var padding = new Uint8Array(dataLength - value.length);
                  return bytes_1.concat([
                    uint256Coder.encode(value.length),
                    value,
                    padding
                  ]);
                }
                function _decodeDynamicBytes(data, offset, localName) {
                  if (data.length < offset + 32) {
                    errors.throwError("insufficient data for dynamicBytes length", errors.INVALID_ARGUMENT, {
                      arg: localName,
                      coderType: "dynamicBytes",
                      value: bytes_1.hexlify(data.slice(offset, offset + 32))
                    });
                  }
                  var length = uint256Coder.decode(data, offset).value;
                  try {
                    length = length.toNumber();
                  } catch (error) {
                    errors.throwError("dynamic bytes count too large", errors.INVALID_ARGUMENT, {
                      arg: localName,
                      coderType: "dynamicBytes",
                      value: length.toString()
                    });
                  }
                  if (data.length < offset + 32 + length) {
                    errors.throwError("insufficient data for dynamicBytes type", errors.INVALID_ARGUMENT, {
                      arg: localName,
                      coderType: "dynamicBytes",
                      value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))
                    });
                  }
                  return {
                    consumed: 32 + 32 * Math.ceil(length / 32),
                    value: data.slice(offset + 32, offset + 32 + length)
                  };
                }
                var CoderDynamicBytes = (
                  /** @class */
                  function(_super) {
                    __extends(CoderDynamicBytes2, _super);
                    function CoderDynamicBytes2(coerceFunc, localName) {
                      return _super.call(this, coerceFunc, "bytes", "bytes", localName, true) || this;
                    }
                    CoderDynamicBytes2.prototype.encode = function(value) {
                      try {
                        return _encodeDynamicBytes(bytes_1.arrayify(value));
                      } catch (error) {
                        errors.throwError("invalid bytes value", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: "bytes",
                          value: error.value
                        });
                      }
                      return null;
                    };
                    CoderDynamicBytes2.prototype.decode = function(data, offset) {
                      var result = _decodeDynamicBytes(data, offset, this.localName);
                      result.value = this.coerceFunc("bytes", bytes_1.hexlify(result.value));
                      return result;
                    };
                    return CoderDynamicBytes2;
                  }(Coder)
                );
                var CoderString = (
                  /** @class */
                  function(_super) {
                    __extends(CoderString2, _super);
                    function CoderString2(coerceFunc, localName) {
                      return _super.call(this, coerceFunc, "string", "string", localName, true) || this;
                    }
                    CoderString2.prototype.encode = function(value) {
                      if (typeof value !== "string") {
                        errors.throwError("invalid string value", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: "string",
                          value
                        });
                      }
                      return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));
                    };
                    CoderString2.prototype.decode = function(data, offset) {
                      var result = _decodeDynamicBytes(data, offset, this.localName);
                      result.value = this.coerceFunc("string", utf8_1.toUtf8String(result.value));
                      return result;
                    };
                    return CoderString2;
                  }(Coder)
                );
                function alignSize(size) {
                  return 32 * Math.ceil(size / 32);
                }
                function pack(coders, values) {
                  if (Array.isArray(values)) {
                  } else if (values && typeof values === "object") {
                    var arrayValues = [];
                    coders.forEach(function(coder) {
                      arrayValues.push(values[coder.localName]);
                    });
                    values = arrayValues;
                  } else {
                    errors.throwError("invalid tuple value", errors.INVALID_ARGUMENT, {
                      coderType: "tuple",
                      value: values
                    });
                  }
                  if (coders.length !== values.length) {
                    errors.throwError("types/value length mismatch", errors.INVALID_ARGUMENT, {
                      coderType: "tuple",
                      value: values
                    });
                  }
                  var parts = [];
                  coders.forEach(function(coder, index) {
                    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });
                  });
                  var staticSize = 0, dynamicSize = 0;
                  parts.forEach(function(part) {
                    if (part.dynamic) {
                      staticSize += 32;
                      dynamicSize += alignSize(part.value.length);
                    } else {
                      staticSize += alignSize(part.value.length);
                    }
                  });
                  var offset = 0, dynamicOffset = staticSize;
                  var data = new Uint8Array(staticSize + dynamicSize);
                  parts.forEach(function(part) {
                    if (part.dynamic) {
                      data.set(uint256Coder.encode(dynamicOffset), offset);
                      offset += 32;
                      data.set(part.value, dynamicOffset);
                      dynamicOffset += alignSize(part.value.length);
                    } else {
                      data.set(part.value, offset);
                      offset += alignSize(part.value.length);
                    }
                  });
                  return data;
                }
                function unpack(coders, data, offset) {
                  var baseOffset = offset;
                  var consumed = 0;
                  var value = [];
                  coders.forEach(function(coder) {
                    if (coder.dynamic) {
                      var dynamicOffset = uint256Coder.decode(data, offset);
                      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());
                      result.consumed = dynamicOffset.consumed;
                    } else {
                      var result = coder.decode(data, offset);
                    }
                    if (result.value != void 0) {
                      value.push(result.value);
                    }
                    offset += result.consumed;
                    consumed += result.consumed;
                  });
                  coders.forEach(function(coder, index) {
                    var name2 = coder.localName;
                    if (!name2) {
                      return;
                    }
                    if (name2 === "length") {
                      name2 = "_length";
                    }
                    if (value[name2] != null) {
                      return;
                    }
                    value[name2] = value[index];
                  });
                  return {
                    value,
                    consumed
                  };
                }
                var CoderArray = (
                  /** @class */
                  function(_super) {
                    __extends(CoderArray2, _super);
                    function CoderArray2(coerceFunc, coder, length, localName) {
                      var _this = this;
                      var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
                      var dynamic = length === -1 || coder.dynamic;
                      _this = _super.call(this, coerceFunc, "array", type, localName, dynamic) || this;
                      _this.coder = coder;
                      _this.length = length;
                      return _this;
                    }
                    CoderArray2.prototype.encode = function(value) {
                      if (!Array.isArray(value)) {
                        errors.throwError("expected array value", errors.INVALID_ARGUMENT, {
                          arg: this.localName,
                          coderType: "array",
                          value
                        });
                      }
                      var count = this.length;
                      var result = new Uint8Array(0);
                      if (count === -1) {
                        count = value.length;
                        result = uint256Coder.encode(count);
                      }
                      errors.checkArgumentCount(count, value.length, " in coder array" + (this.localName ? " " + this.localName : ""));
                      var coders = [];
                      for (var i = 0; i < value.length; i++) {
                        coders.push(this.coder);
                      }
                      return bytes_1.concat([result, pack(coders, value)]);
                    };
                    CoderArray2.prototype.decode = function(data, offset) {
                      var consumed = 0;
                      var count = this.length;
                      if (count === -1) {
                        try {
                          var decodedLength = uint256Coder.decode(data, offset);
                        } catch (error) {
                          errors.throwError("insufficient data for dynamic array length", errors.INVALID_ARGUMENT, {
                            arg: this.localName,
                            coderType: "array",
                            value: error.value
                          });
                        }
                        try {
                          count = decodedLength.value.toNumber();
                        } catch (error) {
                          errors.throwError("array count too large", errors.INVALID_ARGUMENT, {
                            arg: this.localName,
                            coderType: "array",
                            value: decodedLength.value.toString()
                          });
                        }
                        consumed += decodedLength.consumed;
                        offset += decodedLength.consumed;
                      }
                      var coders = [];
                      for (var i = 0; i < count; i++) {
                        coders.push(new CoderAnonymous(this.coder));
                      }
                      var result = unpack(coders, data, offset);
                      result.consumed += consumed;
                      result.value = this.coerceFunc(this.type, result.value);
                      return result;
                    };
                    return CoderArray2;
                  }(Coder)
                );
                var CoderTuple = (
                  /** @class */
                  function(_super) {
                    __extends(CoderTuple2, _super);
                    function CoderTuple2(coerceFunc, coders, localName) {
                      var _this = this;
                      var dynamic = false;
                      var types = [];
                      coders.forEach(function(coder) {
                        if (coder.dynamic) {
                          dynamic = true;
                        }
                        types.push(coder.type);
                      });
                      var type = "tuple(" + types.join(",") + ")";
                      _this = _super.call(this, coerceFunc, "tuple", type, localName, dynamic) || this;
                      _this.coders = coders;
                      return _this;
                    }
                    CoderTuple2.prototype.encode = function(value) {
                      return pack(this.coders, value);
                    };
                    CoderTuple2.prototype.decode = function(data, offset) {
                      var result = unpack(this.coders, data, offset);
                      result.value = this.coerceFunc(this.type, result.value);
                      return result;
                    };
                    return CoderTuple2;
                  }(Coder)
                );
                function splitNesting(value) {
                  value = value.trim();
                  var result = [];
                  var accum = "";
                  var depth = 0;
                  for (var offset = 0; offset < value.length; offset++) {
                    var c = value[offset];
                    if (c === "," && depth === 0) {
                      result.push(accum);
                      accum = "";
                    } else {
                      accum += c;
                      if (c === "(") {
                        depth++;
                      } else if (c === ")") {
                        depth--;
                        if (depth === -1) {
                          throw new Error("unbalanced parenthsis");
                        }
                      }
                    }
                  }
                  if (accum) {
                    result.push(accum);
                  }
                  return result;
                }
                var paramTypeSimple = {
                  address: CoderAddress,
                  bool: CoderBoolean,
                  string: CoderString,
                  bytes: CoderDynamicBytes
                };
                function getTupleParamCoder(coerceFunc, components, localName) {
                  if (!components) {
                    components = [];
                  }
                  var coders = [];
                  components.forEach(function(component) {
                    coders.push(getParamCoder(coerceFunc, component));
                  });
                  return new CoderTuple(coerceFunc, coders, localName);
                }
                function getParamCoder(coerceFunc, param) {
                  var coder = paramTypeSimple[param.type];
                  if (coder) {
                    return new coder(coerceFunc, param.name);
                  }
                  var match = param.type.match(paramTypeNumber);
                  if (match) {
                    var size = parseInt(match[2] || "256");
                    if (size === 0 || size > 256 || size % 8 !== 0) {
                      errors.throwError("invalid " + match[1] + " bit length", errors.INVALID_ARGUMENT, {
                        arg: "param",
                        value: param
                      });
                    }
                    return new CoderNumber(coerceFunc, size / 8, match[1] === "int", param.name);
                  }
                  var match = param.type.match(paramTypeBytes);
                  if (match) {
                    var size = parseInt(match[1]);
                    if (size === 0 || size > 32) {
                      errors.throwError("invalid bytes length", errors.INVALID_ARGUMENT, {
                        arg: "param",
                        value: param
                      });
                    }
                    return new CoderFixedBytes(coerceFunc, size, param.name);
                  }
                  var match = param.type.match(paramTypeArray);
                  if (match) {
                    var size = parseInt(match[2] || "-1");
                    param = properties_1.shallowCopy(param);
                    param.type = match[1];
                    param = properties_1.deepCopy(param);
                    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);
                  }
                  if (param.type.substring(0, 5) === "tuple") {
                    return getTupleParamCoder(coerceFunc, param.components, param.name);
                  }
                  if (param.type === "") {
                    return new CoderNull(coerceFunc, param.name);
                  }
                  errors.throwError("invalid type", errors.INVALID_ARGUMENT, {
                    arg: "type",
                    value: param.type
                  });
                  return null;
                }
                var AbiCoder = (
                  /** @class */
                  function() {
                    function AbiCoder2(coerceFunc) {
                      errors.checkNew(this, AbiCoder2);
                      if (!coerceFunc) {
                        coerceFunc = exports2.defaultCoerceFunc;
                      }
                      properties_1.defineReadOnly(this, "coerceFunc", coerceFunc);
                    }
                    AbiCoder2.prototype.encode = function(types, values) {
                      if (types.length !== values.length) {
                        errors.throwError("types/values length mismatch", errors.INVALID_ARGUMENT, {
                          count: { types: types.length, values: values.length },
                          value: { types, values }
                        });
                      }
                      var coders = [];
                      types.forEach(function(type) {
                        var typeObject = null;
                        if (typeof type === "string") {
                          typeObject = parseParam(type);
                        } else {
                          typeObject = type;
                        }
                        coders.push(getParamCoder(this.coerceFunc, typeObject));
                      }, this);
                      return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, "_").encode(values));
                    };
                    AbiCoder2.prototype.decode = function(types, data) {
                      var coders = [];
                      types.forEach(function(type) {
                        var typeObject = null;
                        if (typeof type === "string") {
                          typeObject = parseParam(type);
                        } else {
                          typeObject = properties_1.deepCopy(type);
                        }
                        coders.push(getParamCoder(this.coerceFunc, typeObject));
                      }, this);
                      return new CoderTuple(this.coerceFunc, coders, "_").decode(bytes_1.arrayify(data), 0).value;
                    };
                    return AbiCoder2;
                  }()
                );
                exports2.AbiCoder = AbiCoder;
                exports2.defaultAbiCoder = new AbiCoder();
              }
            ),
            /***/
            5638: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var __importDefault = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : { "default": mod };
                };
                Object.defineProperty(exports2, "__esModule", { value: true });
                var bn_js_1 = __importDefault(__webpack_require__2(5697));
                var bytes_1 = __webpack_require__2(8458);
                var keccak256_1 = __webpack_require__2(918);
                var rlp_1 = __webpack_require__2(6100);
                var errors = __webpack_require__2(6459);
                function getChecksumAddress(address) {
                  if (typeof address !== "string" || !address.match(/^0x[0-9A-Fa-f]{40}$/)) {
                    errors.throwError("invalid address", errors.INVALID_ARGUMENT, { arg: "address", value: address });
                  }
                  address = address.toLowerCase();
                  var chars = address.substring(2).split("");
                  var hashed = new Uint8Array(40);
                  for (var i_1 = 0; i_1 < 40; i_1++) {
                    hashed[i_1] = chars[i_1].charCodeAt(0);
                  }
                  hashed = bytes_1.arrayify(keccak256_1.keccak256(hashed));
                  for (var i2 = 0; i2 < 40; i2 += 2) {
                    if (hashed[i2 >> 1] >> 4 >= 8) {
                      chars[i2] = chars[i2].toUpperCase();
                    }
                    if ((hashed[i2 >> 1] & 15) >= 8) {
                      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
                    }
                  }
                  return "0x" + chars.join("");
                }
                var MAX_SAFE_INTEGER = 9007199254740991;
                function log10(x) {
                  if (Math.log10) {
                    return Math.log10(x);
                  }
                  return Math.log(x) / Math.LN10;
                }
                var ibanLookup = {};
                for (var i = 0; i < 10; i++) {
                  ibanLookup[String(i)] = String(i);
                }
                for (var i = 0; i < 26; i++) {
                  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
                }
                var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
                function ibanChecksum(address) {
                  address = address.toUpperCase();
                  address = address.substring(4) + address.substring(0, 2) + "00";
                  var expanded = "";
                  address.split("").forEach(function(c) {
                    expanded += ibanLookup[c];
                  });
                  while (expanded.length >= safeDigits) {
                    var block = expanded.substring(0, safeDigits);
                    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
                  }
                  var checksum = String(98 - parseInt(expanded, 10) % 97);
                  while (checksum.length < 2) {
                    checksum = "0" + checksum;
                  }
                  return checksum;
                }
                ;
                function getAddress(address, checksum) {
                  if (checksum === void 0) {
                    checksum = true;
                  }
                  var result = null;
                  if (typeof address !== "string") {
                    errors.throwError("invalid address", errors.INVALID_ARGUMENT, { arg: "address", value: address });
                  }
                  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
                    if (address.substring(0, 2) !== "0x") {
                      address = "0x" + address;
                    }
                    if (checksum) {
                      result = getChecksumAddress(address);
                      if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
                        errors.throwError("bad address checksum", errors.INVALID_ARGUMENT, { arg: "address", value: address });
                      }
                    } else {
                      result = address;
                    }
                  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
                    if (address.substring(2, 4) !== ibanChecksum(address)) {
                      errors.throwError("bad icap checksum", errors.INVALID_ARGUMENT, { arg: "address", value: address });
                    }
                    result = new bn_js_1.default.BN(address.substring(4), 36).toString(16);
                    while (result.length < 40) {
                      result = "0" + result;
                    }
                    result = checksum ? getChecksumAddress("0x" + result) : "0x" + result;
                  } else {
                    errors.throwError("invalid address", errors.INVALID_ARGUMENT, { arg: "address", value: address });
                  }
                  return result;
                }
                exports2.getAddress = getAddress;
                function getIcapAddress(address) {
                  var base36 = new bn_js_1.default.BN(getAddress(address).substring(2), 16).toString(36).toUpperCase();
                  while (base36.length < 30) {
                    base36 = "0" + base36;
                  }
                  return "XE" + ibanChecksum("XE00" + base36) + base36;
                }
                exports2.getIcapAddress = getIcapAddress;
                function getContractAddress(transaction) {
                  if (!transaction.from) {
                    throw new Error("missing from address");
                  }
                  var nonce = transaction.nonce;
                  return getAddress("0x" + keccak256_1.keccak256(rlp_1.encode([
                    getAddress(transaction.from),
                    bytes_1.stripZeros(bytes_1.hexlify(nonce))
                  ])).substring(26));
                }
                exports2.getContractAddress = getContractAddress;
              }
            ),
            /***/
            4759: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var __importDefault = this && this.__importDefault || function(mod) {
                  return mod && mod.__esModule ? mod : { "default": mod };
                };
                var __importStar = this && this.__importStar || function(mod) {
                  if (mod && mod.__esModule)
                    return mod;
                  var result = {};
                  if (mod != null) {
                    for (var k in mod)
                      if (Object.hasOwnProperty.call(mod, k))
                        result[k] = mod[k];
                  }
                  result["default"] = mod;
                  return result;
                };
                Object.defineProperty(exports2, "__esModule", { value: true });
                var bn_js_1 = __importDefault(__webpack_require__2(5697));
                var bytes_1 = __webpack_require__2(8458);
                var properties_1 = __webpack_require__2(8184);
                var errors = __importStar(__webpack_require__2(6459));
                var BN_1 = new bn_js_1.default.BN(-1);
                function toHex(bn) {
                  var value = bn.toString(16);
                  if (value[0] === "-") {
                    if (value.length % 2 === 0) {
                      return "-0x0" + value.substring(1);
                    }
                    return "-0x" + value.substring(1);
                  }
                  if (value.length % 2 === 1) {
                    return "0x0" + value;
                  }
                  return "0x" + value;
                }
                function toBN(value) {
                  return _bnify(bigNumberify(value));
                }
                function toBigNumber(bn) {
                  return new BigNumber(toHex(bn));
                }
                function _bnify(value) {
                  var hex = value._hex;
                  if (hex[0] === "-") {
                    return new bn_js_1.default.BN(hex.substring(3), 16).mul(BN_1);
                  }
                  return new bn_js_1.default.BN(hex.substring(2), 16);
                }
                var BigNumber = (
                  /** @class */
                  function() {
                    function BigNumber2(value) {
                      errors.checkNew(this, BigNumber2);
                      properties_1.setType(this, "BigNumber");
                      if (typeof value === "string") {
                        if (bytes_1.isHexString(value)) {
                          if (value == "0x") {
                            value = "0x0";
                          }
                          properties_1.defineReadOnly(this, "_hex", value);
                        } else if (value[0] === "-" && bytes_1.isHexString(value.substring(1))) {
                          properties_1.defineReadOnly(this, "_hex", value);
                        } else if (value.match(/^-?[0-9]*$/)) {
                          if (value == "") {
                            value = "0";
                          }
                          properties_1.defineReadOnly(this, "_hex", toHex(new bn_js_1.default.BN(value)));
                        } else {
                          errors.throwError("invalid BigNumber string value", errors.INVALID_ARGUMENT, { arg: "value", value });
                        }
                      } else if (typeof value === "number") {
                        if (parseInt(String(value)) !== value) {
                          errors.throwError("underflow", errors.NUMERIC_FAULT, { operation: "setValue", fault: "underflow", value, outputValue: parseInt(String(value)) });
                        }
                        try {
                          properties_1.defineReadOnly(this, "_hex", toHex(new bn_js_1.default.BN(value)));
                        } catch (error) {
                          errors.throwError("overflow", errors.NUMERIC_FAULT, { operation: "setValue", fault: "overflow", details: error.message });
                        }
                      } else if (value instanceof BigNumber2) {
                        properties_1.defineReadOnly(this, "_hex", value._hex);
                      } else if (value.toHexString) {
                        properties_1.defineReadOnly(this, "_hex", toHex(toBN(value.toHexString())));
                      } else if (value._hex && bytes_1.isHexString(value._hex)) {
                        properties_1.defineReadOnly(this, "_hex", value._hex);
                      } else if (bytes_1.isArrayish(value)) {
                        properties_1.defineReadOnly(this, "_hex", toHex(new bn_js_1.default.BN(bytes_1.hexlify(value).substring(2), 16)));
                      } else {
                        errors.throwError("invalid BigNumber value", errors.INVALID_ARGUMENT, { arg: "value", value });
                      }
                    }
                    BigNumber2.prototype.fromTwos = function(value) {
                      return toBigNumber(_bnify(this).fromTwos(value));
                    };
                    BigNumber2.prototype.toTwos = function(value) {
                      return toBigNumber(_bnify(this).toTwos(value));
                    };
                    BigNumber2.prototype.abs = function() {
                      if (this._hex[0] === "-") {
                        return toBigNumber(_bnify(this).mul(BN_1));
                      }
                      return this;
                    };
                    BigNumber2.prototype.add = function(other) {
                      return toBigNumber(_bnify(this).add(toBN(other)));
                    };
                    BigNumber2.prototype.sub = function(other) {
                      return toBigNumber(_bnify(this).sub(toBN(other)));
                    };
                    BigNumber2.prototype.div = function(other) {
                      var o = bigNumberify(other);
                      if (o.isZero()) {
                        errors.throwError("division by zero", errors.NUMERIC_FAULT, { operation: "divide", fault: "division by zero" });
                      }
                      return toBigNumber(_bnify(this).div(toBN(other)));
                    };
                    BigNumber2.prototype.mul = function(other) {
                      return toBigNumber(_bnify(this).mul(toBN(other)));
                    };
                    BigNumber2.prototype.mod = function(other) {
                      return toBigNumber(_bnify(this).mod(toBN(other)));
                    };
                    BigNumber2.prototype.pow = function(other) {
                      return toBigNumber(_bnify(this).pow(toBN(other)));
                    };
                    BigNumber2.prototype.maskn = function(value) {
                      return toBigNumber(_bnify(this).maskn(value));
                    };
                    BigNumber2.prototype.eq = function(other) {
                      return _bnify(this).eq(toBN(other));
                    };
                    BigNumber2.prototype.lt = function(other) {
                      return _bnify(this).lt(toBN(other));
                    };
                    BigNumber2.prototype.lte = function(other) {
                      return _bnify(this).lte(toBN(other));
                    };
                    BigNumber2.prototype.gt = function(other) {
                      return _bnify(this).gt(toBN(other));
                    };
                    BigNumber2.prototype.gte = function(other) {
                      return _bnify(this).gte(toBN(other));
                    };
                    BigNumber2.prototype.isZero = function() {
                      return _bnify(this).isZero();
                    };
                    BigNumber2.prototype.toNumber = function() {
                      try {
                        return _bnify(this).toNumber();
                      } catch (error) {
                        errors.throwError("overflow", errors.NUMERIC_FAULT, { operation: "setValue", fault: "overflow", details: error.message });
                      }
                      return null;
                    };
                    BigNumber2.prototype.toString = function() {
                      return _bnify(this).toString(10);
                    };
                    BigNumber2.prototype.toHexString = function() {
                      return this._hex;
                    };
                    BigNumber2.isBigNumber = function(value) {
                      return properties_1.isType(value, "BigNumber");
                    };
                    return BigNumber2;
                  }()
                );
                exports2.BigNumber = BigNumber;
                function bigNumberify(value) {
                  if (BigNumber.isBigNumber(value)) {
                    return value;
                  }
                  return new BigNumber(value);
                }
                exports2.bigNumberify = bigNumberify;
              }
            ),
            /***/
            8458: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var __importStar = this && this.__importStar || function(mod) {
                  if (mod && mod.__esModule)
                    return mod;
                  var result = {};
                  if (mod != null) {
                    for (var k in mod)
                      if (Object.hasOwnProperty.call(mod, k))
                        result[k] = mod[k];
                  }
                  result["default"] = mod;
                  return result;
                };
                Object.defineProperty(exports2, "__esModule", { value: true });
                var errors = __importStar(__webpack_require__2(6459));
                function isHexable(value) {
                  return !!value.toHexString;
                }
                exports2.isHexable = isHexable;
                function addSlice(array) {
                  if (array.slice) {
                    return array;
                  }
                  array.slice = function() {
                    var args = Array.prototype.slice.call(arguments);
                    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
                  };
                  return array;
                }
                function isArrayish(value) {
                  if (!value || parseInt(String(value.length)) != value.length || typeof value === "string") {
                    return false;
                  }
                  for (var i = 0; i < value.length; i++) {
                    var v = value[i];
                    if (v < 0 || v >= 256 || parseInt(String(v)) != v) {
                      return false;
                    }
                  }
                  return true;
                }
                exports2.isArrayish = isArrayish;
                function arrayify(value) {
                  if (value == null) {
                    errors.throwError("cannot convert null value to array", errors.INVALID_ARGUMENT, { arg: "value", value });
                  }
                  if (isHexable(value)) {
                    value = value.toHexString();
                  }
                  if (typeof value === "string") {
                    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);
                    if (!match) {
                      errors.throwError("invalid hexidecimal string", errors.INVALID_ARGUMENT, { arg: "value", value });
                    }
                    if (match[1] !== "0x") {
                      errors.throwError("hex string must have 0x prefix", errors.INVALID_ARGUMENT, { arg: "value", value });
                    }
                    value = value.substring(2);
                    if (value.length % 2) {
                      value = "0" + value;
                    }
                    var result = [];
                    for (var i = 0; i < value.length; i += 2) {
                      result.push(parseInt(value.substr(i, 2), 16));
                    }
                    return addSlice(new Uint8Array(result));
                  }
                  if (isArrayish(value)) {
                    return addSlice(new Uint8Array(value));
                  }
                  errors.throwError("invalid arrayify value", null, { arg: "value", value, type: typeof value });
                  return null;
                }
                exports2.arrayify = arrayify;
                function concat(objects) {
                  var arrays = [];
                  var length = 0;
                  for (var i = 0; i < objects.length; i++) {
                    var object = arrayify(objects[i]);
                    arrays.push(object);
                    length += object.length;
                  }
                  var result = new Uint8Array(length);
                  var offset = 0;
                  for (var i = 0; i < arrays.length; i++) {
                    result.set(arrays[i], offset);
                    offset += arrays[i].length;
                  }
                  return addSlice(result);
                }
                exports2.concat = concat;
                function stripZeros(value) {
                  var result = arrayify(value);
                  if (result.length === 0) {
                    return result;
                  }
                  var start = 0;
                  while (result[start] === 0) {
                    start++;
                  }
                  if (start) {
                    result = result.slice(start);
                  }
                  return result;
                }
                exports2.stripZeros = stripZeros;
                function padZeros(value, length) {
                  value = arrayify(value);
                  if (length < value.length) {
                    throw new Error("cannot pad");
                  }
                  var result = new Uint8Array(length);
                  result.set(value, length - value.length);
                  return addSlice(result);
                }
                exports2.padZeros = padZeros;
                function isHexString(value, length) {
                  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
                    return false;
                  }
                  if (length && value.length !== 2 + 2 * length) {
                    return false;
                  }
                  return true;
                }
                exports2.isHexString = isHexString;
                var HexCharacters = "0123456789abcdef";
                function hexlify(value) {
                  if (isHexable(value)) {
                    return value.toHexString();
                  }
                  if (typeof value === "number") {
                    if (value < 0) {
                      errors.throwError("cannot hexlify negative value", errors.INVALID_ARGUMENT, { arg: "value", value });
                    }
                    if (value >= 9007199254740991) {
                      errors.throwError("out-of-range", errors.NUMERIC_FAULT, {
                        operartion: "hexlify",
                        fault: "out-of-safe-range"
                      });
                    }
                    var hex = "";
                    while (value) {
                      hex = HexCharacters[value & 15] + hex;
                      value = Math.floor(value / 16);
                    }
                    if (hex.length) {
                      if (hex.length % 2) {
                        hex = "0" + hex;
                      }
                      return "0x" + hex;
                    }
                    return "0x00";
                  }
                  if (typeof value === "string") {
                    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);
                    if (!match) {
                      errors.throwError("invalid hexidecimal string", errors.INVALID_ARGUMENT, { arg: "value", value });
                    }
                    if (match[1] !== "0x") {
                      errors.throwError("hex string must have 0x prefix", errors.INVALID_ARGUMENT, { arg: "value", value });
                    }
                    if (value.length % 2) {
                      value = "0x0" + value.substring(2);
                    }
                    return value;
                  }
                  if (isArrayish(value)) {
                    var result = [];
                    for (var i = 0; i < value.length; i++) {
                      var v = value[i];
                      result.push(HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15]);
                    }
                    return "0x" + result.join("");
                  }
                  errors.throwError("invalid hexlify value", null, { arg: "value", value });
                  return "never";
                }
                exports2.hexlify = hexlify;
                function hexDataLength(data) {
                  if (!isHexString(data) || data.length % 2 !== 0) {
                    return null;
                  }
                  return (data.length - 2) / 2;
                }
                exports2.hexDataLength = hexDataLength;
                function hexDataSlice(data, offset, endOffset) {
                  if (!isHexString(data)) {
                    errors.throwError("invalid hex data", errors.INVALID_ARGUMENT, { arg: "value", value: data });
                  }
                  if (data.length % 2 !== 0) {
                    errors.throwError("hex data length must be even", errors.INVALID_ARGUMENT, { arg: "value", value: data });
                  }
                  offset = 2 + 2 * offset;
                  if (endOffset != null) {
                    return "0x" + data.substring(offset, 2 + 2 * endOffset);
                  }
                  return "0x" + data.substring(offset);
                }
                exports2.hexDataSlice = hexDataSlice;
                function hexStripZeros(value) {
                  if (!isHexString(value)) {
                    errors.throwError("invalid hex string", errors.INVALID_ARGUMENT, { arg: "value", value });
                  }
                  while (value.length > 3 && value.substring(0, 3) === "0x0") {
                    value = "0x" + value.substring(3);
                  }
                  return value;
                }
                exports2.hexStripZeros = hexStripZeros;
                function hexZeroPad(value, length) {
                  if (!isHexString(value)) {
                    errors.throwError("invalid hex string", errors.INVALID_ARGUMENT, { arg: "value", value });
                  }
                  while (value.length < 2 * length + 2) {
                    value = "0x0" + value.substring(2);
                  }
                  return value;
                }
                exports2.hexZeroPad = hexZeroPad;
                function isSignature(value) {
                  return value && value.r != null && value.s != null;
                }
                function splitSignature(signature) {
                  var v = 0;
                  var r = "0x", s = "0x";
                  if (isSignature(signature)) {
                    if (signature.v == null && signature.recoveryParam == null) {
                      errors.throwError("at least on of recoveryParam or v must be specified", errors.INVALID_ARGUMENT, { argument: "signature", value: signature });
                    }
                    r = hexZeroPad(signature.r, 32);
                    s = hexZeroPad(signature.s, 32);
                    v = signature.v;
                    if (typeof v === "string") {
                      v = parseInt(v, 16);
                    }
                    var recoveryParam = signature.recoveryParam;
                    if (recoveryParam == null && signature.v != null) {
                      recoveryParam = 1 - v % 2;
                    }
                    v = 27 + recoveryParam;
                  } else {
                    var bytes = arrayify(signature);
                    if (bytes.length !== 65) {
                      throw new Error("invalid signature");
                    }
                    r = hexlify(bytes.slice(0, 32));
                    s = hexlify(bytes.slice(32, 64));
                    v = bytes[64];
                    if (v !== 27 && v !== 28) {
                      v = 27 + v % 2;
                    }
                  }
                  return {
                    r,
                    s,
                    recoveryParam: v - 27,
                    v
                  };
                }
                exports2.splitSignature = splitSignature;
                function joinSignature(signature) {
                  signature = splitSignature(signature);
                  return hexlify(concat([
                    signature.r,
                    signature.s,
                    signature.recoveryParam ? "0x1c" : "0x1b"
                  ]));
                }
                exports2.joinSignature = joinSignature;
              }
            ),
            /***/
            918: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                var sha3 = __webpack_require__2(747);
                var bytes_1 = __webpack_require__2(8458);
                function keccak256(data) {
                  return "0x" + sha3.keccak_256(bytes_1.arrayify(data));
                }
                exports2.keccak256 = keccak256;
              }
            ),
            /***/
            8184: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var __importStar = this && this.__importStar || function(mod) {
                  if (mod && mod.__esModule)
                    return mod;
                  var result = {};
                  if (mod != null) {
                    for (var k in mod)
                      if (Object.hasOwnProperty.call(mod, k))
                        result[k] = mod[k];
                  }
                  result["default"] = mod;
                  return result;
                };
                Object.defineProperty(exports2, "__esModule", { value: true });
                var errors = __importStar(__webpack_require__2(6459));
                function defineReadOnly(object, name2, value) {
                  Object.defineProperty(object, name2, {
                    enumerable: true,
                    value,
                    writable: false
                  });
                }
                exports2.defineReadOnly = defineReadOnly;
                function setType(object, type) {
                  Object.defineProperty(object, "_ethersType", { configurable: false, value: type, writable: false });
                }
                exports2.setType = setType;
                function isType(object, type) {
                  return object && object._ethersType === type;
                }
                exports2.isType = isType;
                function resolveProperties(object) {
                  var result = {};
                  var promises = [];
                  Object.keys(object).forEach(function(key) {
                    var value = object[key];
                    if (value instanceof Promise) {
                      promises.push(value.then(function(value2) {
                        result[key] = value2;
                        return null;
                      }));
                    } else {
                      result[key] = value;
                    }
                  });
                  return Promise.all(promises).then(function() {
                    return result;
                  });
                }
                exports2.resolveProperties = resolveProperties;
                function checkProperties(object, properties) {
                  if (!object || typeof object !== "object") {
                    errors.throwError("invalid object", errors.INVALID_ARGUMENT, {
                      argument: "object",
                      value: object
                    });
                  }
                  Object.keys(object).forEach(function(key) {
                    if (!properties[key]) {
                      errors.throwError("invalid object key - " + key, errors.INVALID_ARGUMENT, {
                        argument: "transaction",
                        value: object,
                        key
                      });
                    }
                  });
                }
                exports2.checkProperties = checkProperties;
                function shallowCopy(object) {
                  var result = {};
                  for (var key in object) {
                    result[key] = object[key];
                  }
                  return result;
                }
                exports2.shallowCopy = shallowCopy;
                var opaque = { boolean: true, number: true, string: true };
                function deepCopy(object, frozen) {
                  if (object === void 0 || object === null || opaque[typeof object]) {
                    return object;
                  }
                  if (Array.isArray(object)) {
                    var result = object.map(function(item) {
                      return deepCopy(item, frozen);
                    });
                    if (frozen) {
                      Object.freeze(result);
                    }
                    return result;
                  }
                  if (typeof object === "object") {
                    if (isType(object, "BigNumber")) {
                      return object;
                    }
                    if (isType(object, "Description")) {
                      return object;
                    }
                    if (isType(object, "Indexed")) {
                      return object;
                    }
                    var result = {};
                    for (var key in object) {
                      var value = object[key];
                      if (value === void 0) {
                        continue;
                      }
                      defineReadOnly(result, key, deepCopy(value, frozen));
                    }
                    if (frozen) {
                      Object.freeze(result);
                    }
                    return result;
                  }
                  if (typeof object === "function") {
                    return object;
                  }
                  throw new Error("Cannot deepCopy " + typeof object);
                }
                exports2.deepCopy = deepCopy;
                function inherits(ctor, superCtor) {
                  ctor.super_ = superCtor;
                  ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                      value: ctor,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                }
                function inheritable(parent) {
                  return function(child) {
                    inherits(child, parent);
                    defineReadOnly(child, "inherits", inheritable(child));
                  };
                }
                exports2.inheritable = inheritable;
              }
            ),
            /***/
            6100: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                var bytes_1 = __webpack_require__2(8458);
                function arrayifyInteger(value) {
                  var result = [];
                  while (value) {
                    result.unshift(value & 255);
                    value >>= 8;
                  }
                  return result;
                }
                function unarrayifyInteger(data, offset, length) {
                  var result = 0;
                  for (var i = 0; i < length; i++) {
                    result = result * 256 + data[offset + i];
                  }
                  return result;
                }
                function _encode(object) {
                  if (Array.isArray(object)) {
                    var payload = [];
                    object.forEach(function(child) {
                      payload = payload.concat(_encode(child));
                    });
                    if (payload.length <= 55) {
                      payload.unshift(192 + payload.length);
                      return payload;
                    }
                    var length = arrayifyInteger(payload.length);
                    length.unshift(247 + length.length);
                    return length.concat(payload);
                  }
                  var data = Array.prototype.slice.call(bytes_1.arrayify(object));
                  if (data.length === 1 && data[0] <= 127) {
                    return data;
                  } else if (data.length <= 55) {
                    data.unshift(128 + data.length);
                    return data;
                  }
                  var length = arrayifyInteger(data.length);
                  length.unshift(183 + length.length);
                  return length.concat(data);
                }
                function encode(object) {
                  return bytes_1.hexlify(_encode(object));
                }
                exports2.encode = encode;
                function _decodeChildren(data, offset, childOffset, length) {
                  var result = [];
                  while (childOffset < offset + 1 + length) {
                    var decoded = _decode(data, childOffset);
                    result.push(decoded.result);
                    childOffset += decoded.consumed;
                    if (childOffset > offset + 1 + length) {
                      throw new Error("invalid rlp");
                    }
                  }
                  return { consumed: 1 + length, result };
                }
                function _decode(data, offset) {
                  if (data.length === 0) {
                    throw new Error("invalid rlp data");
                  }
                  if (data[offset] >= 248) {
                    var lengthLength = data[offset] - 247;
                    if (offset + 1 + lengthLength > data.length) {
                      throw new Error("too short");
                    }
                    var length = unarrayifyInteger(data, offset + 1, lengthLength);
                    if (offset + 1 + lengthLength + length > data.length) {
                      throw new Error("to short");
                    }
                    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
                  } else if (data[offset] >= 192) {
                    var length = data[offset] - 192;
                    if (offset + 1 + length > data.length) {
                      throw new Error("invalid rlp data");
                    }
                    return _decodeChildren(data, offset, offset + 1, length);
                  } else if (data[offset] >= 184) {
                    var lengthLength = data[offset] - 183;
                    if (offset + 1 + lengthLength > data.length) {
                      throw new Error("invalid rlp data");
                    }
                    var length = unarrayifyInteger(data, offset + 1, lengthLength);
                    if (offset + 1 + lengthLength + length > data.length) {
                      throw new Error("invalid rlp data");
                    }
                    var result = bytes_1.hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
                    return { consumed: 1 + lengthLength + length, result };
                  } else if (data[offset] >= 128) {
                    var length = data[offset] - 128;
                    if (offset + 1 + length > data.length) {
                      throw new Error("invlaid rlp data");
                    }
                    var result = bytes_1.hexlify(data.slice(offset + 1, offset + 1 + length));
                    return { consumed: 1 + length, result };
                  }
                  return { consumed: 1, result: bytes_1.hexlify(data[offset]) };
                }
                function decode(data) {
                  var bytes = bytes_1.arrayify(data);
                  var decoded = _decode(bytes, 0);
                  if (decoded.consumed !== bytes.length) {
                    throw new Error("invalid rlp data");
                  }
                  return decoded.result;
                }
                exports2.decode = decode;
              }
            ),
            /***/
            1165: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                var constants_1 = __webpack_require__2(8707);
                var errors_1 = __webpack_require__2(6459);
                var bytes_1 = __webpack_require__2(8458);
                var UnicodeNormalizationForm;
                (function(UnicodeNormalizationForm2) {
                  UnicodeNormalizationForm2["current"] = "";
                  UnicodeNormalizationForm2["NFC"] = "NFC";
                  UnicodeNormalizationForm2["NFD"] = "NFD";
                  UnicodeNormalizationForm2["NFKC"] = "NFKC";
                  UnicodeNormalizationForm2["NFKD"] = "NFKD";
                })(UnicodeNormalizationForm = exports2.UnicodeNormalizationForm || (exports2.UnicodeNormalizationForm = {}));
                ;
                function toUtf8Bytes(str, form) {
                  if (form === void 0) {
                    form = UnicodeNormalizationForm.current;
                  }
                  if (form != UnicodeNormalizationForm.current) {
                    errors_1.checkNormalize();
                    str = str.normalize(form);
                  }
                  var result = [];
                  for (var i = 0; i < str.length; i++) {
                    var c = str.charCodeAt(i);
                    if (c < 128) {
                      result.push(c);
                    } else if (c < 2048) {
                      result.push(c >> 6 | 192);
                      result.push(c & 63 | 128);
                    } else if ((c & 64512) == 55296) {
                      i++;
                      var c2 = str.charCodeAt(i);
                      if (i >= str.length || (c2 & 64512) !== 56320) {
                        throw new Error("invalid utf-8 string");
                      }
                      c = 65536 + ((c & 1023) << 10) + (c2 & 1023);
                      result.push(c >> 18 | 240);
                      result.push(c >> 12 & 63 | 128);
                      result.push(c >> 6 & 63 | 128);
                      result.push(c & 63 | 128);
                    } else {
                      result.push(c >> 12 | 224);
                      result.push(c >> 6 & 63 | 128);
                      result.push(c & 63 | 128);
                    }
                  }
                  return bytes_1.arrayify(result);
                }
                exports2.toUtf8Bytes = toUtf8Bytes;
                ;
                function toUtf8String(bytes, ignoreErrors) {
                  bytes = bytes_1.arrayify(bytes);
                  var result = "";
                  var i = 0;
                  while (i < bytes.length) {
                    var c = bytes[i++];
                    if (c >> 7 === 0) {
                      result += String.fromCharCode(c);
                      continue;
                    }
                    var extraLength = null;
                    var overlongMask = null;
                    if ((c & 224) === 192) {
                      extraLength = 1;
                      overlongMask = 127;
                    } else if ((c & 240) === 224) {
                      extraLength = 2;
                      overlongMask = 2047;
                    } else if ((c & 248) === 240) {
                      extraLength = 3;
                      overlongMask = 65535;
                    } else {
                      if (!ignoreErrors) {
                        if ((c & 192) === 128) {
                          throw new Error("invalid utf8 byte sequence; unexpected continuation byte");
                        }
                        throw new Error("invalid utf8 byte sequence; invalid prefix");
                      }
                      continue;
                    }
                    if (i + extraLength > bytes.length) {
                      if (!ignoreErrors) {
                        throw new Error("invalid utf8 byte sequence; too short");
                      }
                      for (; i < bytes.length; i++) {
                        if (bytes[i] >> 6 !== 2) {
                          break;
                        }
                      }
                      continue;
                    }
                    var res = c & (1 << 8 - extraLength - 1) - 1;
                    for (var j = 0; j < extraLength; j++) {
                      var nextChar = bytes[i];
                      if ((nextChar & 192) != 128) {
                        res = null;
                        break;
                      }
                      ;
                      res = res << 6 | nextChar & 63;
                      i++;
                    }
                    if (res === null) {
                      if (!ignoreErrors) {
                        throw new Error("invalid utf8 byte sequence; invalid continuation byte");
                      }
                      continue;
                    }
                    if (res <= overlongMask) {
                      if (!ignoreErrors) {
                        throw new Error("invalid utf8 byte sequence; overlong");
                      }
                      continue;
                    }
                    if (res > 1114111) {
                      if (!ignoreErrors) {
                        throw new Error("invalid utf8 byte sequence; out-of-range");
                      }
                      continue;
                    }
                    if (res >= 55296 && res <= 57343) {
                      if (!ignoreErrors) {
                        throw new Error("invalid utf8 byte sequence; utf-16 surrogate");
                      }
                      continue;
                    }
                    if (res <= 65535) {
                      result += String.fromCharCode(res);
                      continue;
                    }
                    res -= 65536;
                    result += String.fromCharCode((res >> 10 & 1023) + 55296, (res & 1023) + 56320);
                  }
                  return result;
                }
                exports2.toUtf8String = toUtf8String;
                function formatBytes32String(text) {
                  var bytes = toUtf8Bytes(text);
                  if (bytes.length > 31) {
                    throw new Error("bytes32 string must be less than 32 bytes");
                  }
                  return bytes_1.hexlify(bytes_1.concat([bytes, constants_1.HashZero]).slice(0, 32));
                }
                exports2.formatBytes32String = formatBytes32String;
                function parseBytes32String(bytes) {
                  var data = bytes_1.arrayify(bytes);
                  if (data.length !== 32) {
                    throw new Error("invalid bytes32 - not 32 bytes long");
                  }
                  if (data[31] !== 0) {
                    throw new Error("invalid bytes32 sdtring - no null terminator");
                  }
                  var length = 31;
                  while (data[length - 1] === 0) {
                    length--;
                  }
                  return toUtf8String(data.slice(0, length));
                }
                exports2.parseBytes32String = parseBytes32String;
              }
            ),
            /***/
            634: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                ;
                (function(globalObject) {
                  "use strict";
                  var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
                  function clone(configObject) {
                    var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
                      decimalSeparator: ".",
                      groupSeparator: ",",
                      groupSize: 3,
                      secondaryGroupSize: 0,
                      fractionGroupSeparator: "",
                      // non-breaking space
                      fractionGroupSize: 0
                    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
                    function BigNumber2(n, b) {
                      var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
                      if (!(x instanceof BigNumber2)) {
                        return new BigNumber2(n, b);
                      }
                      if (b == null) {
                        if (n instanceof BigNumber2) {
                          x.s = n.s;
                          x.e = n.e;
                          x.c = (n = n.c) ? n.slice() : n;
                          return;
                        }
                        isNum = typeof n == "number";
                        if (isNum && n * 0 == 0) {
                          x.s = 1 / n < 0 ? (n = -n, -1) : 1;
                          if (n === ~~n) {
                            for (e = 0, i = n; i >= 10; i /= 10, e++)
                              ;
                            x.e = e;
                            x.c = [n];
                            return;
                          }
                          str = n + "";
                        } else {
                          if (!isNumeric.test(str = n + ""))
                            return parseNumeric(x, str, isNum);
                          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                        }
                        if ((e = str.indexOf(".")) > -1)
                          str = str.replace(".", "");
                        if ((i = str.search(/e/i)) > 0) {
                          if (e < 0)
                            e = i;
                          e += +str.slice(i + 1);
                          str = str.substring(0, i);
                        } else if (e < 0) {
                          e = str.length;
                        }
                      } else {
                        intCheck(b, 2, ALPHABET.length, "Base");
                        str = n + "";
                        if (b == 10) {
                          x = new BigNumber2(n instanceof BigNumber2 ? n : str);
                          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                        }
                        isNum = typeof n == "number";
                        if (isNum) {
                          if (n * 0 != 0)
                            return parseNumeric(x, str, isNum, b);
                          x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;
                          if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                            throw Error(tooManyDigits + n);
                          }
                          isNum = false;
                        } else {
                          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                        }
                        alphabet = ALPHABET.slice(0, b);
                        e = i = 0;
                        for (len = str.length; i < len; i++) {
                          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                            if (c == ".") {
                              if (i > e) {
                                e = len;
                                continue;
                              }
                            } else if (!caseChanged) {
                              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                                caseChanged = true;
                                i = -1;
                                e = 0;
                                continue;
                              }
                            }
                            return parseNumeric(x, n + "", isNum, b);
                          }
                        }
                        str = convertBase(str, b, 10, x.s);
                        if ((e = str.indexOf(".")) > -1)
                          str = str.replace(".", "");
                        else
                          e = str.length;
                      }
                      for (i = 0; str.charCodeAt(i) === 48; i++)
                        ;
                      for (len = str.length; str.charCodeAt(--len) === 48; )
                        ;
                      str = str.slice(i, ++len);
                      if (str) {
                        len -= i;
                        if (isNum && BigNumber2.DEBUG && len > 15 && (n > MAX_SAFE_INTEGER || n !== mathfloor(n))) {
                          throw Error(tooManyDigits + x.s * n);
                        }
                        e = e - i - 1;
                        if (e > MAX_EXP) {
                          x.c = x.e = null;
                        } else if (e < MIN_EXP) {
                          x.c = [x.e = 0];
                        } else {
                          x.e = e;
                          x.c = [];
                          i = (e + 1) % LOG_BASE;
                          if (e < 0)
                            i += LOG_BASE;
                          if (i < len) {
                            if (i)
                              x.c.push(+str.slice(0, i));
                            for (len -= LOG_BASE; i < len; ) {
                              x.c.push(+str.slice(i, i += LOG_BASE));
                            }
                            str = str.slice(i);
                            i = LOG_BASE - str.length;
                          } else {
                            i -= len;
                          }
                          for (; i--; str += "0")
                            ;
                          x.c.push(+str);
                        }
                      } else {
                        x.c = [x.e = 0];
                      }
                    }
                    BigNumber2.clone = clone;
                    BigNumber2.ROUND_UP = 0;
                    BigNumber2.ROUND_DOWN = 1;
                    BigNumber2.ROUND_CEIL = 2;
                    BigNumber2.ROUND_FLOOR = 3;
                    BigNumber2.ROUND_HALF_UP = 4;
                    BigNumber2.ROUND_HALF_DOWN = 5;
                    BigNumber2.ROUND_HALF_EVEN = 6;
                    BigNumber2.ROUND_HALF_CEIL = 7;
                    BigNumber2.ROUND_HALF_FLOOR = 8;
                    BigNumber2.EUCLID = 9;
                    BigNumber2.config = BigNumber2.set = function(obj) {
                      var p, v;
                      if (obj != null) {
                        if (typeof obj == "object") {
                          if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                            v = obj[p];
                            intCheck(v, 0, MAX, p);
                            DECIMAL_PLACES = v;
                          }
                          if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                            v = obj[p];
                            intCheck(v, 0, 8, p);
                            ROUNDING_MODE = v;
                          }
                          if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                            v = obj[p];
                            if (isArray(v)) {
                              intCheck(v[0], -MAX, 0, p);
                              intCheck(v[1], 0, MAX, p);
                              TO_EXP_NEG = v[0];
                              TO_EXP_POS = v[1];
                            } else {
                              intCheck(v, -MAX, MAX, p);
                              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                            }
                          }
                          if (obj.hasOwnProperty(p = "RANGE")) {
                            v = obj[p];
                            if (isArray(v)) {
                              intCheck(v[0], -MAX, -1, p);
                              intCheck(v[1], 1, MAX, p);
                              MIN_EXP = v[0];
                              MAX_EXP = v[1];
                            } else {
                              intCheck(v, -MAX, MAX, p);
                              if (v) {
                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                              } else {
                                throw Error(bignumberError + p + " cannot be zero: " + v);
                              }
                            }
                          }
                          if (obj.hasOwnProperty(p = "CRYPTO")) {
                            v = obj[p];
                            if (v === !!v) {
                              if (v) {
                                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                                  CRYPTO = v;
                                } else {
                                  CRYPTO = !v;
                                  throw Error(bignumberError + "crypto unavailable");
                                }
                              } else {
                                CRYPTO = v;
                              }
                            } else {
                              throw Error(bignumberError + p + " not true or false: " + v);
                            }
                          }
                          if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                            v = obj[p];
                            intCheck(v, 0, 9, p);
                            MODULO_MODE = v;
                          }
                          if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                            v = obj[p];
                            intCheck(v, 0, MAX, p);
                            POW_PRECISION = v;
                          }
                          if (obj.hasOwnProperty(p = "FORMAT")) {
                            v = obj[p];
                            if (typeof v == "object")
                              FORMAT = v;
                            else
                              throw Error(bignumberError + p + " not an object: " + v);
                          }
                          if (obj.hasOwnProperty(p = "ALPHABET")) {
                            v = obj[p];
                            if (typeof v == "string" && !/^.$|\.|(.).*\1/.test(v)) {
                              ALPHABET = v;
                            } else {
                              throw Error(bignumberError + p + " invalid: " + v);
                            }
                          }
                        } else {
                          throw Error(bignumberError + "Object expected: " + obj);
                        }
                      }
                      return {
                        DECIMAL_PLACES,
                        ROUNDING_MODE,
                        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
                        RANGE: [MIN_EXP, MAX_EXP],
                        CRYPTO,
                        MODULO_MODE,
                        POW_PRECISION,
                        FORMAT,
                        ALPHABET
                      };
                    };
                    BigNumber2.isBigNumber = function(v) {
                      return v instanceof BigNumber2 || v && v._isBigNumber === true || false;
                    };
                    BigNumber2.maximum = BigNumber2.max = function() {
                      return maxOrMin(arguments, P.lt);
                    };
                    BigNumber2.minimum = BigNumber2.min = function() {
                      return maxOrMin(arguments, P.gt);
                    };
                    BigNumber2.random = function() {
                      var pow2_53 = 9007199254740992;
                      var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
                        return mathfloor(Math.random() * pow2_53);
                      } : function() {
                        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
                      };
                      return function(dp) {
                        var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
                        if (dp == null)
                          dp = DECIMAL_PLACES;
                        else
                          intCheck(dp, 0, MAX);
                        k = mathceil(dp / LOG_BASE);
                        if (CRYPTO) {
                          if (crypto.getRandomValues) {
                            a = crypto.getRandomValues(new Uint32Array(k *= 2));
                            for (; i < k; ) {
                              v = a[i] * 131072 + (a[i + 1] >>> 11);
                              if (v >= 9e15) {
                                b = crypto.getRandomValues(new Uint32Array(2));
                                a[i] = b[0];
                                a[i + 1] = b[1];
                              } else {
                                c.push(v % 1e14);
                                i += 2;
                              }
                            }
                            i = k / 2;
                          } else if (crypto.randomBytes) {
                            a = crypto.randomBytes(k *= 7);
                            for (; i < k; ) {
                              v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                              if (v >= 9e15) {
                                crypto.randomBytes(7).copy(a, i);
                              } else {
                                c.push(v % 1e14);
                                i += 7;
                              }
                            }
                            i = k / 7;
                          } else {
                            CRYPTO = false;
                            throw Error(bignumberError + "crypto unavailable");
                          }
                        }
                        if (!CRYPTO) {
                          for (; i < k; ) {
                            v = random53bitInt();
                            if (v < 9e15)
                              c[i++] = v % 1e14;
                          }
                        }
                        k = c[--i];
                        dp %= LOG_BASE;
                        if (k && dp) {
                          v = POWS_TEN[LOG_BASE - dp];
                          c[i] = mathfloor(k / v) * v;
                        }
                        for (; c[i] === 0; c.pop(), i--)
                          ;
                        if (i < 0) {
                          c = [e = 0];
                        } else {
                          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                            ;
                          for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                            ;
                          if (i < LOG_BASE)
                            e -= LOG_BASE - i;
                        }
                        rand.e = e;
                        rand.c = c;
                        return rand;
                      };
                    }();
                    convertBase = /* @__PURE__ */ function() {
                      var decimal = "0123456789";
                      function toBaseOut(str, baseIn, baseOut, alphabet) {
                        var j, arr = [0], arrL, i = 0, len = str.length;
                        for (; i < len; ) {
                          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                            ;
                          arr[0] += alphabet.indexOf(str.charAt(i++));
                          for (j = 0; j < arr.length; j++) {
                            if (arr[j] > baseOut - 1) {
                              if (arr[j + 1] == null)
                                arr[j + 1] = 0;
                              arr[j + 1] += arr[j] / baseOut | 0;
                              arr[j] %= baseOut;
                            }
                          }
                        }
                        return arr.reverse();
                      }
                      return function(str, baseIn, baseOut, sign, callerIsToString) {
                        var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
                        if (i >= 0) {
                          k = POW_PRECISION;
                          POW_PRECISION = 0;
                          str = str.replace(".", "");
                          y = new BigNumber2(baseIn);
                          x = y.pow(str.length - i);
                          POW_PRECISION = k;
                          y.c = toBaseOut(
                            toFixedPoint(coeffToString(x.c), x.e, "0"),
                            10,
                            baseOut,
                            decimal
                          );
                          y.e = y.c.length;
                        }
                        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
                        e = k = xc.length;
                        for (; xc[--k] == 0; xc.pop())
                          ;
                        if (!xc[0])
                          return alphabet.charAt(0);
                        if (i < 0) {
                          --e;
                        } else {
                          x.c = xc;
                          x.e = e;
                          x.s = sign;
                          x = div(x, y, dp, rm, baseOut);
                          xc = x.c;
                          r = x.r;
                          e = x.e;
                        }
                        d = e + dp + 1;
                        i = xc[d];
                        k = baseOut / 2;
                        r = r || d < 0 || xc[d + 1] != null;
                        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
                        if (d < 1 || !xc[0]) {
                          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                        } else {
                          xc.length = d;
                          if (r) {
                            for (--baseOut; ++xc[--d] > baseOut; ) {
                              xc[d] = 0;
                              if (!d) {
                                ++e;
                                xc = [1].concat(xc);
                              }
                            }
                          }
                          for (k = xc.length; !xc[--k]; )
                            ;
                          for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                            ;
                          str = toFixedPoint(str, e, alphabet.charAt(0));
                        }
                        return str;
                      };
                    }();
                    div = /* @__PURE__ */ function() {
                      function multiply(x, k, base) {
                        var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
                        for (x = x.slice(); i--; ) {
                          xlo = x[i] % SQRT_BASE;
                          xhi = x[i] / SQRT_BASE | 0;
                          m = khi * xlo + xhi * klo;
                          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                          x[i] = temp % base;
                        }
                        if (carry)
                          x = [carry].concat(x);
                        return x;
                      }
                      function compare2(a, b, aL, bL) {
                        var i, cmp;
                        if (aL != bL) {
                          cmp = aL > bL ? 1 : -1;
                        } else {
                          for (i = cmp = 0; i < aL; i++) {
                            if (a[i] != b[i]) {
                              cmp = a[i] > b[i] ? 1 : -1;
                              break;
                            }
                          }
                        }
                        return cmp;
                      }
                      function subtract(a, b, aL, base) {
                        var i = 0;
                        for (; aL--; ) {
                          a[aL] -= i;
                          i = a[aL] < b[aL] ? 1 : 0;
                          a[aL] = i * base + a[aL] - b[aL];
                        }
                        for (; !a[0] && a.length > 1; a.splice(0, 1))
                          ;
                      }
                      return function(x, y, dp, rm, base) {
                        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
                        if (!xc || !xc[0] || !yc || !yc[0]) {
                          return new BigNumber2(
                            // Return NaN if either NaN, or both Infinity or 0.
                            !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                              // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                              xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                            )
                          );
                        }
                        q = new BigNumber2(s);
                        qc = q.c = [];
                        e = x.e - y.e;
                        s = dp + e + 1;
                        if (!base) {
                          base = BASE;
                          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                          s = s / LOG_BASE | 0;
                        }
                        for (i = 0; yc[i] == (xc[i] || 0); i++)
                          ;
                        if (yc[i] > (xc[i] || 0))
                          e--;
                        if (s < 0) {
                          qc.push(1);
                          more = true;
                        } else {
                          xL = xc.length;
                          yL = yc.length;
                          i = 0;
                          s += 2;
                          n = mathfloor(base / (yc[0] + 1));
                          if (n > 1) {
                            yc = multiply(yc, n, base);
                            xc = multiply(xc, n, base);
                            yL = yc.length;
                            xL = xc.length;
                          }
                          xi = yL;
                          rem = xc.slice(0, yL);
                          remL = rem.length;
                          for (; remL < yL; rem[remL++] = 0)
                            ;
                          yz = yc.slice();
                          yz = [0].concat(yz);
                          yc0 = yc[0];
                          if (yc[1] >= base / 2)
                            yc0++;
                          do {
                            n = 0;
                            cmp = compare2(yc, rem, yL, remL);
                            if (cmp < 0) {
                              rem0 = rem[0];
                              if (yL != remL)
                                rem0 = rem0 * base + (rem[1] || 0);
                              n = mathfloor(rem0 / yc0);
                              if (n > 1) {
                                if (n >= base)
                                  n = base - 1;
                                prod = multiply(yc, n, base);
                                prodL = prod.length;
                                remL = rem.length;
                                while (compare2(prod, rem, prodL, remL) == 1) {
                                  n--;
                                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                  prodL = prod.length;
                                  cmp = 1;
                                }
                              } else {
                                if (n == 0) {
                                  cmp = n = 1;
                                }
                                prod = yc.slice();
                                prodL = prod.length;
                              }
                              if (prodL < remL)
                                prod = [0].concat(prod);
                              subtract(rem, prod, remL, base);
                              remL = rem.length;
                              if (cmp == -1) {
                                while (compare2(yc, rem, yL, remL) < 1) {
                                  n++;
                                  subtract(rem, yL < remL ? yz : yc, remL, base);
                                  remL = rem.length;
                                }
                              }
                            } else if (cmp === 0) {
                              n++;
                              rem = [0];
                            }
                            qc[i++] = n;
                            if (rem[0]) {
                              rem[remL++] = xc[xi] || 0;
                            } else {
                              rem = [xc[xi]];
                              remL = 1;
                            }
                          } while ((xi++ < xL || rem[0] != null) && s--);
                          more = rem[0] != null;
                          if (!qc[0])
                            qc.splice(0, 1);
                        }
                        if (base == BASE) {
                          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                            ;
                          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
                        } else {
                          q.e = e;
                          q.r = +more;
                        }
                        return q;
                      };
                    }();
                    function format(n, i, rm, id) {
                      var c0, e, ne, len, str;
                      if (rm == null)
                        rm = ROUNDING_MODE;
                      else
                        intCheck(rm, 0, 8);
                      if (!n.c)
                        return n.toString();
                      c0 = n.c[0];
                      ne = n.e;
                      if (i == null) {
                        str = coeffToString(n.c);
                        str = id == 1 || id == 2 && ne <= TO_EXP_NEG ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
                      } else {
                        n = round(new BigNumber2(n), i, rm);
                        e = n.e;
                        str = coeffToString(n.c);
                        len = str.length;
                        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                          for (; len < i; str += "0", len++)
                            ;
                          str = toExponential(str, e);
                        } else {
                          i -= ne;
                          str = toFixedPoint(str, e, "0");
                          if (e + 1 > len) {
                            if (--i > 0)
                              for (str += "."; i--; str += "0")
                                ;
                          } else {
                            i += e - len;
                            if (i > 0) {
                              if (e + 1 == len)
                                str += ".";
                              for (; i--; str += "0")
                                ;
                            }
                          }
                        }
                      }
                      return n.s < 0 && c0 ? "-" + str : str;
                    }
                    function maxOrMin(args, method) {
                      var m, n, i = 0;
                      if (isArray(args[0]))
                        args = args[0];
                      m = new BigNumber2(args[0]);
                      for (; ++i < args.length; ) {
                        n = new BigNumber2(args[i]);
                        if (!n.s) {
                          m = n;
                          break;
                        } else if (method.call(m, n)) {
                          m = n;
                        }
                      }
                      return m;
                    }
                    function normalise(n, c, e) {
                      var i = 1, j = c.length;
                      for (; !c[--j]; c.pop())
                        ;
                      for (j = c[0]; j >= 10; j /= 10, i++)
                        ;
                      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
                        n.c = n.e = null;
                      } else if (e < MIN_EXP) {
                        n.c = [n.e = 0];
                      } else {
                        n.e = e;
                        n.c = c;
                      }
                      return n;
                    }
                    parseNumeric = /* @__PURE__ */ function() {
                      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
                      return function(x, str, isNum, b) {
                        var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
                        if (isInfinityOrNaN.test(s)) {
                          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                          x.c = x.e = null;
                        } else {
                          if (!isNum) {
                            s = s.replace(basePrefix, function(m, p1, p2) {
                              base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                              return !b || b == base ? p1 : m;
                            });
                            if (b) {
                              base = b;
                              s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                            }
                            if (str != s)
                              return new BigNumber2(s, base);
                          }
                          if (BigNumber2.DEBUG) {
                            throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
                          }
                          x.c = x.e = x.s = null;
                        }
                      };
                    }();
                    function round(x, sd, rm, r) {
                      var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
                      if (xc) {
                        out: {
                          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                            ;
                          i = sd - d;
                          if (i < 0) {
                            i += LOG_BASE;
                            j = sd;
                            n = xc[ni = 0];
                            rd = n / pows10[d - j - 1] % 10 | 0;
                          } else {
                            ni = mathceil((i + 1) / LOG_BASE);
                            if (ni >= xc.length) {
                              if (r) {
                                for (; xc.length <= ni; xc.push(0))
                                  ;
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                              } else {
                                break out;
                              }
                            } else {
                              n = k = xc[ni];
                              for (d = 1; k >= 10; k /= 10, d++)
                                ;
                              i %= LOG_BASE;
                              j = i - LOG_BASE + d;
                              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                            }
                          }
                          r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                          if (sd < 1 || !xc[0]) {
                            xc.length = 0;
                            if (r) {
                              sd -= x.e + 1;
                              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                              x.e = -sd || 0;
                            } else {
                              xc[0] = x.e = 0;
                            }
                            return x;
                          }
                          if (i == 0) {
                            xc.length = ni;
                            k = 1;
                            ni--;
                          } else {
                            xc.length = ni + 1;
                            k = pows10[LOG_BASE - i];
                            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                          }
                          if (r) {
                            for (; ; ) {
                              if (ni == 0) {
                                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                                  ;
                                j = xc[0] += k;
                                for (k = 1; j >= 10; j /= 10, k++)
                                  ;
                                if (i != k) {
                                  x.e++;
                                  if (xc[0] == BASE)
                                    xc[0] = 1;
                                }
                                break;
                              } else {
                                xc[ni] += k;
                                if (xc[ni] != BASE)
                                  break;
                                xc[ni--] = 0;
                                k = 1;
                              }
                            }
                          }
                          for (i = xc.length; xc[--i] === 0; xc.pop())
                            ;
                        }
                        if (x.e > MAX_EXP) {
                          x.c = x.e = null;
                        } else if (x.e < MIN_EXP) {
                          x.c = [x.e = 0];
                        }
                      }
                      return x;
                    }
                    P.absoluteValue = P.abs = function() {
                      var x = new BigNumber2(this);
                      if (x.s < 0)
                        x.s = 1;
                      return x;
                    };
                    P.comparedTo = function(y, b) {
                      return compare(this, new BigNumber2(y, b));
                    };
                    P.decimalPlaces = P.dp = function(dp, rm) {
                      var c, n, v, x = this;
                      if (dp != null) {
                        intCheck(dp, 0, MAX);
                        if (rm == null)
                          rm = ROUNDING_MODE;
                        else
                          intCheck(rm, 0, 8);
                        return round(new BigNumber2(x), dp + x.e + 1, rm);
                      }
                      if (!(c = x.c))
                        return null;
                      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
                      if (v = c[v])
                        for (; v % 10 == 0; v /= 10, n--)
                          ;
                      if (n < 0)
                        n = 0;
                      return n;
                    };
                    P.dividedBy = P.div = function(y, b) {
                      return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
                    };
                    P.dividedToIntegerBy = P.idiv = function(y, b) {
                      return div(this, new BigNumber2(y, b), 0, 1);
                    };
                    P.exponentiatedBy = P.pow = function(n, m) {
                      var half, isModExp, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
                      n = new BigNumber2(n);
                      if (n.c && !n.isInteger()) {
                        throw Error(bignumberError + "Exponent not an integer: " + n);
                      }
                      if (m != null)
                        m = new BigNumber2(m);
                      nIsBig = n.e > 14;
                      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
                        y = new BigNumber2(Math.pow(+x.valueOf(), nIsBig ? 2 - isOdd(n) : +n));
                        return m ? y.mod(m) : y;
                      }
                      nIsNeg = n.s < 0;
                      if (m) {
                        if (m.c ? !m.c[0] : !m.s)
                          return new BigNumber2(NaN);
                        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
                        if (isModExp)
                          x = x.mod(m);
                      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
                        k = x.s < 0 && isOdd(n) ? -0 : 0;
                        if (x.e > -1)
                          k = 1 / k;
                        return new BigNumber2(nIsNeg ? 1 / k : k);
                      } else if (POW_PRECISION) {
                        k = mathceil(POW_PRECISION / LOG_BASE + 2);
                      }
                      if (nIsBig) {
                        half = new BigNumber2(0.5);
                        nIsOdd = isOdd(n);
                      } else {
                        nIsOdd = n % 2;
                      }
                      if (nIsNeg)
                        n.s = 1;
                      y = new BigNumber2(ONE);
                      for (; ; ) {
                        if (nIsOdd) {
                          y = y.times(x);
                          if (!y.c)
                            break;
                          if (k) {
                            if (y.c.length > k)
                              y.c.length = k;
                          } else if (isModExp) {
                            y = y.mod(m);
                          }
                        }
                        if (nIsBig) {
                          n = n.times(half);
                          round(n, n.e + 1, 1);
                          if (!n.c[0])
                            break;
                          nIsBig = n.e > 14;
                          nIsOdd = isOdd(n);
                        } else {
                          n = mathfloor(n / 2);
                          if (!n)
                            break;
                          nIsOdd = n % 2;
                        }
                        x = x.times(x);
                        if (k) {
                          if (x.c && x.c.length > k)
                            x.c.length = k;
                        } else if (isModExp) {
                          x = x.mod(m);
                        }
                      }
                      if (isModExp)
                        return y;
                      if (nIsNeg)
                        y = ONE.div(y);
                      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
                    };
                    P.integerValue = function(rm) {
                      var n = new BigNumber2(this);
                      if (rm == null)
                        rm = ROUNDING_MODE;
                      else
                        intCheck(rm, 0, 8);
                      return round(n, n.e + 1, rm);
                    };
                    P.isEqualTo = P.eq = function(y, b) {
                      return compare(this, new BigNumber2(y, b)) === 0;
                    };
                    P.isFinite = function() {
                      return !!this.c;
                    };
                    P.isGreaterThan = P.gt = function(y, b) {
                      return compare(this, new BigNumber2(y, b)) > 0;
                    };
                    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
                      return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
                    };
                    P.isInteger = function() {
                      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
                    };
                    P.isLessThan = P.lt = function(y, b) {
                      return compare(this, new BigNumber2(y, b)) < 0;
                    };
                    P.isLessThanOrEqualTo = P.lte = function(y, b) {
                      return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
                    };
                    P.isNaN = function() {
                      return !this.s;
                    };
                    P.isNegative = function() {
                      return this.s < 0;
                    };
                    P.isPositive = function() {
                      return this.s > 0;
                    };
                    P.isZero = function() {
                      return !!this.c && this.c[0] == 0;
                    };
                    P.minus = function(y, b) {
                      var i, j, t, xLTy, x = this, a = x.s;
                      y = new BigNumber2(y, b);
                      b = y.s;
                      if (!a || !b)
                        return new BigNumber2(NaN);
                      if (a != b) {
                        y.s = -b;
                        return x.plus(y);
                      }
                      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                      if (!xe || !ye) {
                        if (!xc || !yc)
                          return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
                        if (!xc[0] || !yc[0]) {
                          return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                            // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                            ROUNDING_MODE == 3 ? -0 : 0
                          ));
                        }
                      }
                      xe = bitFloor(xe);
                      ye = bitFloor(ye);
                      xc = xc.slice();
                      if (a = xe - ye) {
                        if (xLTy = a < 0) {
                          a = -a;
                          t = xc;
                        } else {
                          ye = xe;
                          t = yc;
                        }
                        t.reverse();
                        for (b = a; b--; t.push(0))
                          ;
                        t.reverse();
                      } else {
                        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
                        for (a = b = 0; b < j; b++) {
                          if (xc[b] != yc[b]) {
                            xLTy = xc[b] < yc[b];
                            break;
                          }
                        }
                      }
                      if (xLTy)
                        t = xc, xc = yc, yc = t, y.s = -y.s;
                      b = (j = yc.length) - (i = xc.length);
                      if (b > 0)
                        for (; b--; xc[i++] = 0)
                          ;
                      b = BASE - 1;
                      for (; j > a; ) {
                        if (xc[--j] < yc[j]) {
                          for (i = j; i && !xc[--i]; xc[i] = b)
                            ;
                          --xc[i];
                          xc[j] += BASE;
                        }
                        xc[j] -= yc[j];
                      }
                      for (; xc[0] == 0; xc.splice(0, 1), --ye)
                        ;
                      if (!xc[0]) {
                        y.s = ROUNDING_MODE == 3 ? -1 : 1;
                        y.c = [y.e = 0];
                        return y;
                      }
                      return normalise(y, xc, ye);
                    };
                    P.modulo = P.mod = function(y, b) {
                      var q, s, x = this;
                      y = new BigNumber2(y, b);
                      if (!x.c || !y.s || y.c && !y.c[0]) {
                        return new BigNumber2(NaN);
                      } else if (!y.c || x.c && !x.c[0]) {
                        return new BigNumber2(x);
                      }
                      if (MODULO_MODE == 9) {
                        s = y.s;
                        y.s = 1;
                        q = div(x, y, 0, 3);
                        y.s = s;
                        q.s *= s;
                      } else {
                        q = div(x, y, 0, MODULO_MODE);
                      }
                      y = x.minus(q.times(y));
                      if (!y.c[0] && MODULO_MODE == 1)
                        y.s = x.s;
                      return y;
                    };
                    P.multipliedBy = P.times = function(y, b) {
                      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
                      if (!xc || !yc || !xc[0] || !yc[0]) {
                        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                          y.c = y.e = y.s = null;
                        } else {
                          y.s *= x.s;
                          if (!xc || !yc) {
                            y.c = y.e = null;
                          } else {
                            y.c = [0];
                            y.e = 0;
                          }
                        }
                        return y;
                      }
                      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
                      y.s *= x.s;
                      xcL = xc.length;
                      ycL = yc.length;
                      if (xcL < ycL)
                        zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
                      for (i = xcL + ycL, zc = []; i--; zc.push(0))
                        ;
                      base = BASE;
                      sqrtBase = SQRT_BASE;
                      for (i = ycL; --i >= 0; ) {
                        c = 0;
                        ylo = yc[i] % sqrtBase;
                        yhi = yc[i] / sqrtBase | 0;
                        for (k = xcL, j = i + k; j > i; ) {
                          xlo = xc[--k] % sqrtBase;
                          xhi = xc[k] / sqrtBase | 0;
                          m = yhi * xlo + xhi * ylo;
                          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                          zc[j--] = xlo % base;
                        }
                        zc[j] = c;
                      }
                      if (c) {
                        ++e;
                      } else {
                        zc.splice(0, 1);
                      }
                      return normalise(y, zc, e);
                    };
                    P.negated = function() {
                      var x = new BigNumber2(this);
                      x.s = -x.s || null;
                      return x;
                    };
                    P.plus = function(y, b) {
                      var t, x = this, a = x.s;
                      y = new BigNumber2(y, b);
                      b = y.s;
                      if (!a || !b)
                        return new BigNumber2(NaN);
                      if (a != b) {
                        y.s = -b;
                        return x.minus(y);
                      }
                      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
                      if (!xe || !ye) {
                        if (!xc || !yc)
                          return new BigNumber2(a / 0);
                        if (!xc[0] || !yc[0])
                          return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
                      }
                      xe = bitFloor(xe);
                      ye = bitFloor(ye);
                      xc = xc.slice();
                      if (a = xe - ye) {
                        if (a > 0) {
                          ye = xe;
                          t = yc;
                        } else {
                          a = -a;
                          t = xc;
                        }
                        t.reverse();
                        for (; a--; t.push(0))
                          ;
                        t.reverse();
                      }
                      a = xc.length;
                      b = yc.length;
                      if (a - b < 0)
                        t = yc, yc = xc, xc = t, b = a;
                      for (a = 0; b; ) {
                        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
                      }
                      if (a) {
                        xc = [a].concat(xc);
                        ++ye;
                      }
                      return normalise(y, xc, ye);
                    };
                    P.precision = P.sd = function(sd, rm) {
                      var c, n, v, x = this;
                      if (sd != null && sd !== !!sd) {
                        intCheck(sd, 1, MAX);
                        if (rm == null)
                          rm = ROUNDING_MODE;
                        else
                          intCheck(rm, 0, 8);
                        return round(new BigNumber2(x), sd, rm);
                      }
                      if (!(c = x.c))
                        return null;
                      v = c.length - 1;
                      n = v * LOG_BASE + 1;
                      if (v = c[v]) {
                        for (; v % 10 == 0; v /= 10, n--)
                          ;
                        for (v = c[0]; v >= 10; v /= 10, n++)
                          ;
                      }
                      if (sd && x.e + 1 > n)
                        n = x.e + 1;
                      return n;
                    };
                    P.shiftedBy = function(k) {
                      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
                      return this.times("1e" + k);
                    };
                    P.squareRoot = P.sqrt = function() {
                      var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
                      if (s !== 1 || !c || !c[0]) {
                        return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                      }
                      s = Math.sqrt(+x);
                      if (s == 0 || s == 1 / 0) {
                        n = coeffToString(c);
                        if ((n.length + e) % 2 == 0)
                          n += "0";
                        s = Math.sqrt(n);
                        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
                        if (s == 1 / 0) {
                          n = "1e" + e;
                        } else {
                          n = s.toExponential();
                          n = n.slice(0, n.indexOf("e") + 1) + e;
                        }
                        r = new BigNumber2(n);
                      } else {
                        r = new BigNumber2(s + "");
                      }
                      if (r.c[0]) {
                        e = r.e;
                        s = e + dp;
                        if (s < 3)
                          s = 0;
                        for (; ; ) {
                          t = r;
                          r = half.times(t.plus(div(x, t, dp, 1)));
                          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                            if (r.e < e)
                              --s;
                            n = n.slice(s - 3, s + 1);
                            if (n == "9999" || !rep && n == "4999") {
                              if (!rep) {
                                round(t, t.e + DECIMAL_PLACES + 2, 0);
                                if (t.times(t).eq(x)) {
                                  r = t;
                                  break;
                                }
                              }
                              dp += 4;
                              s += 4;
                              rep = 1;
                            } else {
                              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                                round(r, r.e + DECIMAL_PLACES + 2, 1);
                                m = !r.times(r).eq(x);
                              }
                              break;
                            }
                          }
                        }
                      }
                      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
                    };
                    P.toExponential = function(dp, rm) {
                      if (dp != null) {
                        intCheck(dp, 0, MAX);
                        dp++;
                      }
                      return format(this, dp, rm, 1);
                    };
                    P.toFixed = function(dp, rm) {
                      if (dp != null) {
                        intCheck(dp, 0, MAX);
                        dp = dp + this.e + 1;
                      }
                      return format(this, dp, rm);
                    };
                    P.toFormat = function(dp, rm) {
                      var str = this.toFixed(dp, rm);
                      if (this.c) {
                        var i, arr = str.split("."), g1 = +FORMAT.groupSize, g2 = +FORMAT.secondaryGroupSize, groupSeparator = FORMAT.groupSeparator, intPart = arr[0], fractionPart = arr[1], isNeg = this.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
                        if (g2)
                          i = g1, g1 = g2, g2 = i, len -= i;
                        if (g1 > 0 && len > 0) {
                          i = len % g1 || g1;
                          intPart = intDigits.substr(0, i);
                          for (; i < len; i += g1) {
                            intPart += groupSeparator + intDigits.substr(i, g1);
                          }
                          if (g2 > 0)
                            intPart += groupSeparator + intDigits.slice(i);
                          if (isNeg)
                            intPart = "-" + intPart;
                        }
                        str = fractionPart ? intPart + FORMAT.decimalSeparator + ((g2 = +FORMAT.fractionGroupSize) ? fractionPart.replace(
                          new RegExp("\\d{" + g2 + "}\\B", "g"),
                          "$&" + FORMAT.fractionGroupSeparator
                        ) : fractionPart) : intPart;
                      }
                      return str;
                    };
                    P.toFraction = function(md) {
                      var arr, d, d0, d1, d2, e, exp, n, n0, n1, q, s, x = this, xc = x.c;
                      if (md != null) {
                        n = new BigNumber2(md);
                        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                          throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + md);
                        }
                      }
                      if (!xc)
                        return x.toString();
                      d = new BigNumber2(ONE);
                      n1 = d0 = new BigNumber2(ONE);
                      d1 = n0 = new BigNumber2(ONE);
                      s = coeffToString(xc);
                      e = d.e = s.length - x.e - 1;
                      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
                      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
                      exp = MAX_EXP;
                      MAX_EXP = 1 / 0;
                      n = new BigNumber2(s);
                      n0.c[0] = 0;
                      for (; ; ) {
                        q = div(n, d, 0, 1);
                        d2 = d0.plus(q.times(d1));
                        if (d2.comparedTo(md) == 1)
                          break;
                        d0 = d1;
                        d1 = d2;
                        n1 = n0.plus(q.times(d2 = n1));
                        n0 = d2;
                        d = n.minus(q.times(d2 = d));
                        n = d2;
                      }
                      d2 = div(md.minus(d0), d1, 0, 1);
                      n0 = n0.plus(d2.times(n1));
                      d0 = d0.plus(d2.times(d1));
                      n0.s = n1.s = x.s;
                      e *= 2;
                      arr = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
                        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
                      ) < 1 ? [n1.toString(), d1.toString()] : [n0.toString(), d0.toString()];
                      MAX_EXP = exp;
                      return arr;
                    };
                    P.toNumber = function() {
                      return +this;
                    };
                    P.toPrecision = function(sd, rm) {
                      if (sd != null)
                        intCheck(sd, 1, MAX);
                      return format(this, sd, rm, 2);
                    };
                    P.toString = function(b) {
                      var str, n = this, s = n.s, e = n.e;
                      if (e === null) {
                        if (s) {
                          str = "Infinity";
                          if (s < 0)
                            str = "-" + str;
                        } else {
                          str = "NaN";
                        }
                      } else {
                        str = coeffToString(n.c);
                        if (b == null) {
                          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
                        } else {
                          intCheck(b, 2, ALPHABET.length, "Base");
                          str = convertBase(toFixedPoint(str, e, "0"), 10, b, s, true);
                        }
                        if (s < 0 && n.c[0])
                          str = "-" + str;
                      }
                      return str;
                    };
                    P.valueOf = P.toJSON = function() {
                      var str, n = this, e = n.e;
                      if (e === null)
                        return n.toString();
                      str = coeffToString(n.c);
                      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
                      return n.s < 0 ? "-" + str : str;
                    };
                    P._isBigNumber = true;
                    if (configObject != null)
                      BigNumber2.set(configObject);
                    return BigNumber2;
                  }
                  function bitFloor(n) {
                    var i = n | 0;
                    return n > 0 || n === i ? i : i - 1;
                  }
                  function coeffToString(a) {
                    var s, z, i = 1, j = a.length, r = a[0] + "";
                    for (; i < j; ) {
                      s = a[i++] + "";
                      z = LOG_BASE - s.length;
                      for (; z--; s = "0" + s)
                        ;
                      r += s;
                    }
                    for (j = r.length; r.charCodeAt(--j) === 48; )
                      ;
                    return r.slice(0, j + 1 || 1);
                  }
                  function compare(x, y) {
                    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
                    if (!i || !j)
                      return null;
                    a = xc && !xc[0];
                    b = yc && !yc[0];
                    if (a || b)
                      return a ? b ? 0 : -j : i;
                    if (i != j)
                      return i;
                    a = i < 0;
                    b = k == l;
                    if (!xc || !yc)
                      return b ? 0 : !xc ^ a ? 1 : -1;
                    if (!b)
                      return k > l ^ a ? 1 : -1;
                    j = (k = xc.length) < (l = yc.length) ? k : l;
                    for (i = 0; i < j; i++)
                      if (xc[i] != yc[i])
                        return xc[i] > yc[i] ^ a ? 1 : -1;
                    return k == l ? 0 : k > l ^ a ? 1 : -1;
                  }
                  function intCheck(n, min, max, name2) {
                    if (n < min || n > max || n !== (n < 0 ? mathceil(n) : mathfloor(n))) {
                      throw Error(bignumberError + (name2 || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + n);
                    }
                  }
                  function isArray(obj) {
                    return Object.prototype.toString.call(obj) == "[object Array]";
                  }
                  function isOdd(n) {
                    var k = n.c.length - 1;
                    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
                  }
                  function toExponential(str, e) {
                    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
                  }
                  function toFixedPoint(str, e, z) {
                    var len, zs;
                    if (e < 0) {
                      for (zs = z + "."; ++e; zs += z)
                        ;
                      str = zs + str;
                    } else {
                      len = str.length;
                      if (++e > len) {
                        for (zs = z, e -= len; --e; zs += z)
                          ;
                        str += zs;
                      } else if (e < len) {
                        str = str.slice(0, e) + "." + str.slice(e);
                      }
                    }
                    return str;
                  }
                  BigNumber = clone();
                  BigNumber["default"] = BigNumber.BigNumber = BigNumber;
                  if (true) {
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                      return BigNumber;
                    }).call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                  } else {
                  }
                })(this);
              }
            ),
            /***/
            5697: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                module2 = __webpack_require__2.nmd(module2);
                (function(module3, exports2) {
                  "use strict";
                  function assert(val, msg) {
                    if (!val)
                      throw new Error(msg || "Assertion failed");
                  }
                  function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {
                    };
                    TempCtor.prototype = superCtor.prototype;
                    ctor.prototype = new TempCtor();
                    ctor.prototype.constructor = ctor;
                  }
                  function BN(number, base, endian) {
                    if (BN.isBN(number)) {
                      return number;
                    }
                    this.negative = 0;
                    this.words = null;
                    this.length = 0;
                    this.red = null;
                    if (number !== null) {
                      if (base === "le" || base === "be") {
                        endian = base;
                        base = 10;
                      }
                      this._init(number || 0, base || 10, endian || "be");
                    }
                  }
                  if (typeof module3 === "object") {
                    module3.exports = BN;
                  } else {
                    exports2.BN = BN;
                  }
                  BN.BN = BN;
                  BN.wordSize = 26;
                  var Buffer;
                  try {
                    if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
                      Buffer = window.Buffer;
                    } else {
                      Buffer = __webpack_require__2(2574).Buffer;
                    }
                  } catch (e) {
                  }
                  BN.isBN = function isBN(num) {
                    if (num instanceof BN) {
                      return true;
                    }
                    return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
                  };
                  BN.max = function max(left, right) {
                    if (left.cmp(right) > 0)
                      return left;
                    return right;
                  };
                  BN.min = function min(left, right) {
                    if (left.cmp(right) < 0)
                      return left;
                    return right;
                  };
                  BN.prototype._init = function init(number, base, endian) {
                    if (typeof number === "number") {
                      return this._initNumber(number, base, endian);
                    }
                    if (typeof number === "object") {
                      return this._initArray(number, base, endian);
                    }
                    if (base === "hex") {
                      base = 16;
                    }
                    assert(base === (base | 0) && base >= 2 && base <= 36);
                    number = number.toString().replace(/\s+/g, "");
                    var start = 0;
                    if (number[0] === "-") {
                      start++;
                      this.negative = 1;
                    }
                    if (start < number.length) {
                      if (base === 16) {
                        this._parseHex(number, start, endian);
                      } else {
                        this._parseBase(number, base, start);
                        if (endian === "le") {
                          this._initArray(this.toArray(), base, endian);
                        }
                      }
                    }
                  };
                  BN.prototype._initNumber = function _initNumber(number, base, endian) {
                    if (number < 0) {
                      this.negative = 1;
                      number = -number;
                    }
                    if (number < 67108864) {
                      this.words = [number & 67108863];
                      this.length = 1;
                    } else if (number < 4503599627370496) {
                      this.words = [
                        number & 67108863,
                        number / 67108864 & 67108863
                      ];
                      this.length = 2;
                    } else {
                      assert(number < 9007199254740992);
                      this.words = [
                        number & 67108863,
                        number / 67108864 & 67108863,
                        1
                      ];
                      this.length = 3;
                    }
                    if (endian !== "le")
                      return;
                    this._initArray(this.toArray(), base, endian);
                  };
                  BN.prototype._initArray = function _initArray(number, base, endian) {
                    assert(typeof number.length === "number");
                    if (number.length <= 0) {
                      this.words = [0];
                      this.length = 1;
                      return this;
                    }
                    this.length = Math.ceil(number.length / 3);
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++) {
                      this.words[i] = 0;
                    }
                    var j, w;
                    var off = 0;
                    if (endian === "be") {
                      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
                        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                          off -= 26;
                          j++;
                        }
                      }
                    } else if (endian === "le") {
                      for (i = 0, j = 0; i < number.length; i += 3) {
                        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                          off -= 26;
                          j++;
                        }
                      }
                    }
                    return this.strip();
                  };
                  function parseHex4Bits(string, index) {
                    var c = string.charCodeAt(index);
                    if (c >= 65 && c <= 70) {
                      return c - 55;
                    } else if (c >= 97 && c <= 102) {
                      return c - 87;
                    } else {
                      return c - 48 & 15;
                    }
                  }
                  function parseHexByte(string, lowerBound, index) {
                    var r = parseHex4Bits(string, index);
                    if (index - 1 >= lowerBound) {
                      r |= parseHex4Bits(string, index - 1) << 4;
                    }
                    return r;
                  }
                  BN.prototype._parseHex = function _parseHex(number, start, endian) {
                    this.length = Math.ceil((number.length - start) / 6);
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++) {
                      this.words[i] = 0;
                    }
                    var off = 0;
                    var j = 0;
                    var w;
                    if (endian === "be") {
                      for (i = number.length - 1; i >= start; i -= 2) {
                        w = parseHexByte(number, start, i) << off;
                        this.words[j] |= w & 67108863;
                        if (off >= 18) {
                          off -= 18;
                          j += 1;
                          this.words[j] |= w >>> 26;
                        } else {
                          off += 8;
                        }
                      }
                    } else {
                      var parseLength = number.length - start;
                      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
                        w = parseHexByte(number, start, i) << off;
                        this.words[j] |= w & 67108863;
                        if (off >= 18) {
                          off -= 18;
                          j += 1;
                          this.words[j] |= w >>> 26;
                        } else {
                          off += 8;
                        }
                      }
                    }
                    this.strip();
                  };
                  function parseBase(str, start, end, mul) {
                    var r = 0;
                    var len = Math.min(str.length, end);
                    for (var i = start; i < len; i++) {
                      var c = str.charCodeAt(i) - 48;
                      r *= mul;
                      if (c >= 49) {
                        r += c - 49 + 10;
                      } else if (c >= 17) {
                        r += c - 17 + 10;
                      } else {
                        r += c;
                      }
                    }
                    return r;
                  }
                  BN.prototype._parseBase = function _parseBase(number, base, start) {
                    this.words = [0];
                    this.length = 1;
                    for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
                      limbLen++;
                    }
                    limbLen--;
                    limbPow = limbPow / base | 0;
                    var total = number.length - start;
                    var mod = total % limbLen;
                    var end = Math.min(total, total - mod) + start;
                    var word = 0;
                    for (var i = start; i < end; i += limbLen) {
                      word = parseBase(number, i, i + limbLen, base);
                      this.imuln(limbPow);
                      if (this.words[0] + word < 67108864) {
                        this.words[0] += word;
                      } else {
                        this._iaddn(word);
                      }
                    }
                    if (mod !== 0) {
                      var pow = 1;
                      word = parseBase(number, i, number.length, base);
                      for (i = 0; i < mod; i++) {
                        pow *= base;
                      }
                      this.imuln(pow);
                      if (this.words[0] + word < 67108864) {
                        this.words[0] += word;
                      } else {
                        this._iaddn(word);
                      }
                    }
                    this.strip();
                  };
                  BN.prototype.copy = function copy(dest) {
                    dest.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++) {
                      dest.words[i] = this.words[i];
                    }
                    dest.length = this.length;
                    dest.negative = this.negative;
                    dest.red = this.red;
                  };
                  BN.prototype.clone = function clone() {
                    var r = new BN(null);
                    this.copy(r);
                    return r;
                  };
                  BN.prototype._expand = function _expand(size) {
                    while (this.length < size) {
                      this.words[this.length++] = 0;
                    }
                    return this;
                  };
                  BN.prototype.strip = function strip() {
                    while (this.length > 1 && this.words[this.length - 1] === 0) {
                      this.length--;
                    }
                    return this._normSign();
                  };
                  BN.prototype._normSign = function _normSign() {
                    if (this.length === 1 && this.words[0] === 0) {
                      this.negative = 0;
                    }
                    return this;
                  };
                  BN.prototype.inspect = function inspect() {
                    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
                  };
                  var zeros = [
                    "",
                    "0",
                    "00",
                    "000",
                    "0000",
                    "00000",
                    "000000",
                    "0000000",
                    "00000000",
                    "000000000",
                    "0000000000",
                    "00000000000",
                    "000000000000",
                    "0000000000000",
                    "00000000000000",
                    "000000000000000",
                    "0000000000000000",
                    "00000000000000000",
                    "000000000000000000",
                    "0000000000000000000",
                    "00000000000000000000",
                    "000000000000000000000",
                    "0000000000000000000000",
                    "00000000000000000000000",
                    "000000000000000000000000",
                    "0000000000000000000000000"
                  ];
                  var groupSizes = [
                    0,
                    0,
                    25,
                    16,
                    12,
                    11,
                    10,
                    9,
                    8,
                    8,
                    7,
                    7,
                    7,
                    7,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    6,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5,
                    5
                  ];
                  var groupBases = [
                    0,
                    0,
                    33554432,
                    43046721,
                    16777216,
                    48828125,
                    60466176,
                    40353607,
                    16777216,
                    43046721,
                    1e7,
                    19487171,
                    35831808,
                    62748517,
                    7529536,
                    11390625,
                    16777216,
                    24137569,
                    34012224,
                    47045881,
                    64e6,
                    4084101,
                    5153632,
                    6436343,
                    7962624,
                    9765625,
                    11881376,
                    14348907,
                    17210368,
                    20511149,
                    243e5,
                    28629151,
                    33554432,
                    39135393,
                    45435424,
                    52521875,
                    60466176
                  ];
                  BN.prototype.toString = function toString(base, padding) {
                    base = base || 10;
                    padding = padding | 0 || 1;
                    var out;
                    if (base === 16 || base === "hex") {
                      out = "";
                      var off = 0;
                      var carry = 0;
                      for (var i = 0; i < this.length; i++) {
                        var w = this.words[i];
                        var word = ((w << off | carry) & 16777215).toString(16);
                        carry = w >>> 24 - off & 16777215;
                        if (carry !== 0 || i !== this.length - 1) {
                          out = zeros[6 - word.length] + word + out;
                        } else {
                          out = word + out;
                        }
                        off += 2;
                        if (off >= 26) {
                          off -= 26;
                          i--;
                        }
                      }
                      if (carry !== 0) {
                        out = carry.toString(16) + out;
                      }
                      while (out.length % padding !== 0) {
                        out = "0" + out;
                      }
                      if (this.negative !== 0) {
                        out = "-" + out;
                      }
                      return out;
                    }
                    if (base === (base | 0) && base >= 2 && base <= 36) {
                      var groupSize = groupSizes[base];
                      var groupBase = groupBases[base];
                      out = "";
                      var c = this.clone();
                      c.negative = 0;
                      while (!c.isZero()) {
                        var r = c.modn(groupBase).toString(base);
                        c = c.idivn(groupBase);
                        if (!c.isZero()) {
                          out = zeros[groupSize - r.length] + r + out;
                        } else {
                          out = r + out;
                        }
                      }
                      if (this.isZero()) {
                        out = "0" + out;
                      }
                      while (out.length % padding !== 0) {
                        out = "0" + out;
                      }
                      if (this.negative !== 0) {
                        out = "-" + out;
                      }
                      return out;
                    }
                    assert(false, "Base should be between 2 and 36");
                  };
                  BN.prototype.toNumber = function toNumber() {
                    var ret = this.words[0];
                    if (this.length === 2) {
                      ret += this.words[1] * 67108864;
                    } else if (this.length === 3 && this.words[2] === 1) {
                      ret += 4503599627370496 + this.words[1] * 67108864;
                    } else if (this.length > 2) {
                      assert(false, "Number can only safely store up to 53 bits");
                    }
                    return this.negative !== 0 ? -ret : ret;
                  };
                  BN.prototype.toJSON = function toJSON() {
                    return this.toString(16);
                  };
                  BN.prototype.toBuffer = function toBuffer(endian, length) {
                    assert(typeof Buffer !== "undefined");
                    return this.toArrayLike(Buffer, endian, length);
                  };
                  BN.prototype.toArray = function toArray(endian, length) {
                    return this.toArrayLike(Array, endian, length);
                  };
                  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
                    var byteLength = this.byteLength();
                    var reqLength = length || Math.max(1, byteLength);
                    assert(byteLength <= reqLength, "byte array longer than desired length");
                    assert(reqLength > 0, "Requested array length <= 0");
                    this.strip();
                    var littleEndian = endian === "le";
                    var res = new ArrayType(reqLength);
                    var b, i;
                    var q = this.clone();
                    if (!littleEndian) {
                      for (i = 0; i < reqLength - byteLength; i++) {
                        res[i] = 0;
                      }
                      for (i = 0; !q.isZero(); i++) {
                        b = q.andln(255);
                        q.iushrn(8);
                        res[reqLength - i - 1] = b;
                      }
                    } else {
                      for (i = 0; !q.isZero(); i++) {
                        b = q.andln(255);
                        q.iushrn(8);
                        res[i] = b;
                      }
                      for (; i < reqLength; i++) {
                        res[i] = 0;
                      }
                    }
                    return res;
                  };
                  if (Math.clz32) {
                    BN.prototype._countBits = function _countBits(w) {
                      return 32 - Math.clz32(w);
                    };
                  } else {
                    BN.prototype._countBits = function _countBits(w) {
                      var t = w;
                      var r = 0;
                      if (t >= 4096) {
                        r += 13;
                        t >>>= 13;
                      }
                      if (t >= 64) {
                        r += 7;
                        t >>>= 7;
                      }
                      if (t >= 8) {
                        r += 4;
                        t >>>= 4;
                      }
                      if (t >= 2) {
                        r += 2;
                        t >>>= 2;
                      }
                      return r + t;
                    };
                  }
                  BN.prototype._zeroBits = function _zeroBits(w) {
                    if (w === 0)
                      return 26;
                    var t = w;
                    var r = 0;
                    if ((t & 8191) === 0) {
                      r += 13;
                      t >>>= 13;
                    }
                    if ((t & 127) === 0) {
                      r += 7;
                      t >>>= 7;
                    }
                    if ((t & 15) === 0) {
                      r += 4;
                      t >>>= 4;
                    }
                    if ((t & 3) === 0) {
                      r += 2;
                      t >>>= 2;
                    }
                    if ((t & 1) === 0) {
                      r++;
                    }
                    return r;
                  };
                  BN.prototype.bitLength = function bitLength() {
                    var w = this.words[this.length - 1];
                    var hi = this._countBits(w);
                    return (this.length - 1) * 26 + hi;
                  };
                  function toBitArray(num) {
                    var w = new Array(num.bitLength());
                    for (var bit = 0; bit < w.length; bit++) {
                      var off = bit / 26 | 0;
                      var wbit = bit % 26;
                      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
                    }
                    return w;
                  }
                  BN.prototype.zeroBits = function zeroBits() {
                    if (this.isZero())
                      return 0;
                    var r = 0;
                    for (var i = 0; i < this.length; i++) {
                      var b = this._zeroBits(this.words[i]);
                      r += b;
                      if (b !== 26)
                        break;
                    }
                    return r;
                  };
                  BN.prototype.byteLength = function byteLength() {
                    return Math.ceil(this.bitLength() / 8);
                  };
                  BN.prototype.toTwos = function toTwos(width) {
                    if (this.negative !== 0) {
                      return this.abs().inotn(width).iaddn(1);
                    }
                    return this.clone();
                  };
                  BN.prototype.fromTwos = function fromTwos(width) {
                    if (this.testn(width - 1)) {
                      return this.notn(width).iaddn(1).ineg();
                    }
                    return this.clone();
                  };
                  BN.prototype.isNeg = function isNeg() {
                    return this.negative !== 0;
                  };
                  BN.prototype.neg = function neg() {
                    return this.clone().ineg();
                  };
                  BN.prototype.ineg = function ineg() {
                    if (!this.isZero()) {
                      this.negative ^= 1;
                    }
                    return this;
                  };
                  BN.prototype.iuor = function iuor(num) {
                    while (this.length < num.length) {
                      this.words[this.length++] = 0;
                    }
                    for (var i = 0; i < num.length; i++) {
                      this.words[i] = this.words[i] | num.words[i];
                    }
                    return this.strip();
                  };
                  BN.prototype.ior = function ior(num) {
                    assert((this.negative | num.negative) === 0);
                    return this.iuor(num);
                  };
                  BN.prototype.or = function or(num) {
                    if (this.length > num.length)
                      return this.clone().ior(num);
                    return num.clone().ior(this);
                  };
                  BN.prototype.uor = function uor(num) {
                    if (this.length > num.length)
                      return this.clone().iuor(num);
                    return num.clone().iuor(this);
                  };
                  BN.prototype.iuand = function iuand(num) {
                    var b;
                    if (this.length > num.length) {
                      b = num;
                    } else {
                      b = this;
                    }
                    for (var i = 0; i < b.length; i++) {
                      this.words[i] = this.words[i] & num.words[i];
                    }
                    this.length = b.length;
                    return this.strip();
                  };
                  BN.prototype.iand = function iand(num) {
                    assert((this.negative | num.negative) === 0);
                    return this.iuand(num);
                  };
                  BN.prototype.and = function and(num) {
                    if (this.length > num.length)
                      return this.clone().iand(num);
                    return num.clone().iand(this);
                  };
                  BN.prototype.uand = function uand(num) {
                    if (this.length > num.length)
                      return this.clone().iuand(num);
                    return num.clone().iuand(this);
                  };
                  BN.prototype.iuxor = function iuxor(num) {
                    var a;
                    var b;
                    if (this.length > num.length) {
                      a = this;
                      b = num;
                    } else {
                      a = num;
                      b = this;
                    }
                    for (var i = 0; i < b.length; i++) {
                      this.words[i] = a.words[i] ^ b.words[i];
                    }
                    if (this !== a) {
                      for (; i < a.length; i++) {
                        this.words[i] = a.words[i];
                      }
                    }
                    this.length = a.length;
                    return this.strip();
                  };
                  BN.prototype.ixor = function ixor(num) {
                    assert((this.negative | num.negative) === 0);
                    return this.iuxor(num);
                  };
                  BN.prototype.xor = function xor(num) {
                    if (this.length > num.length)
                      return this.clone().ixor(num);
                    return num.clone().ixor(this);
                  };
                  BN.prototype.uxor = function uxor(num) {
                    if (this.length > num.length)
                      return this.clone().iuxor(num);
                    return num.clone().iuxor(this);
                  };
                  BN.prototype.inotn = function inotn(width) {
                    assert(typeof width === "number" && width >= 0);
                    var bytesNeeded = Math.ceil(width / 26) | 0;
                    var bitsLeft = width % 26;
                    this._expand(bytesNeeded);
                    if (bitsLeft > 0) {
                      bytesNeeded--;
                    }
                    for (var i = 0; i < bytesNeeded; i++) {
                      this.words[i] = ~this.words[i] & 67108863;
                    }
                    if (bitsLeft > 0) {
                      this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
                    }
                    return this.strip();
                  };
                  BN.prototype.notn = function notn(width) {
                    return this.clone().inotn(width);
                  };
                  BN.prototype.setn = function setn(bit, val) {
                    assert(typeof bit === "number" && bit >= 0);
                    var off = bit / 26 | 0;
                    var wbit = bit % 26;
                    this._expand(off + 1);
                    if (val) {
                      this.words[off] = this.words[off] | 1 << wbit;
                    } else {
                      this.words[off] = this.words[off] & ~(1 << wbit);
                    }
                    return this.strip();
                  };
                  BN.prototype.iadd = function iadd(num) {
                    var r;
                    if (this.negative !== 0 && num.negative === 0) {
                      this.negative = 0;
                      r = this.isub(num);
                      this.negative ^= 1;
                      return this._normSign();
                    } else if (this.negative === 0 && num.negative !== 0) {
                      num.negative = 0;
                      r = this.isub(num);
                      num.negative = 1;
                      return r._normSign();
                    }
                    var a, b;
                    if (this.length > num.length) {
                      a = this;
                      b = num;
                    } else {
                      a = num;
                      b = this;
                    }
                    var carry = 0;
                    for (var i = 0; i < b.length; i++) {
                      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
                      this.words[i] = r & 67108863;
                      carry = r >>> 26;
                    }
                    for (; carry !== 0 && i < a.length; i++) {
                      r = (a.words[i] | 0) + carry;
                      this.words[i] = r & 67108863;
                      carry = r >>> 26;
                    }
                    this.length = a.length;
                    if (carry !== 0) {
                      this.words[this.length] = carry;
                      this.length++;
                    } else if (a !== this) {
                      for (; i < a.length; i++) {
                        this.words[i] = a.words[i];
                      }
                    }
                    return this;
                  };
                  BN.prototype.add = function add(num) {
                    var res;
                    if (num.negative !== 0 && this.negative === 0) {
                      num.negative = 0;
                      res = this.sub(num);
                      num.negative ^= 1;
                      return res;
                    } else if (num.negative === 0 && this.negative !== 0) {
                      this.negative = 0;
                      res = num.sub(this);
                      this.negative = 1;
                      return res;
                    }
                    if (this.length > num.length)
                      return this.clone().iadd(num);
                    return num.clone().iadd(this);
                  };
                  BN.prototype.isub = function isub(num) {
                    if (num.negative !== 0) {
                      num.negative = 0;
                      var r = this.iadd(num);
                      num.negative = 1;
                      return r._normSign();
                    } else if (this.negative !== 0) {
                      this.negative = 0;
                      this.iadd(num);
                      this.negative = 1;
                      return this._normSign();
                    }
                    var cmp = this.cmp(num);
                    if (cmp === 0) {
                      this.negative = 0;
                      this.length = 1;
                      this.words[0] = 0;
                      return this;
                    }
                    var a, b;
                    if (cmp > 0) {
                      a = this;
                      b = num;
                    } else {
                      a = num;
                      b = this;
                    }
                    var carry = 0;
                    for (var i = 0; i < b.length; i++) {
                      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
                      carry = r >> 26;
                      this.words[i] = r & 67108863;
                    }
                    for (; carry !== 0 && i < a.length; i++) {
                      r = (a.words[i] | 0) + carry;
                      carry = r >> 26;
                      this.words[i] = r & 67108863;
                    }
                    if (carry === 0 && i < a.length && a !== this) {
                      for (; i < a.length; i++) {
                        this.words[i] = a.words[i];
                      }
                    }
                    this.length = Math.max(this.length, i);
                    if (a !== this) {
                      this.negative = 1;
                    }
                    return this.strip();
                  };
                  BN.prototype.sub = function sub(num) {
                    return this.clone().isub(num);
                  };
                  function smallMulTo(self2, num, out) {
                    out.negative = num.negative ^ self2.negative;
                    var len = self2.length + num.length | 0;
                    out.length = len;
                    len = len - 1 | 0;
                    var a = self2.words[0] | 0;
                    var b = num.words[0] | 0;
                    var r = a * b;
                    var lo = r & 67108863;
                    var carry = r / 67108864 | 0;
                    out.words[0] = lo;
                    for (var k = 1; k < len; k++) {
                      var ncarry = carry >>> 26;
                      var rword = carry & 67108863;
                      var maxJ = Math.min(k, num.length - 1);
                      for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
                        var i = k - j | 0;
                        a = self2.words[i] | 0;
                        b = num.words[j] | 0;
                        r = a * b + rword;
                        ncarry += r / 67108864 | 0;
                        rword = r & 67108863;
                      }
                      out.words[k] = rword | 0;
                      carry = ncarry | 0;
                    }
                    if (carry !== 0) {
                      out.words[k] = carry | 0;
                    } else {
                      out.length--;
                    }
                    return out.strip();
                  }
                  var comb10MulTo = function comb10MulTo2(self2, num, out) {
                    var a = self2.words;
                    var b = num.words;
                    var o = out.words;
                    var c = 0;
                    var lo;
                    var mid;
                    var hi;
                    var a0 = a[0] | 0;
                    var al0 = a0 & 8191;
                    var ah0 = a0 >>> 13;
                    var a1 = a[1] | 0;
                    var al1 = a1 & 8191;
                    var ah1 = a1 >>> 13;
                    var a2 = a[2] | 0;
                    var al2 = a2 & 8191;
                    var ah2 = a2 >>> 13;
                    var a3 = a[3] | 0;
                    var al3 = a3 & 8191;
                    var ah3 = a3 >>> 13;
                    var a4 = a[4] | 0;
                    var al4 = a4 & 8191;
                    var ah4 = a4 >>> 13;
                    var a5 = a[5] | 0;
                    var al5 = a5 & 8191;
                    var ah5 = a5 >>> 13;
                    var a6 = a[6] | 0;
                    var al6 = a6 & 8191;
                    var ah6 = a6 >>> 13;
                    var a7 = a[7] | 0;
                    var al7 = a7 & 8191;
                    var ah7 = a7 >>> 13;
                    var a8 = a[8] | 0;
                    var al8 = a8 & 8191;
                    var ah8 = a8 >>> 13;
                    var a9 = a[9] | 0;
                    var al9 = a9 & 8191;
                    var ah9 = a9 >>> 13;
                    var b0 = b[0] | 0;
                    var bl0 = b0 & 8191;
                    var bh0 = b0 >>> 13;
                    var b1 = b[1] | 0;
                    var bl1 = b1 & 8191;
                    var bh1 = b1 >>> 13;
                    var b2 = b[2] | 0;
                    var bl2 = b2 & 8191;
                    var bh2 = b2 >>> 13;
                    var b3 = b[3] | 0;
                    var bl3 = b3 & 8191;
                    var bh3 = b3 >>> 13;
                    var b4 = b[4] | 0;
                    var bl4 = b4 & 8191;
                    var bh4 = b4 >>> 13;
                    var b5 = b[5] | 0;
                    var bl5 = b5 & 8191;
                    var bh5 = b5 >>> 13;
                    var b6 = b[6] | 0;
                    var bl6 = b6 & 8191;
                    var bh6 = b6 >>> 13;
                    var b7 = b[7] | 0;
                    var bl7 = b7 & 8191;
                    var bh7 = b7 >>> 13;
                    var b8 = b[8] | 0;
                    var bl8 = b8 & 8191;
                    var bh8 = b8 >>> 13;
                    var b9 = b[9] | 0;
                    var bl9 = b9 & 8191;
                    var bh9 = b9 >>> 13;
                    out.negative = self2.negative ^ num.negative;
                    out.length = 19;
                    lo = Math.imul(al0, bl0);
                    mid = Math.imul(al0, bh0);
                    mid = mid + Math.imul(ah0, bl0) | 0;
                    hi = Math.imul(ah0, bh0);
                    var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
                    w0 &= 67108863;
                    lo = Math.imul(al1, bl0);
                    mid = Math.imul(al1, bh0);
                    mid = mid + Math.imul(ah1, bl0) | 0;
                    hi = Math.imul(ah1, bh0);
                    lo = lo + Math.imul(al0, bl1) | 0;
                    mid = mid + Math.imul(al0, bh1) | 0;
                    mid = mid + Math.imul(ah0, bl1) | 0;
                    hi = hi + Math.imul(ah0, bh1) | 0;
                    var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
                    w1 &= 67108863;
                    lo = Math.imul(al2, bl0);
                    mid = Math.imul(al2, bh0);
                    mid = mid + Math.imul(ah2, bl0) | 0;
                    hi = Math.imul(ah2, bh0);
                    lo = lo + Math.imul(al1, bl1) | 0;
                    mid = mid + Math.imul(al1, bh1) | 0;
                    mid = mid + Math.imul(ah1, bl1) | 0;
                    hi = hi + Math.imul(ah1, bh1) | 0;
                    lo = lo + Math.imul(al0, bl2) | 0;
                    mid = mid + Math.imul(al0, bh2) | 0;
                    mid = mid + Math.imul(ah0, bl2) | 0;
                    hi = hi + Math.imul(ah0, bh2) | 0;
                    var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
                    w2 &= 67108863;
                    lo = Math.imul(al3, bl0);
                    mid = Math.imul(al3, bh0);
                    mid = mid + Math.imul(ah3, bl0) | 0;
                    hi = Math.imul(ah3, bh0);
                    lo = lo + Math.imul(al2, bl1) | 0;
                    mid = mid + Math.imul(al2, bh1) | 0;
                    mid = mid + Math.imul(ah2, bl1) | 0;
                    hi = hi + Math.imul(ah2, bh1) | 0;
                    lo = lo + Math.imul(al1, bl2) | 0;
                    mid = mid + Math.imul(al1, bh2) | 0;
                    mid = mid + Math.imul(ah1, bl2) | 0;
                    hi = hi + Math.imul(ah1, bh2) | 0;
                    lo = lo + Math.imul(al0, bl3) | 0;
                    mid = mid + Math.imul(al0, bh3) | 0;
                    mid = mid + Math.imul(ah0, bl3) | 0;
                    hi = hi + Math.imul(ah0, bh3) | 0;
                    var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
                    w3 &= 67108863;
                    lo = Math.imul(al4, bl0);
                    mid = Math.imul(al4, bh0);
                    mid = mid + Math.imul(ah4, bl0) | 0;
                    hi = Math.imul(ah4, bh0);
                    lo = lo + Math.imul(al3, bl1) | 0;
                    mid = mid + Math.imul(al3, bh1) | 0;
                    mid = mid + Math.imul(ah3, bl1) | 0;
                    hi = hi + Math.imul(ah3, bh1) | 0;
                    lo = lo + Math.imul(al2, bl2) | 0;
                    mid = mid + Math.imul(al2, bh2) | 0;
                    mid = mid + Math.imul(ah2, bl2) | 0;
                    hi = hi + Math.imul(ah2, bh2) | 0;
                    lo = lo + Math.imul(al1, bl3) | 0;
                    mid = mid + Math.imul(al1, bh3) | 0;
                    mid = mid + Math.imul(ah1, bl3) | 0;
                    hi = hi + Math.imul(ah1, bh3) | 0;
                    lo = lo + Math.imul(al0, bl4) | 0;
                    mid = mid + Math.imul(al0, bh4) | 0;
                    mid = mid + Math.imul(ah0, bl4) | 0;
                    hi = hi + Math.imul(ah0, bh4) | 0;
                    var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
                    w4 &= 67108863;
                    lo = Math.imul(al5, bl0);
                    mid = Math.imul(al5, bh0);
                    mid = mid + Math.imul(ah5, bl0) | 0;
                    hi = Math.imul(ah5, bh0);
                    lo = lo + Math.imul(al4, bl1) | 0;
                    mid = mid + Math.imul(al4, bh1) | 0;
                    mid = mid + Math.imul(ah4, bl1) | 0;
                    hi = hi + Math.imul(ah4, bh1) | 0;
                    lo = lo + Math.imul(al3, bl2) | 0;
                    mid = mid + Math.imul(al3, bh2) | 0;
                    mid = mid + Math.imul(ah3, bl2) | 0;
                    hi = hi + Math.imul(ah3, bh2) | 0;
                    lo = lo + Math.imul(al2, bl3) | 0;
                    mid = mid + Math.imul(al2, bh3) | 0;
                    mid = mid + Math.imul(ah2, bl3) | 0;
                    hi = hi + Math.imul(ah2, bh3) | 0;
                    lo = lo + Math.imul(al1, bl4) | 0;
                    mid = mid + Math.imul(al1, bh4) | 0;
                    mid = mid + Math.imul(ah1, bl4) | 0;
                    hi = hi + Math.imul(ah1, bh4) | 0;
                    lo = lo + Math.imul(al0, bl5) | 0;
                    mid = mid + Math.imul(al0, bh5) | 0;
                    mid = mid + Math.imul(ah0, bl5) | 0;
                    hi = hi + Math.imul(ah0, bh5) | 0;
                    var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
                    w5 &= 67108863;
                    lo = Math.imul(al6, bl0);
                    mid = Math.imul(al6, bh0);
                    mid = mid + Math.imul(ah6, bl0) | 0;
                    hi = Math.imul(ah6, bh0);
                    lo = lo + Math.imul(al5, bl1) | 0;
                    mid = mid + Math.imul(al5, bh1) | 0;
                    mid = mid + Math.imul(ah5, bl1) | 0;
                    hi = hi + Math.imul(ah5, bh1) | 0;
                    lo = lo + Math.imul(al4, bl2) | 0;
                    mid = mid + Math.imul(al4, bh2) | 0;
                    mid = mid + Math.imul(ah4, bl2) | 0;
                    hi = hi + Math.imul(ah4, bh2) | 0;
                    lo = lo + Math.imul(al3, bl3) | 0;
                    mid = mid + Math.imul(al3, bh3) | 0;
                    mid = mid + Math.imul(ah3, bl3) | 0;
                    hi = hi + Math.imul(ah3, bh3) | 0;
                    lo = lo + Math.imul(al2, bl4) | 0;
                    mid = mid + Math.imul(al2, bh4) | 0;
                    mid = mid + Math.imul(ah2, bl4) | 0;
                    hi = hi + Math.imul(ah2, bh4) | 0;
                    lo = lo + Math.imul(al1, bl5) | 0;
                    mid = mid + Math.imul(al1, bh5) | 0;
                    mid = mid + Math.imul(ah1, bl5) | 0;
                    hi = hi + Math.imul(ah1, bh5) | 0;
                    lo = lo + Math.imul(al0, bl6) | 0;
                    mid = mid + Math.imul(al0, bh6) | 0;
                    mid = mid + Math.imul(ah0, bl6) | 0;
                    hi = hi + Math.imul(ah0, bh6) | 0;
                    var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
                    w6 &= 67108863;
                    lo = Math.imul(al7, bl0);
                    mid = Math.imul(al7, bh0);
                    mid = mid + Math.imul(ah7, bl0) | 0;
                    hi = Math.imul(ah7, bh0);
                    lo = lo + Math.imul(al6, bl1) | 0;
                    mid = mid + Math.imul(al6, bh1) | 0;
                    mid = mid + Math.imul(ah6, bl1) | 0;
                    hi = hi + Math.imul(ah6, bh1) | 0;
                    lo = lo + Math.imul(al5, bl2) | 0;
                    mid = mid + Math.imul(al5, bh2) | 0;
                    mid = mid + Math.imul(ah5, bl2) | 0;
                    hi = hi + Math.imul(ah5, bh2) | 0;
                    lo = lo + Math.imul(al4, bl3) | 0;
                    mid = mid + Math.imul(al4, bh3) | 0;
                    mid = mid + Math.imul(ah4, bl3) | 0;
                    hi = hi + Math.imul(ah4, bh3) | 0;
                    lo = lo + Math.imul(al3, bl4) | 0;
                    mid = mid + Math.imul(al3, bh4) | 0;
                    mid = mid + Math.imul(ah3, bl4) | 0;
                    hi = hi + Math.imul(ah3, bh4) | 0;
                    lo = lo + Math.imul(al2, bl5) | 0;
                    mid = mid + Math.imul(al2, bh5) | 0;
                    mid = mid + Math.imul(ah2, bl5) | 0;
                    hi = hi + Math.imul(ah2, bh5) | 0;
                    lo = lo + Math.imul(al1, bl6) | 0;
                    mid = mid + Math.imul(al1, bh6) | 0;
                    mid = mid + Math.imul(ah1, bl6) | 0;
                    hi = hi + Math.imul(ah1, bh6) | 0;
                    lo = lo + Math.imul(al0, bl7) | 0;
                    mid = mid + Math.imul(al0, bh7) | 0;
                    mid = mid + Math.imul(ah0, bl7) | 0;
                    hi = hi + Math.imul(ah0, bh7) | 0;
                    var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
                    w7 &= 67108863;
                    lo = Math.imul(al8, bl0);
                    mid = Math.imul(al8, bh0);
                    mid = mid + Math.imul(ah8, bl0) | 0;
                    hi = Math.imul(ah8, bh0);
                    lo = lo + Math.imul(al7, bl1) | 0;
                    mid = mid + Math.imul(al7, bh1) | 0;
                    mid = mid + Math.imul(ah7, bl1) | 0;
                    hi = hi + Math.imul(ah7, bh1) | 0;
                    lo = lo + Math.imul(al6, bl2) | 0;
                    mid = mid + Math.imul(al6, bh2) | 0;
                    mid = mid + Math.imul(ah6, bl2) | 0;
                    hi = hi + Math.imul(ah6, bh2) | 0;
                    lo = lo + Math.imul(al5, bl3) | 0;
                    mid = mid + Math.imul(al5, bh3) | 0;
                    mid = mid + Math.imul(ah5, bl3) | 0;
                    hi = hi + Math.imul(ah5, bh3) | 0;
                    lo = lo + Math.imul(al4, bl4) | 0;
                    mid = mid + Math.imul(al4, bh4) | 0;
                    mid = mid + Math.imul(ah4, bl4) | 0;
                    hi = hi + Math.imul(ah4, bh4) | 0;
                    lo = lo + Math.imul(al3, bl5) | 0;
                    mid = mid + Math.imul(al3, bh5) | 0;
                    mid = mid + Math.imul(ah3, bl5) | 0;
                    hi = hi + Math.imul(ah3, bh5) | 0;
                    lo = lo + Math.imul(al2, bl6) | 0;
                    mid = mid + Math.imul(al2, bh6) | 0;
                    mid = mid + Math.imul(ah2, bl6) | 0;
                    hi = hi + Math.imul(ah2, bh6) | 0;
                    lo = lo + Math.imul(al1, bl7) | 0;
                    mid = mid + Math.imul(al1, bh7) | 0;
                    mid = mid + Math.imul(ah1, bl7) | 0;
                    hi = hi + Math.imul(ah1, bh7) | 0;
                    lo = lo + Math.imul(al0, bl8) | 0;
                    mid = mid + Math.imul(al0, bh8) | 0;
                    mid = mid + Math.imul(ah0, bl8) | 0;
                    hi = hi + Math.imul(ah0, bh8) | 0;
                    var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
                    w8 &= 67108863;
                    lo = Math.imul(al9, bl0);
                    mid = Math.imul(al9, bh0);
                    mid = mid + Math.imul(ah9, bl0) | 0;
                    hi = Math.imul(ah9, bh0);
                    lo = lo + Math.imul(al8, bl1) | 0;
                    mid = mid + Math.imul(al8, bh1) | 0;
                    mid = mid + Math.imul(ah8, bl1) | 0;
                    hi = hi + Math.imul(ah8, bh1) | 0;
                    lo = lo + Math.imul(al7, bl2) | 0;
                    mid = mid + Math.imul(al7, bh2) | 0;
                    mid = mid + Math.imul(ah7, bl2) | 0;
                    hi = hi + Math.imul(ah7, bh2) | 0;
                    lo = lo + Math.imul(al6, bl3) | 0;
                    mid = mid + Math.imul(al6, bh3) | 0;
                    mid = mid + Math.imul(ah6, bl3) | 0;
                    hi = hi + Math.imul(ah6, bh3) | 0;
                    lo = lo + Math.imul(al5, bl4) | 0;
                    mid = mid + Math.imul(al5, bh4) | 0;
                    mid = mid + Math.imul(ah5, bl4) | 0;
                    hi = hi + Math.imul(ah5, bh4) | 0;
                    lo = lo + Math.imul(al4, bl5) | 0;
                    mid = mid + Math.imul(al4, bh5) | 0;
                    mid = mid + Math.imul(ah4, bl5) | 0;
                    hi = hi + Math.imul(ah4, bh5) | 0;
                    lo = lo + Math.imul(al3, bl6) | 0;
                    mid = mid + Math.imul(al3, bh6) | 0;
                    mid = mid + Math.imul(ah3, bl6) | 0;
                    hi = hi + Math.imul(ah3, bh6) | 0;
                    lo = lo + Math.imul(al2, bl7) | 0;
                    mid = mid + Math.imul(al2, bh7) | 0;
                    mid = mid + Math.imul(ah2, bl7) | 0;
                    hi = hi + Math.imul(ah2, bh7) | 0;
                    lo = lo + Math.imul(al1, bl8) | 0;
                    mid = mid + Math.imul(al1, bh8) | 0;
                    mid = mid + Math.imul(ah1, bl8) | 0;
                    hi = hi + Math.imul(ah1, bh8) | 0;
                    lo = lo + Math.imul(al0, bl9) | 0;
                    mid = mid + Math.imul(al0, bh9) | 0;
                    mid = mid + Math.imul(ah0, bl9) | 0;
                    hi = hi + Math.imul(ah0, bh9) | 0;
                    var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
                    w9 &= 67108863;
                    lo = Math.imul(al9, bl1);
                    mid = Math.imul(al9, bh1);
                    mid = mid + Math.imul(ah9, bl1) | 0;
                    hi = Math.imul(ah9, bh1);
                    lo = lo + Math.imul(al8, bl2) | 0;
                    mid = mid + Math.imul(al8, bh2) | 0;
                    mid = mid + Math.imul(ah8, bl2) | 0;
                    hi = hi + Math.imul(ah8, bh2) | 0;
                    lo = lo + Math.imul(al7, bl3) | 0;
                    mid = mid + Math.imul(al7, bh3) | 0;
                    mid = mid + Math.imul(ah7, bl3) | 0;
                    hi = hi + Math.imul(ah7, bh3) | 0;
                    lo = lo + Math.imul(al6, bl4) | 0;
                    mid = mid + Math.imul(al6, bh4) | 0;
                    mid = mid + Math.imul(ah6, bl4) | 0;
                    hi = hi + Math.imul(ah6, bh4) | 0;
                    lo = lo + Math.imul(al5, bl5) | 0;
                    mid = mid + Math.imul(al5, bh5) | 0;
                    mid = mid + Math.imul(ah5, bl5) | 0;
                    hi = hi + Math.imul(ah5, bh5) | 0;
                    lo = lo + Math.imul(al4, bl6) | 0;
                    mid = mid + Math.imul(al4, bh6) | 0;
                    mid = mid + Math.imul(ah4, bl6) | 0;
                    hi = hi + Math.imul(ah4, bh6) | 0;
                    lo = lo + Math.imul(al3, bl7) | 0;
                    mid = mid + Math.imul(al3, bh7) | 0;
                    mid = mid + Math.imul(ah3, bl7) | 0;
                    hi = hi + Math.imul(ah3, bh7) | 0;
                    lo = lo + Math.imul(al2, bl8) | 0;
                    mid = mid + Math.imul(al2, bh8) | 0;
                    mid = mid + Math.imul(ah2, bl8) | 0;
                    hi = hi + Math.imul(ah2, bh8) | 0;
                    lo = lo + Math.imul(al1, bl9) | 0;
                    mid = mid + Math.imul(al1, bh9) | 0;
                    mid = mid + Math.imul(ah1, bl9) | 0;
                    hi = hi + Math.imul(ah1, bh9) | 0;
                    var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
                    w10 &= 67108863;
                    lo = Math.imul(al9, bl2);
                    mid = Math.imul(al9, bh2);
                    mid = mid + Math.imul(ah9, bl2) | 0;
                    hi = Math.imul(ah9, bh2);
                    lo = lo + Math.imul(al8, bl3) | 0;
                    mid = mid + Math.imul(al8, bh3) | 0;
                    mid = mid + Math.imul(ah8, bl3) | 0;
                    hi = hi + Math.imul(ah8, bh3) | 0;
                    lo = lo + Math.imul(al7, bl4) | 0;
                    mid = mid + Math.imul(al7, bh4) | 0;
                    mid = mid + Math.imul(ah7, bl4) | 0;
                    hi = hi + Math.imul(ah7, bh4) | 0;
                    lo = lo + Math.imul(al6, bl5) | 0;
                    mid = mid + Math.imul(al6, bh5) | 0;
                    mid = mid + Math.imul(ah6, bl5) | 0;
                    hi = hi + Math.imul(ah6, bh5) | 0;
                    lo = lo + Math.imul(al5, bl6) | 0;
                    mid = mid + Math.imul(al5, bh6) | 0;
                    mid = mid + Math.imul(ah5, bl6) | 0;
                    hi = hi + Math.imul(ah5, bh6) | 0;
                    lo = lo + Math.imul(al4, bl7) | 0;
                    mid = mid + Math.imul(al4, bh7) | 0;
                    mid = mid + Math.imul(ah4, bl7) | 0;
                    hi = hi + Math.imul(ah4, bh7) | 0;
                    lo = lo + Math.imul(al3, bl8) | 0;
                    mid = mid + Math.imul(al3, bh8) | 0;
                    mid = mid + Math.imul(ah3, bl8) | 0;
                    hi = hi + Math.imul(ah3, bh8) | 0;
                    lo = lo + Math.imul(al2, bl9) | 0;
                    mid = mid + Math.imul(al2, bh9) | 0;
                    mid = mid + Math.imul(ah2, bl9) | 0;
                    hi = hi + Math.imul(ah2, bh9) | 0;
                    var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
                    w11 &= 67108863;
                    lo = Math.imul(al9, bl3);
                    mid = Math.imul(al9, bh3);
                    mid = mid + Math.imul(ah9, bl3) | 0;
                    hi = Math.imul(ah9, bh3);
                    lo = lo + Math.imul(al8, bl4) | 0;
                    mid = mid + Math.imul(al8, bh4) | 0;
                    mid = mid + Math.imul(ah8, bl4) | 0;
                    hi = hi + Math.imul(ah8, bh4) | 0;
                    lo = lo + Math.imul(al7, bl5) | 0;
                    mid = mid + Math.imul(al7, bh5) | 0;
                    mid = mid + Math.imul(ah7, bl5) | 0;
                    hi = hi + Math.imul(ah7, bh5) | 0;
                    lo = lo + Math.imul(al6, bl6) | 0;
                    mid = mid + Math.imul(al6, bh6) | 0;
                    mid = mid + Math.imul(ah6, bl6) | 0;
                    hi = hi + Math.imul(ah6, bh6) | 0;
                    lo = lo + Math.imul(al5, bl7) | 0;
                    mid = mid + Math.imul(al5, bh7) | 0;
                    mid = mid + Math.imul(ah5, bl7) | 0;
                    hi = hi + Math.imul(ah5, bh7) | 0;
                    lo = lo + Math.imul(al4, bl8) | 0;
                    mid = mid + Math.imul(al4, bh8) | 0;
                    mid = mid + Math.imul(ah4, bl8) | 0;
                    hi = hi + Math.imul(ah4, bh8) | 0;
                    lo = lo + Math.imul(al3, bl9) | 0;
                    mid = mid + Math.imul(al3, bh9) | 0;
                    mid = mid + Math.imul(ah3, bl9) | 0;
                    hi = hi + Math.imul(ah3, bh9) | 0;
                    var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
                    w12 &= 67108863;
                    lo = Math.imul(al9, bl4);
                    mid = Math.imul(al9, bh4);
                    mid = mid + Math.imul(ah9, bl4) | 0;
                    hi = Math.imul(ah9, bh4);
                    lo = lo + Math.imul(al8, bl5) | 0;
                    mid = mid + Math.imul(al8, bh5) | 0;
                    mid = mid + Math.imul(ah8, bl5) | 0;
                    hi = hi + Math.imul(ah8, bh5) | 0;
                    lo = lo + Math.imul(al7, bl6) | 0;
                    mid = mid + Math.imul(al7, bh6) | 0;
                    mid = mid + Math.imul(ah7, bl6) | 0;
                    hi = hi + Math.imul(ah7, bh6) | 0;
                    lo = lo + Math.imul(al6, bl7) | 0;
                    mid = mid + Math.imul(al6, bh7) | 0;
                    mid = mid + Math.imul(ah6, bl7) | 0;
                    hi = hi + Math.imul(ah6, bh7) | 0;
                    lo = lo + Math.imul(al5, bl8) | 0;
                    mid = mid + Math.imul(al5, bh8) | 0;
                    mid = mid + Math.imul(ah5, bl8) | 0;
                    hi = hi + Math.imul(ah5, bh8) | 0;
                    lo = lo + Math.imul(al4, bl9) | 0;
                    mid = mid + Math.imul(al4, bh9) | 0;
                    mid = mid + Math.imul(ah4, bl9) | 0;
                    hi = hi + Math.imul(ah4, bh9) | 0;
                    var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
                    w13 &= 67108863;
                    lo = Math.imul(al9, bl5);
                    mid = Math.imul(al9, bh5);
                    mid = mid + Math.imul(ah9, bl5) | 0;
                    hi = Math.imul(ah9, bh5);
                    lo = lo + Math.imul(al8, bl6) | 0;
                    mid = mid + Math.imul(al8, bh6) | 0;
                    mid = mid + Math.imul(ah8, bl6) | 0;
                    hi = hi + Math.imul(ah8, bh6) | 0;
                    lo = lo + Math.imul(al7, bl7) | 0;
                    mid = mid + Math.imul(al7, bh7) | 0;
                    mid = mid + Math.imul(ah7, bl7) | 0;
                    hi = hi + Math.imul(ah7, bh7) | 0;
                    lo = lo + Math.imul(al6, bl8) | 0;
                    mid = mid + Math.imul(al6, bh8) | 0;
                    mid = mid + Math.imul(ah6, bl8) | 0;
                    hi = hi + Math.imul(ah6, bh8) | 0;
                    lo = lo + Math.imul(al5, bl9) | 0;
                    mid = mid + Math.imul(al5, bh9) | 0;
                    mid = mid + Math.imul(ah5, bl9) | 0;
                    hi = hi + Math.imul(ah5, bh9) | 0;
                    var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
                    w14 &= 67108863;
                    lo = Math.imul(al9, bl6);
                    mid = Math.imul(al9, bh6);
                    mid = mid + Math.imul(ah9, bl6) | 0;
                    hi = Math.imul(ah9, bh6);
                    lo = lo + Math.imul(al8, bl7) | 0;
                    mid = mid + Math.imul(al8, bh7) | 0;
                    mid = mid + Math.imul(ah8, bl7) | 0;
                    hi = hi + Math.imul(ah8, bh7) | 0;
                    lo = lo + Math.imul(al7, bl8) | 0;
                    mid = mid + Math.imul(al7, bh8) | 0;
                    mid = mid + Math.imul(ah7, bl8) | 0;
                    hi = hi + Math.imul(ah7, bh8) | 0;
                    lo = lo + Math.imul(al6, bl9) | 0;
                    mid = mid + Math.imul(al6, bh9) | 0;
                    mid = mid + Math.imul(ah6, bl9) | 0;
                    hi = hi + Math.imul(ah6, bh9) | 0;
                    var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
                    w15 &= 67108863;
                    lo = Math.imul(al9, bl7);
                    mid = Math.imul(al9, bh7);
                    mid = mid + Math.imul(ah9, bl7) | 0;
                    hi = Math.imul(ah9, bh7);
                    lo = lo + Math.imul(al8, bl8) | 0;
                    mid = mid + Math.imul(al8, bh8) | 0;
                    mid = mid + Math.imul(ah8, bl8) | 0;
                    hi = hi + Math.imul(ah8, bh8) | 0;
                    lo = lo + Math.imul(al7, bl9) | 0;
                    mid = mid + Math.imul(al7, bh9) | 0;
                    mid = mid + Math.imul(ah7, bl9) | 0;
                    hi = hi + Math.imul(ah7, bh9) | 0;
                    var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
                    w16 &= 67108863;
                    lo = Math.imul(al9, bl8);
                    mid = Math.imul(al9, bh8);
                    mid = mid + Math.imul(ah9, bl8) | 0;
                    hi = Math.imul(ah9, bh8);
                    lo = lo + Math.imul(al8, bl9) | 0;
                    mid = mid + Math.imul(al8, bh9) | 0;
                    mid = mid + Math.imul(ah8, bl9) | 0;
                    hi = hi + Math.imul(ah8, bh9) | 0;
                    var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
                    w17 &= 67108863;
                    lo = Math.imul(al9, bl9);
                    mid = Math.imul(al9, bh9);
                    mid = mid + Math.imul(ah9, bl9) | 0;
                    hi = Math.imul(ah9, bh9);
                    var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
                    w18 &= 67108863;
                    o[0] = w0;
                    o[1] = w1;
                    o[2] = w2;
                    o[3] = w3;
                    o[4] = w4;
                    o[5] = w5;
                    o[6] = w6;
                    o[7] = w7;
                    o[8] = w8;
                    o[9] = w9;
                    o[10] = w10;
                    o[11] = w11;
                    o[12] = w12;
                    o[13] = w13;
                    o[14] = w14;
                    o[15] = w15;
                    o[16] = w16;
                    o[17] = w17;
                    o[18] = w18;
                    if (c !== 0) {
                      o[19] = c;
                      out.length++;
                    }
                    return out;
                  };
                  if (!Math.imul) {
                    comb10MulTo = smallMulTo;
                  }
                  function bigMulTo(self2, num, out) {
                    out.negative = num.negative ^ self2.negative;
                    out.length = self2.length + num.length;
                    var carry = 0;
                    var hncarry = 0;
                    for (var k = 0; k < out.length - 1; k++) {
                      var ncarry = hncarry;
                      hncarry = 0;
                      var rword = carry & 67108863;
                      var maxJ = Math.min(k, num.length - 1);
                      for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = self2.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;
                        var lo = r & 67108863;
                        ncarry = ncarry + (r / 67108864 | 0) | 0;
                        lo = lo + rword | 0;
                        rword = lo & 67108863;
                        ncarry = ncarry + (lo >>> 26) | 0;
                        hncarry += ncarry >>> 26;
                        ncarry &= 67108863;
                      }
                      out.words[k] = rword;
                      carry = ncarry;
                      ncarry = hncarry;
                    }
                    if (carry !== 0) {
                      out.words[k] = carry;
                    } else {
                      out.length--;
                    }
                    return out.strip();
                  }
                  function jumboMulTo(self2, num, out) {
                    var fftm = new FFTM();
                    return fftm.mulp(self2, num, out);
                  }
                  BN.prototype.mulTo = function mulTo(num, out) {
                    var res;
                    var len = this.length + num.length;
                    if (this.length === 10 && num.length === 10) {
                      res = comb10MulTo(this, num, out);
                    } else if (len < 63) {
                      res = smallMulTo(this, num, out);
                    } else if (len < 1024) {
                      res = bigMulTo(this, num, out);
                    } else {
                      res = jumboMulTo(this, num, out);
                    }
                    return res;
                  };
                  function FFTM(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                  FFTM.prototype.makeRBT = function makeRBT(N) {
                    var t = new Array(N);
                    var l = BN.prototype._countBits(N) - 1;
                    for (var i = 0; i < N; i++) {
                      t[i] = this.revBin(i, l, N);
                    }
                    return t;
                  };
                  FFTM.prototype.revBin = function revBin(x, l, N) {
                    if (x === 0 || x === N - 1)
                      return x;
                    var rb = 0;
                    for (var i = 0; i < l; i++) {
                      rb |= (x & 1) << l - i - 1;
                      x >>= 1;
                    }
                    return rb;
                  };
                  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
                    for (var i = 0; i < N; i++) {
                      rtws[i] = rws[rbt[i]];
                      itws[i] = iws[rbt[i]];
                    }
                  };
                  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
                    this.permute(rbt, rws, iws, rtws, itws, N);
                    for (var s = 1; s < N; s <<= 1) {
                      var l = s << 1;
                      var rtwdf = Math.cos(2 * Math.PI / l);
                      var itwdf = Math.sin(2 * Math.PI / l);
                      for (var p = 0; p < N; p += l) {
                        var rtwdf_ = rtwdf;
                        var itwdf_ = itwdf;
                        for (var j = 0; j < s; j++) {
                          var re = rtws[p + j];
                          var ie = itws[p + j];
                          var ro = rtws[p + j + s];
                          var io = itws[p + j + s];
                          var rx = rtwdf_ * ro - itwdf_ * io;
                          io = rtwdf_ * io + itwdf_ * ro;
                          ro = rx;
                          rtws[p + j] = re + ro;
                          itws[p + j] = ie + io;
                          rtws[p + j + s] = re - ro;
                          itws[p + j + s] = ie - io;
                          if (j !== l) {
                            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                            rtwdf_ = rx;
                          }
                        }
                      }
                    }
                  };
                  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
                    var N = Math.max(m, n) | 1;
                    var odd = N & 1;
                    var i = 0;
                    for (N = N / 2 | 0; N; N = N >>> 1) {
                      i++;
                    }
                    return 1 << i + 1 + odd;
                  };
                  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
                    if (N <= 1)
                      return;
                    for (var i = 0; i < N / 2; i++) {
                      var t = rws[i];
                      rws[i] = rws[N - i - 1];
                      rws[N - i - 1] = t;
                      t = iws[i];
                      iws[i] = -iws[N - i - 1];
                      iws[N - i - 1] = -t;
                    }
                  };
                  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
                    var carry = 0;
                    for (var i = 0; i < N / 2; i++) {
                      var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
                      ws[i] = w & 67108863;
                      if (w < 67108864) {
                        carry = 0;
                      } else {
                        carry = w / 67108864 | 0;
                      }
                    }
                    return ws;
                  };
                  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
                    var carry = 0;
                    for (var i = 0; i < len; i++) {
                      carry = carry + (ws[i] | 0);
                      rws[2 * i] = carry & 8191;
                      carry = carry >>> 13;
                      rws[2 * i + 1] = carry & 8191;
                      carry = carry >>> 13;
                    }
                    for (i = 2 * len; i < N; ++i) {
                      rws[i] = 0;
                    }
                    assert(carry === 0);
                    assert((carry & ~8191) === 0);
                  };
                  FFTM.prototype.stub = function stub(N) {
                    var ph = new Array(N);
                    for (var i = 0; i < N; i++) {
                      ph[i] = 0;
                    }
                    return ph;
                  };
                  FFTM.prototype.mulp = function mulp(x, y, out) {
                    var N = 2 * this.guessLen13b(x.length, y.length);
                    var rbt = this.makeRBT(N);
                    var _ = this.stub(N);
                    var rws = new Array(N);
                    var rwst = new Array(N);
                    var iwst = new Array(N);
                    var nrws = new Array(N);
                    var nrwst = new Array(N);
                    var niwst = new Array(N);
                    var rmws = out.words;
                    rmws.length = N;
                    this.convert13b(x.words, x.length, rws, N);
                    this.convert13b(y.words, y.length, nrws, N);
                    this.transform(rws, _, rwst, iwst, N, rbt);
                    this.transform(nrws, _, nrwst, niwst, N, rbt);
                    for (var i = 0; i < N; i++) {
                      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
                      rwst[i] = rx;
                    }
                    this.conjugate(rwst, iwst, N);
                    this.transform(rwst, iwst, rmws, _, N, rbt);
                    this.conjugate(rmws, _, N);
                    this.normalize13b(rmws, N);
                    out.negative = x.negative ^ y.negative;
                    out.length = x.length + y.length;
                    return out.strip();
                  };
                  BN.prototype.mul = function mul(num) {
                    var out = new BN(null);
                    out.words = new Array(this.length + num.length);
                    return this.mulTo(num, out);
                  };
                  BN.prototype.mulf = function mulf(num) {
                    var out = new BN(null);
                    out.words = new Array(this.length + num.length);
                    return jumboMulTo(this, num, out);
                  };
                  BN.prototype.imul = function imul(num) {
                    return this.clone().mulTo(num, this);
                  };
                  BN.prototype.imuln = function imuln(num) {
                    assert(typeof num === "number");
                    assert(num < 67108864);
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                      var w = (this.words[i] | 0) * num;
                      var lo = (w & 67108863) + (carry & 67108863);
                      carry >>= 26;
                      carry += w / 67108864 | 0;
                      carry += lo >>> 26;
                      this.words[i] = lo & 67108863;
                    }
                    if (carry !== 0) {
                      this.words[i] = carry;
                      this.length++;
                    }
                    return this;
                  };
                  BN.prototype.muln = function muln(num) {
                    return this.clone().imuln(num);
                  };
                  BN.prototype.sqr = function sqr() {
                    return this.mul(this);
                  };
                  BN.prototype.isqr = function isqr() {
                    return this.imul(this.clone());
                  };
                  BN.prototype.pow = function pow(num) {
                    var w = toBitArray(num);
                    if (w.length === 0)
                      return new BN(1);
                    var res = this;
                    for (var i = 0; i < w.length; i++, res = res.sqr()) {
                      if (w[i] !== 0)
                        break;
                    }
                    if (++i < w.length) {
                      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                        if (w[i] === 0)
                          continue;
                        res = res.mul(q);
                      }
                    }
                    return res;
                  };
                  BN.prototype.iushln = function iushln(bits) {
                    assert(typeof bits === "number" && bits >= 0);
                    var r = bits % 26;
                    var s = (bits - r) / 26;
                    var carryMask = 67108863 >>> 26 - r << 26 - r;
                    var i;
                    if (r !== 0) {
                      var carry = 0;
                      for (i = 0; i < this.length; i++) {
                        var newCarry = this.words[i] & carryMask;
                        var c = (this.words[i] | 0) - newCarry << r;
                        this.words[i] = c | carry;
                        carry = newCarry >>> 26 - r;
                      }
                      if (carry) {
                        this.words[i] = carry;
                        this.length++;
                      }
                    }
                    if (s !== 0) {
                      for (i = this.length - 1; i >= 0; i--) {
                        this.words[i + s] = this.words[i];
                      }
                      for (i = 0; i < s; i++) {
                        this.words[i] = 0;
                      }
                      this.length += s;
                    }
                    return this.strip();
                  };
                  BN.prototype.ishln = function ishln(bits) {
                    assert(this.negative === 0);
                    return this.iushln(bits);
                  };
                  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
                    assert(typeof bits === "number" && bits >= 0);
                    var h;
                    if (hint) {
                      h = (hint - hint % 26) / 26;
                    } else {
                      h = 0;
                    }
                    var r = bits % 26;
                    var s = Math.min((bits - r) / 26, this.length);
                    var mask = 67108863 ^ 67108863 >>> r << r;
                    var maskedWords = extended;
                    h -= s;
                    h = Math.max(0, h);
                    if (maskedWords) {
                      for (var i = 0; i < s; i++) {
                        maskedWords.words[i] = this.words[i];
                      }
                      maskedWords.length = s;
                    }
                    if (s === 0) {
                    } else if (this.length > s) {
                      this.length -= s;
                      for (i = 0; i < this.length; i++) {
                        this.words[i] = this.words[i + s];
                      }
                    } else {
                      this.words[0] = 0;
                      this.length = 1;
                    }
                    var carry = 0;
                    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                      var word = this.words[i] | 0;
                      this.words[i] = carry << 26 - r | word >>> r;
                      carry = word & mask;
                    }
                    if (maskedWords && carry !== 0) {
                      maskedWords.words[maskedWords.length++] = carry;
                    }
                    if (this.length === 0) {
                      this.words[0] = 0;
                      this.length = 1;
                    }
                    return this.strip();
                  };
                  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                    assert(this.negative === 0);
                    return this.iushrn(bits, hint, extended);
                  };
                  BN.prototype.shln = function shln(bits) {
                    return this.clone().ishln(bits);
                  };
                  BN.prototype.ushln = function ushln(bits) {
                    return this.clone().iushln(bits);
                  };
                  BN.prototype.shrn = function shrn(bits) {
                    return this.clone().ishrn(bits);
                  };
                  BN.prototype.ushrn = function ushrn(bits) {
                    return this.clone().iushrn(bits);
                  };
                  BN.prototype.testn = function testn(bit) {
                    assert(typeof bit === "number" && bit >= 0);
                    var r = bit % 26;
                    var s = (bit - r) / 26;
                    var q = 1 << r;
                    if (this.length <= s)
                      return false;
                    var w = this.words[s];
                    return !!(w & q);
                  };
                  BN.prototype.imaskn = function imaskn(bits) {
                    assert(typeof bits === "number" && bits >= 0);
                    var r = bits % 26;
                    var s = (bits - r) / 26;
                    assert(this.negative === 0, "imaskn works only with positive numbers");
                    if (this.length <= s) {
                      return this;
                    }
                    if (r !== 0) {
                      s++;
                    }
                    this.length = Math.min(s, this.length);
                    if (r !== 0) {
                      var mask = 67108863 ^ 67108863 >>> r << r;
                      this.words[this.length - 1] &= mask;
                    }
                    return this.strip();
                  };
                  BN.prototype.maskn = function maskn(bits) {
                    return this.clone().imaskn(bits);
                  };
                  BN.prototype.iaddn = function iaddn(num) {
                    assert(typeof num === "number");
                    assert(num < 67108864);
                    if (num < 0)
                      return this.isubn(-num);
                    if (this.negative !== 0) {
                      if (this.length === 1 && (this.words[0] | 0) < num) {
                        this.words[0] = num - (this.words[0] | 0);
                        this.negative = 0;
                        return this;
                      }
                      this.negative = 0;
                      this.isubn(num);
                      this.negative = 1;
                      return this;
                    }
                    return this._iaddn(num);
                  };
                  BN.prototype._iaddn = function _iaddn(num) {
                    this.words[0] += num;
                    for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
                      this.words[i] -= 67108864;
                      if (i === this.length - 1) {
                        this.words[i + 1] = 1;
                      } else {
                        this.words[i + 1]++;
                      }
                    }
                    this.length = Math.max(this.length, i + 1);
                    return this;
                  };
                  BN.prototype.isubn = function isubn(num) {
                    assert(typeof num === "number");
                    assert(num < 67108864);
                    if (num < 0)
                      return this.iaddn(-num);
                    if (this.negative !== 0) {
                      this.negative = 0;
                      this.iaddn(num);
                      this.negative = 1;
                      return this;
                    }
                    this.words[0] -= num;
                    if (this.length === 1 && this.words[0] < 0) {
                      this.words[0] = -this.words[0];
                      this.negative = 1;
                    } else {
                      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                        this.words[i] += 67108864;
                        this.words[i + 1] -= 1;
                      }
                    }
                    return this.strip();
                  };
                  BN.prototype.addn = function addn(num) {
                    return this.clone().iaddn(num);
                  };
                  BN.prototype.subn = function subn(num) {
                    return this.clone().isubn(num);
                  };
                  BN.prototype.iabs = function iabs() {
                    this.negative = 0;
                    return this;
                  };
                  BN.prototype.abs = function abs() {
                    return this.clone().iabs();
                  };
                  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                    var len = num.length + shift;
                    var i;
                    this._expand(len);
                    var w;
                    var carry = 0;
                    for (i = 0; i < num.length; i++) {
                      w = (this.words[i + shift] | 0) + carry;
                      var right = (num.words[i] | 0) * mul;
                      w -= right & 67108863;
                      carry = (w >> 26) - (right / 67108864 | 0);
                      this.words[i + shift] = w & 67108863;
                    }
                    for (; i < this.length - shift; i++) {
                      w = (this.words[i + shift] | 0) + carry;
                      carry = w >> 26;
                      this.words[i + shift] = w & 67108863;
                    }
                    if (carry === 0)
                      return this.strip();
                    assert(carry === -1);
                    carry = 0;
                    for (i = 0; i < this.length; i++) {
                      w = -(this.words[i] | 0) + carry;
                      carry = w >> 26;
                      this.words[i] = w & 67108863;
                    }
                    this.negative = 1;
                    return this.strip();
                  };
                  BN.prototype._wordDiv = function _wordDiv(num, mode) {
                    var shift = this.length - num.length;
                    var a = this.clone();
                    var b = num;
                    var bhi = b.words[b.length - 1] | 0;
                    var bhiBits = this._countBits(bhi);
                    shift = 26 - bhiBits;
                    if (shift !== 0) {
                      b = b.ushln(shift);
                      a.iushln(shift);
                      bhi = b.words[b.length - 1] | 0;
                    }
                    var m = a.length - b.length;
                    var q;
                    if (mode !== "mod") {
                      q = new BN(null);
                      q.length = m + 1;
                      q.words = new Array(q.length);
                      for (var i = 0; i < q.length; i++) {
                        q.words[i] = 0;
                      }
                    }
                    var diff = a.clone()._ishlnsubmul(b, 1, m);
                    if (diff.negative === 0) {
                      a = diff;
                      if (q) {
                        q.words[m] = 1;
                      }
                    }
                    for (var j = m - 1; j >= 0; j--) {
                      var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
                      qj = Math.min(qj / bhi | 0, 67108863);
                      a._ishlnsubmul(b, qj, j);
                      while (a.negative !== 0) {
                        qj--;
                        a.negative = 0;
                        a._ishlnsubmul(b, 1, j);
                        if (!a.isZero()) {
                          a.negative ^= 1;
                        }
                      }
                      if (q) {
                        q.words[j] = qj;
                      }
                    }
                    if (q) {
                      q.strip();
                    }
                    a.strip();
                    if (mode !== "div" && shift !== 0) {
                      a.iushrn(shift);
                    }
                    return {
                      div: q || null,
                      mod: a
                    };
                  };
                  BN.prototype.divmod = function divmod(num, mode, positive) {
                    assert(!num.isZero());
                    if (this.isZero()) {
                      return {
                        div: new BN(0),
                        mod: new BN(0)
                      };
                    }
                    var div, mod, res;
                    if (this.negative !== 0 && num.negative === 0) {
                      res = this.neg().divmod(num, mode);
                      if (mode !== "mod") {
                        div = res.div.neg();
                      }
                      if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                          mod.iadd(num);
                        }
                      }
                      return {
                        div,
                        mod
                      };
                    }
                    if (this.negative === 0 && num.negative !== 0) {
                      res = this.divmod(num.neg(), mode);
                      if (mode !== "mod") {
                        div = res.div.neg();
                      }
                      return {
                        div,
                        mod: res.mod
                      };
                    }
                    if ((this.negative & num.negative) !== 0) {
                      res = this.neg().divmod(num.neg(), mode);
                      if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                          mod.isub(num);
                        }
                      }
                      return {
                        div: res.div,
                        mod
                      };
                    }
                    if (num.length > this.length || this.cmp(num) < 0) {
                      return {
                        div: new BN(0),
                        mod: this
                      };
                    }
                    if (num.length === 1) {
                      if (mode === "div") {
                        return {
                          div: this.divn(num.words[0]),
                          mod: null
                        };
                      }
                      if (mode === "mod") {
                        return {
                          div: null,
                          mod: new BN(this.modn(num.words[0]))
                        };
                      }
                      return {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                      };
                    }
                    return this._wordDiv(num, mode);
                  };
                  BN.prototype.div = function div(num) {
                    return this.divmod(num, "div", false).div;
                  };
                  BN.prototype.mod = function mod(num) {
                    return this.divmod(num, "mod", false).mod;
                  };
                  BN.prototype.umod = function umod(num) {
                    return this.divmod(num, "mod", true).mod;
                  };
                  BN.prototype.divRound = function divRound(num) {
                    var dm = this.divmod(num);
                    if (dm.mod.isZero())
                      return dm.div;
                    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
                    var half = num.ushrn(1);
                    var r2 = num.andln(1);
                    var cmp = mod.cmp(half);
                    if (cmp < 0 || r2 === 1 && cmp === 0)
                      return dm.div;
                    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
                  };
                  BN.prototype.modn = function modn(num) {
                    assert(num <= 67108863);
                    var p = (1 << 26) % num;
                    var acc = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                      acc = (p * acc + (this.words[i] | 0)) % num;
                    }
                    return acc;
                  };
                  BN.prototype.idivn = function idivn(num) {
                    assert(num <= 67108863);
                    var carry = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                      var w = (this.words[i] | 0) + carry * 67108864;
                      this.words[i] = w / num | 0;
                      carry = w % num;
                    }
                    return this.strip();
                  };
                  BN.prototype.divn = function divn(num) {
                    return this.clone().idivn(num);
                  };
                  BN.prototype.egcd = function egcd(p) {
                    assert(p.negative === 0);
                    assert(!p.isZero());
                    var x = this;
                    var y = p.clone();
                    if (x.negative !== 0) {
                      x = x.umod(p);
                    } else {
                      x = x.clone();
                    }
                    var A = new BN(1);
                    var B = new BN(0);
                    var C = new BN(0);
                    var D = new BN(1);
                    var g = 0;
                    while (x.isEven() && y.isEven()) {
                      x.iushrn(1);
                      y.iushrn(1);
                      ++g;
                    }
                    var yp = y.clone();
                    var xp = x.clone();
                    while (!x.isZero()) {
                      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
                        ;
                      if (i > 0) {
                        x.iushrn(i);
                        while (i-- > 0) {
                          if (A.isOdd() || B.isOdd()) {
                            A.iadd(yp);
                            B.isub(xp);
                          }
                          A.iushrn(1);
                          B.iushrn(1);
                        }
                      }
                      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
                        ;
                      if (j > 0) {
                        y.iushrn(j);
                        while (j-- > 0) {
                          if (C.isOdd() || D.isOdd()) {
                            C.iadd(yp);
                            D.isub(xp);
                          }
                          C.iushrn(1);
                          D.iushrn(1);
                        }
                      }
                      if (x.cmp(y) >= 0) {
                        x.isub(y);
                        A.isub(C);
                        B.isub(D);
                      } else {
                        y.isub(x);
                        C.isub(A);
                        D.isub(B);
                      }
                    }
                    return {
                      a: C,
                      b: D,
                      gcd: y.iushln(g)
                    };
                  };
                  BN.prototype._invmp = function _invmp(p) {
                    assert(p.negative === 0);
                    assert(!p.isZero());
                    var a = this;
                    var b = p.clone();
                    if (a.negative !== 0) {
                      a = a.umod(p);
                    } else {
                      a = a.clone();
                    }
                    var x1 = new BN(1);
                    var x2 = new BN(0);
                    var delta = b.clone();
                    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
                        ;
                      if (i > 0) {
                        a.iushrn(i);
                        while (i-- > 0) {
                          if (x1.isOdd()) {
                            x1.iadd(delta);
                          }
                          x1.iushrn(1);
                        }
                      }
                      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
                        ;
                      if (j > 0) {
                        b.iushrn(j);
                        while (j-- > 0) {
                          if (x2.isOdd()) {
                            x2.iadd(delta);
                          }
                          x2.iushrn(1);
                        }
                      }
                      if (a.cmp(b) >= 0) {
                        a.isub(b);
                        x1.isub(x2);
                      } else {
                        b.isub(a);
                        x2.isub(x1);
                      }
                    }
                    var res;
                    if (a.cmpn(1) === 0) {
                      res = x1;
                    } else {
                      res = x2;
                    }
                    if (res.cmpn(0) < 0) {
                      res.iadd(p);
                    }
                    return res;
                  };
                  BN.prototype.gcd = function gcd(num) {
                    if (this.isZero())
                      return num.abs();
                    if (num.isZero())
                      return this.abs();
                    var a = this.clone();
                    var b = num.clone();
                    a.negative = 0;
                    b.negative = 0;
                    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                      a.iushrn(1);
                      b.iushrn(1);
                    }
                    do {
                      while (a.isEven()) {
                        a.iushrn(1);
                      }
                      while (b.isEven()) {
                        b.iushrn(1);
                      }
                      var r = a.cmp(b);
                      if (r < 0) {
                        var t = a;
                        a = b;
                        b = t;
                      } else if (r === 0 || b.cmpn(1) === 0) {
                        break;
                      }
                      a.isub(b);
                    } while (true);
                    return b.iushln(shift);
                  };
                  BN.prototype.invm = function invm(num) {
                    return this.egcd(num).a.umod(num);
                  };
                  BN.prototype.isEven = function isEven() {
                    return (this.words[0] & 1) === 0;
                  };
                  BN.prototype.isOdd = function isOdd() {
                    return (this.words[0] & 1) === 1;
                  };
                  BN.prototype.andln = function andln(num) {
                    return this.words[0] & num;
                  };
                  BN.prototype.bincn = function bincn(bit) {
                    assert(typeof bit === "number");
                    var r = bit % 26;
                    var s = (bit - r) / 26;
                    var q = 1 << r;
                    if (this.length <= s) {
                      this._expand(s + 1);
                      this.words[s] |= q;
                      return this;
                    }
                    var carry = q;
                    for (var i = s; carry !== 0 && i < this.length; i++) {
                      var w = this.words[i] | 0;
                      w += carry;
                      carry = w >>> 26;
                      w &= 67108863;
                      this.words[i] = w;
                    }
                    if (carry !== 0) {
                      this.words[i] = carry;
                      this.length++;
                    }
                    return this;
                  };
                  BN.prototype.isZero = function isZero() {
                    return this.length === 1 && this.words[0] === 0;
                  };
                  BN.prototype.cmpn = function cmpn(num) {
                    var negative = num < 0;
                    if (this.negative !== 0 && !negative)
                      return -1;
                    if (this.negative === 0 && negative)
                      return 1;
                    this.strip();
                    var res;
                    if (this.length > 1) {
                      res = 1;
                    } else {
                      if (negative) {
                        num = -num;
                      }
                      assert(num <= 67108863, "Number is too big");
                      var w = this.words[0] | 0;
                      res = w === num ? 0 : w < num ? -1 : 1;
                    }
                    if (this.negative !== 0)
                      return -res | 0;
                    return res;
                  };
                  BN.prototype.cmp = function cmp(num) {
                    if (this.negative !== 0 && num.negative === 0)
                      return -1;
                    if (this.negative === 0 && num.negative !== 0)
                      return 1;
                    var res = this.ucmp(num);
                    if (this.negative !== 0)
                      return -res | 0;
                    return res;
                  };
                  BN.prototype.ucmp = function ucmp(num) {
                    if (this.length > num.length)
                      return 1;
                    if (this.length < num.length)
                      return -1;
                    var res = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                      var a = this.words[i] | 0;
                      var b = num.words[i] | 0;
                      if (a === b)
                        continue;
                      if (a < b) {
                        res = -1;
                      } else if (a > b) {
                        res = 1;
                      }
                      break;
                    }
                    return res;
                  };
                  BN.prototype.gtn = function gtn(num) {
                    return this.cmpn(num) === 1;
                  };
                  BN.prototype.gt = function gt(num) {
                    return this.cmp(num) === 1;
                  };
                  BN.prototype.gten = function gten(num) {
                    return this.cmpn(num) >= 0;
                  };
                  BN.prototype.gte = function gte(num) {
                    return this.cmp(num) >= 0;
                  };
                  BN.prototype.ltn = function ltn(num) {
                    return this.cmpn(num) === -1;
                  };
                  BN.prototype.lt = function lt(num) {
                    return this.cmp(num) === -1;
                  };
                  BN.prototype.lten = function lten(num) {
                    return this.cmpn(num) <= 0;
                  };
                  BN.prototype.lte = function lte(num) {
                    return this.cmp(num) <= 0;
                  };
                  BN.prototype.eqn = function eqn(num) {
                    return this.cmpn(num) === 0;
                  };
                  BN.prototype.eq = function eq(num) {
                    return this.cmp(num) === 0;
                  };
                  BN.red = function red(num) {
                    return new Red(num);
                  };
                  BN.prototype.toRed = function toRed(ctx) {
                    assert(!this.red, "Already a number in reduction context");
                    assert(this.negative === 0, "red works only with positives");
                    return ctx.convertTo(this)._forceRed(ctx);
                  };
                  BN.prototype.fromRed = function fromRed() {
                    assert(this.red, "fromRed works only with numbers in reduction context");
                    return this.red.convertFrom(this);
                  };
                  BN.prototype._forceRed = function _forceRed(ctx) {
                    this.red = ctx;
                    return this;
                  };
                  BN.prototype.forceRed = function forceRed(ctx) {
                    assert(!this.red, "Already a number in reduction context");
                    return this._forceRed(ctx);
                  };
                  BN.prototype.redAdd = function redAdd(num) {
                    assert(this.red, "redAdd works only with red numbers");
                    return this.red.add(this, num);
                  };
                  BN.prototype.redIAdd = function redIAdd(num) {
                    assert(this.red, "redIAdd works only with red numbers");
                    return this.red.iadd(this, num);
                  };
                  BN.prototype.redSub = function redSub(num) {
                    assert(this.red, "redSub works only with red numbers");
                    return this.red.sub(this, num);
                  };
                  BN.prototype.redISub = function redISub(num) {
                    assert(this.red, "redISub works only with red numbers");
                    return this.red.isub(this, num);
                  };
                  BN.prototype.redShl = function redShl(num) {
                    assert(this.red, "redShl works only with red numbers");
                    return this.red.shl(this, num);
                  };
                  BN.prototype.redMul = function redMul(num) {
                    assert(this.red, "redMul works only with red numbers");
                    this.red._verify2(this, num);
                    return this.red.mul(this, num);
                  };
                  BN.prototype.redIMul = function redIMul(num) {
                    assert(this.red, "redMul works only with red numbers");
                    this.red._verify2(this, num);
                    return this.red.imul(this, num);
                  };
                  BN.prototype.redSqr = function redSqr() {
                    assert(this.red, "redSqr works only with red numbers");
                    this.red._verify1(this);
                    return this.red.sqr(this);
                  };
                  BN.prototype.redISqr = function redISqr() {
                    assert(this.red, "redISqr works only with red numbers");
                    this.red._verify1(this);
                    return this.red.isqr(this);
                  };
                  BN.prototype.redSqrt = function redSqrt() {
                    assert(this.red, "redSqrt works only with red numbers");
                    this.red._verify1(this);
                    return this.red.sqrt(this);
                  };
                  BN.prototype.redInvm = function redInvm() {
                    assert(this.red, "redInvm works only with red numbers");
                    this.red._verify1(this);
                    return this.red.invm(this);
                  };
                  BN.prototype.redNeg = function redNeg() {
                    assert(this.red, "redNeg works only with red numbers");
                    this.red._verify1(this);
                    return this.red.neg(this);
                  };
                  BN.prototype.redPow = function redPow(num) {
                    assert(this.red && !num.red, "redPow(normalNum)");
                    this.red._verify1(this);
                    return this.red.pow(this, num);
                  };
                  var primes = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                  };
                  function MPrime(name2, p) {
                    this.name = name2;
                    this.p = new BN(p, 16);
                    this.n = this.p.bitLength();
                    this.k = new BN(1).iushln(this.n).isub(this.p);
                    this.tmp = this._tmp();
                  }
                  MPrime.prototype._tmp = function _tmp() {
                    var tmp = new BN(null);
                    tmp.words = new Array(Math.ceil(this.n / 13));
                    return tmp;
                  };
                  MPrime.prototype.ireduce = function ireduce(num) {
                    var r = num;
                    var rlen;
                    do {
                      this.split(r, this.tmp);
                      r = this.imulK(r);
                      r = r.iadd(this.tmp);
                      rlen = r.bitLength();
                    } while (rlen > this.n);
                    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                    if (cmp === 0) {
                      r.words[0] = 0;
                      r.length = 1;
                    } else if (cmp > 0) {
                      r.isub(this.p);
                    } else {
                      if (r.strip !== void 0) {
                        r.strip();
                      } else {
                        r._strip();
                      }
                    }
                    return r;
                  };
                  MPrime.prototype.split = function split(input, out) {
                    input.iushrn(this.n, 0, out);
                  };
                  MPrime.prototype.imulK = function imulK(num) {
                    return num.imul(this.k);
                  };
                  function K256() {
                    MPrime.call(
                      this,
                      "k256",
                      "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
                    );
                  }
                  inherits(K256, MPrime);
                  K256.prototype.split = function split(input, output) {
                    var mask = 4194303;
                    var outLen = Math.min(input.length, 9);
                    for (var i = 0; i < outLen; i++) {
                      output.words[i] = input.words[i];
                    }
                    output.length = outLen;
                    if (input.length <= 9) {
                      input.words[0] = 0;
                      input.length = 1;
                      return;
                    }
                    var prev = input.words[9];
                    output.words[output.length++] = prev & mask;
                    for (i = 10; i < input.length; i++) {
                      var next = input.words[i] | 0;
                      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
                      prev = next;
                    }
                    prev >>>= 22;
                    input.words[i - 10] = prev;
                    if (prev === 0 && input.length > 10) {
                      input.length -= 10;
                    } else {
                      input.length -= 9;
                    }
                  };
                  K256.prototype.imulK = function imulK(num) {
                    num.words[num.length] = 0;
                    num.words[num.length + 1] = 0;
                    num.length += 2;
                    var lo = 0;
                    for (var i = 0; i < num.length; i++) {
                      var w = num.words[i] | 0;
                      lo += w * 977;
                      num.words[i] = lo & 67108863;
                      lo = w * 64 + (lo / 67108864 | 0);
                    }
                    if (num.words[num.length - 1] === 0) {
                      num.length--;
                      if (num.words[num.length - 1] === 0) {
                        num.length--;
                      }
                    }
                    return num;
                  };
                  function P224() {
                    MPrime.call(
                      this,
                      "p224",
                      "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
                    );
                  }
                  inherits(P224, MPrime);
                  function P192() {
                    MPrime.call(
                      this,
                      "p192",
                      "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
                    );
                  }
                  inherits(P192, MPrime);
                  function P25519() {
                    MPrime.call(
                      this,
                      "25519",
                      "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
                    );
                  }
                  inherits(P25519, MPrime);
                  P25519.prototype.imulK = function imulK(num) {
                    var carry = 0;
                    for (var i = 0; i < num.length; i++) {
                      var hi = (num.words[i] | 0) * 19 + carry;
                      var lo = hi & 67108863;
                      hi >>>= 26;
                      num.words[i] = lo;
                      carry = hi;
                    }
                    if (carry !== 0) {
                      num.words[num.length++] = carry;
                    }
                    return num;
                  };
                  BN._prime = function prime(name2) {
                    if (primes[name2])
                      return primes[name2];
                    var prime2;
                    if (name2 === "k256") {
                      prime2 = new K256();
                    } else if (name2 === "p224") {
                      prime2 = new P224();
                    } else if (name2 === "p192") {
                      prime2 = new P192();
                    } else if (name2 === "p25519") {
                      prime2 = new P25519();
                    } else {
                      throw new Error("Unknown prime " + name2);
                    }
                    primes[name2] = prime2;
                    return prime2;
                  };
                  function Red(m) {
                    if (typeof m === "string") {
                      var prime = BN._prime(m);
                      this.m = prime.p;
                      this.prime = prime;
                    } else {
                      assert(m.gtn(1), "modulus must be greater than 1");
                      this.m = m;
                      this.prime = null;
                    }
                  }
                  Red.prototype._verify1 = function _verify1(a) {
                    assert(a.negative === 0, "red works only with positives");
                    assert(a.red, "red works only with red numbers");
                  };
                  Red.prototype._verify2 = function _verify2(a, b) {
                    assert((a.negative | b.negative) === 0, "red works only with positives");
                    assert(
                      a.red && a.red === b.red,
                      "red works only with red numbers"
                    );
                  };
                  Red.prototype.imod = function imod(a) {
                    if (this.prime)
                      return this.prime.ireduce(a)._forceRed(this);
                    return a.umod(this.m)._forceRed(this);
                  };
                  Red.prototype.neg = function neg(a) {
                    if (a.isZero()) {
                      return a.clone();
                    }
                    return this.m.sub(a)._forceRed(this);
                  };
                  Red.prototype.add = function add(a, b) {
                    this._verify2(a, b);
                    var res = a.add(b);
                    if (res.cmp(this.m) >= 0) {
                      res.isub(this.m);
                    }
                    return res._forceRed(this);
                  };
                  Red.prototype.iadd = function iadd(a, b) {
                    this._verify2(a, b);
                    var res = a.iadd(b);
                    if (res.cmp(this.m) >= 0) {
                      res.isub(this.m);
                    }
                    return res;
                  };
                  Red.prototype.sub = function sub(a, b) {
                    this._verify2(a, b);
                    var res = a.sub(b);
                    if (res.cmpn(0) < 0) {
                      res.iadd(this.m);
                    }
                    return res._forceRed(this);
                  };
                  Red.prototype.isub = function isub(a, b) {
                    this._verify2(a, b);
                    var res = a.isub(b);
                    if (res.cmpn(0) < 0) {
                      res.iadd(this.m);
                    }
                    return res;
                  };
                  Red.prototype.shl = function shl(a, num) {
                    this._verify1(a);
                    return this.imod(a.ushln(num));
                  };
                  Red.prototype.imul = function imul(a, b) {
                    this._verify2(a, b);
                    return this.imod(a.imul(b));
                  };
                  Red.prototype.mul = function mul(a, b) {
                    this._verify2(a, b);
                    return this.imod(a.mul(b));
                  };
                  Red.prototype.isqr = function isqr(a) {
                    return this.imul(a, a.clone());
                  };
                  Red.prototype.sqr = function sqr(a) {
                    return this.mul(a, a);
                  };
                  Red.prototype.sqrt = function sqrt(a) {
                    if (a.isZero())
                      return a.clone();
                    var mod3 = this.m.andln(3);
                    assert(mod3 % 2 === 1);
                    if (mod3 === 3) {
                      var pow = this.m.add(new BN(1)).iushrn(2);
                      return this.pow(a, pow);
                    }
                    var q = this.m.subn(1);
                    var s = 0;
                    while (!q.isZero() && q.andln(1) === 0) {
                      s++;
                      q.iushrn(1);
                    }
                    assert(!q.isZero());
                    var one = new BN(1).toRed(this);
                    var nOne = one.redNeg();
                    var lpow = this.m.subn(1).iushrn(1);
                    var z = this.m.bitLength();
                    z = new BN(2 * z * z).toRed(this);
                    while (this.pow(z, lpow).cmp(nOne) !== 0) {
                      z.redIAdd(nOne);
                    }
                    var c = this.pow(z, q);
                    var r = this.pow(a, q.addn(1).iushrn(1));
                    var t = this.pow(a, q);
                    var m = s;
                    while (t.cmp(one) !== 0) {
                      var tmp = t;
                      for (var i = 0; tmp.cmp(one) !== 0; i++) {
                        tmp = tmp.redSqr();
                      }
                      assert(i < m);
                      var b = this.pow(c, new BN(1).iushln(m - i - 1));
                      r = r.redMul(b);
                      c = b.redSqr();
                      t = t.redMul(c);
                      m = i;
                    }
                    return r;
                  };
                  Red.prototype.invm = function invm(a) {
                    var inv = a._invmp(this.m);
                    if (inv.negative !== 0) {
                      inv.negative = 0;
                      return this.imod(inv).redNeg();
                    } else {
                      return this.imod(inv);
                    }
                  };
                  Red.prototype.pow = function pow(a, num) {
                    if (num.isZero())
                      return new BN(1).toRed(this);
                    if (num.cmpn(1) === 0)
                      return a.clone();
                    var windowSize = 4;
                    var wnd = new Array(1 << windowSize);
                    wnd[0] = new BN(1).toRed(this);
                    wnd[1] = a;
                    for (var i = 2; i < wnd.length; i++) {
                      wnd[i] = this.mul(wnd[i - 1], a);
                    }
                    var res = wnd[0];
                    var current = 0;
                    var currentLen = 0;
                    var start = num.bitLength() % 26;
                    if (start === 0) {
                      start = 26;
                    }
                    for (i = num.length - 1; i >= 0; i--) {
                      var word = num.words[i];
                      for (var j = start - 1; j >= 0; j--) {
                        var bit = word >> j & 1;
                        if (res !== wnd[0]) {
                          res = this.sqr(res);
                        }
                        if (bit === 0 && current === 0) {
                          currentLen = 0;
                          continue;
                        }
                        current <<= 1;
                        current |= bit;
                        currentLen++;
                        if (currentLen !== windowSize && (i !== 0 || j !== 0))
                          continue;
                        res = this.mul(res, wnd[current]);
                        currentLen = 0;
                        current = 0;
                      }
                      start = 26;
                    }
                    return res;
                  };
                  Red.prototype.convertTo = function convertTo(num) {
                    var r = num.umod(this.m);
                    return r === num ? r.clone() : r;
                  };
                  Red.prototype.convertFrom = function convertFrom(num) {
                    var res = num.clone();
                    res.red = null;
                    return res;
                  };
                  BN.mont = function mont(num) {
                    return new Mont(num);
                  };
                  function Mont(m) {
                    Red.call(this, m);
                    this.shift = this.m.bitLength();
                    if (this.shift % 26 !== 0) {
                      this.shift += 26 - this.shift % 26;
                    }
                    this.r = new BN(1).iushln(this.shift);
                    this.r2 = this.imod(this.r.sqr());
                    this.rinv = this.r._invmp(this.m);
                    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                    this.minv = this.minv.umod(this.r);
                    this.minv = this.r.sub(this.minv);
                  }
                  inherits(Mont, Red);
                  Mont.prototype.convertTo = function convertTo(num) {
                    return this.imod(num.ushln(this.shift));
                  };
                  Mont.prototype.convertFrom = function convertFrom(num) {
                    var r = this.imod(num.mul(this.rinv));
                    r.red = null;
                    return r;
                  };
                  Mont.prototype.imul = function imul(a, b) {
                    if (a.isZero() || b.isZero()) {
                      a.words[0] = 0;
                      a.length = 1;
                      return a;
                    }
                    var t = a.imul(b);
                    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                    var u = t.isub(c).iushrn(this.shift);
                    var res = u;
                    if (u.cmp(this.m) >= 0) {
                      res = u.isub(this.m);
                    } else if (u.cmpn(0) < 0) {
                      res = u.iadd(this.m);
                    }
                    return res._forceRed(this);
                  };
                  Mont.prototype.mul = function mul(a, b) {
                    if (a.isZero() || b.isZero())
                      return new BN(0)._forceRed(this);
                    var t = a.mul(b);
                    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                    var u = t.isub(c).iushrn(this.shift);
                    var res = u;
                    if (u.cmp(this.m) >= 0) {
                      res = u.isub(this.m);
                    } else if (u.cmpn(0) < 0) {
                      res = u.iadd(this.m);
                    }
                    return res._forceRed(this);
                  };
                  Mont.prototype.invm = function invm(a) {
                    var res = this.imod(a._invmp(this.m).mul(this.r2));
                    return res._forceRed(this);
                  };
                })(module2, this);
              }
            ),
            /***/
            747: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                (function() {
                  "use strict";
                  var root = typeof window === "object" ? window : {};
                  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
                  if (NODE_JS) {
                    root = __webpack_require__2.g;
                  }
                  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module2.exports;
                  var HEX_CHARS = "0123456789abcdef".split("");
                  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
                  var KECCAK_PADDING = [1, 256, 65536, 16777216];
                  var PADDING = [6, 1536, 393216, 100663296];
                  var SHIFT = [0, 8, 16, 24];
                  var RC = [
                    1,
                    0,
                    32898,
                    0,
                    32906,
                    2147483648,
                    2147516416,
                    2147483648,
                    32907,
                    0,
                    2147483649,
                    0,
                    2147516545,
                    2147483648,
                    32777,
                    2147483648,
                    138,
                    0,
                    136,
                    0,
                    2147516425,
                    0,
                    2147483658,
                    0,
                    2147516555,
                    0,
                    139,
                    2147483648,
                    32905,
                    2147483648,
                    32771,
                    2147483648,
                    32770,
                    2147483648,
                    128,
                    2147483648,
                    32778,
                    0,
                    2147483658,
                    2147483648,
                    2147516545,
                    2147483648,
                    32896,
                    2147483648,
                    2147483649,
                    0,
                    2147516424,
                    2147483648
                  ];
                  var BITS = [224, 256, 384, 512];
                  var SHAKE_BITS = [128, 256];
                  var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array"];
                  var createOutputMethod = function(bits2, padding, outputType) {
                    return function(message) {
                      return new Keccak(bits2, padding, bits2).update(message)[outputType]();
                    };
                  };
                  var createShakeOutputMethod = function(bits2, padding, outputType) {
                    return function(message, outputBits) {
                      return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
                    };
                  };
                  var createMethod = function(bits2, padding) {
                    var method = createOutputMethod(bits2, padding, "hex");
                    method.create = function() {
                      return new Keccak(bits2, padding, bits2);
                    };
                    method.update = function(message) {
                      return method.create().update(message);
                    };
                    for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
                      var type = OUTPUT_TYPES[i2];
                      method[type] = createOutputMethod(bits2, padding, type);
                    }
                    return method;
                  };
                  var createShakeMethod = function(bits2, padding) {
                    var method = createShakeOutputMethod(bits2, padding, "hex");
                    method.create = function(outputBits) {
                      return new Keccak(bits2, padding, outputBits);
                    };
                    method.update = function(message, outputBits) {
                      return method.create(outputBits).update(message);
                    };
                    for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
                      var type = OUTPUT_TYPES[i2];
                      method[type] = createShakeOutputMethod(bits2, padding, type);
                    }
                    return method;
                  };
                  var algorithms = [
                    { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
                    { name: "sha3", padding: PADDING, bits: BITS, createMethod },
                    { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod }
                  ];
                  var methods = {}, methodNames = [];
                  for (var i = 0; i < algorithms.length; ++i) {
                    var algorithm = algorithms[i];
                    var bits = algorithm.bits;
                    for (var j = 0; j < bits.length; ++j) {
                      var methodName = algorithm.name + "_" + bits[j];
                      methodNames.push(methodName);
                      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
                    }
                  }
                  function Keccak(bits2, padding, outputBits) {
                    this.blocks = [];
                    this.s = [];
                    this.padding = padding;
                    this.outputBits = outputBits;
                    this.reset = true;
                    this.block = 0;
                    this.start = 0;
                    this.blockCount = 1600 - (bits2 << 1) >> 5;
                    this.byteCount = this.blockCount << 2;
                    this.outputBlocks = outputBits >> 5;
                    this.extraBytes = (outputBits & 31) >> 3;
                    for (var i2 = 0; i2 < 50; ++i2) {
                      this.s[i2] = 0;
                    }
                  }
                  Keccak.prototype.update = function(message) {
                    var notString = typeof message !== "string";
                    if (notString && message.constructor === ArrayBuffer) {
                      message = new Uint8Array(message);
                    }
                    var length = message.length, blocks = this.blocks, byteCount = this.byteCount, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
                    while (index < length) {
                      if (this.reset) {
                        this.reset = false;
                        blocks[0] = this.block;
                        for (i2 = 1; i2 < blockCount + 1; ++i2) {
                          blocks[i2] = 0;
                        }
                      }
                      if (notString) {
                        for (i2 = this.start; index < length && i2 < byteCount; ++index) {
                          blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
                        }
                      } else {
                        for (i2 = this.start; index < length && i2 < byteCount; ++index) {
                          code = message.charCodeAt(index);
                          if (code < 128) {
                            blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
                          } else if (code < 2048) {
                            blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                            blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                          } else if (code < 55296 || code >= 57344) {
                            blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                            blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                            blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                          } else {
                            code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                            blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                            blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                            blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                            blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                          }
                        }
                      }
                      this.lastByteIndex = i2;
                      if (i2 >= byteCount) {
                        this.start = i2 - byteCount;
                        this.block = blocks[blockCount];
                        for (i2 = 0; i2 < blockCount; ++i2) {
                          s[i2] ^= blocks[i2];
                        }
                        f(s);
                        this.reset = true;
                      } else {
                        this.start = i2;
                      }
                    }
                    return this;
                  };
                  Keccak.prototype.finalize = function() {
                    var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
                    blocks[i2 >> 2] |= this.padding[i2 & 3];
                    if (this.lastByteIndex === this.byteCount) {
                      blocks[0] = blocks[blockCount];
                      for (i2 = 1; i2 < blockCount + 1; ++i2) {
                        blocks[i2] = 0;
                      }
                    }
                    blocks[blockCount - 1] |= 2147483648;
                    for (i2 = 0; i2 < blockCount; ++i2) {
                      s[i2] ^= blocks[i2];
                    }
                    f(s);
                  };
                  Keccak.prototype.toString = Keccak.prototype.hex = function() {
                    this.finalize();
                    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
                    var hex = "", block;
                    while (j2 < outputBlocks) {
                      for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
                        block = s[i2];
                        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
                      }
                      if (j2 % blockCount === 0) {
                        f(s);
                        i2 = 0;
                      }
                    }
                    if (extraBytes) {
                      block = s[i2];
                      if (extraBytes > 0) {
                        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
                      }
                      if (extraBytes > 1) {
                        hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
                      }
                      if (extraBytes > 2) {
                        hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
                      }
                    }
                    return hex;
                  };
                  Keccak.prototype.arrayBuffer = function() {
                    this.finalize();
                    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
                    var bytes = this.outputBits >> 3;
                    var buffer;
                    if (extraBytes) {
                      buffer = new ArrayBuffer(outputBlocks + 1 << 2);
                    } else {
                      buffer = new ArrayBuffer(bytes);
                    }
                    var array = new Uint32Array(buffer);
                    while (j2 < outputBlocks) {
                      for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
                        array[j2] = s[i2];
                      }
                      if (j2 % blockCount === 0) {
                        f(s);
                      }
                    }
                    if (extraBytes) {
                      array[i2] = s[i2];
                      buffer = buffer.slice(0, bytes);
                    }
                    return buffer;
                  };
                  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
                  Keccak.prototype.digest = Keccak.prototype.array = function() {
                    this.finalize();
                    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
                    var array = [], offset, block;
                    while (j2 < outputBlocks) {
                      for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
                        offset = j2 << 2;
                        block = s[i2];
                        array[offset] = block & 255;
                        array[offset + 1] = block >> 8 & 255;
                        array[offset + 2] = block >> 16 & 255;
                        array[offset + 3] = block >> 24 & 255;
                      }
                      if (j2 % blockCount === 0) {
                        f(s);
                      }
                    }
                    if (extraBytes) {
                      offset = j2 << 2;
                      block = s[i2];
                      if (extraBytes > 0) {
                        array[offset] = block & 255;
                      }
                      if (extraBytes > 1) {
                        array[offset + 1] = block >> 8 & 255;
                      }
                      if (extraBytes > 2) {
                        array[offset + 2] = block >> 16 & 255;
                      }
                    }
                    return array;
                  };
                  var f = function(s) {
                    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
                    for (n = 0; n < 48; n += 2) {
                      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
                      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
                      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
                      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
                      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
                      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
                      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
                      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
                      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
                      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
                      h = c8 ^ (c2 << 1 | c3 >>> 31);
                      l = c9 ^ (c3 << 1 | c2 >>> 31);
                      s[0] ^= h;
                      s[1] ^= l;
                      s[10] ^= h;
                      s[11] ^= l;
                      s[20] ^= h;
                      s[21] ^= l;
                      s[30] ^= h;
                      s[31] ^= l;
                      s[40] ^= h;
                      s[41] ^= l;
                      h = c0 ^ (c4 << 1 | c5 >>> 31);
                      l = c1 ^ (c5 << 1 | c4 >>> 31);
                      s[2] ^= h;
                      s[3] ^= l;
                      s[12] ^= h;
                      s[13] ^= l;
                      s[22] ^= h;
                      s[23] ^= l;
                      s[32] ^= h;
                      s[33] ^= l;
                      s[42] ^= h;
                      s[43] ^= l;
                      h = c2 ^ (c6 << 1 | c7 >>> 31);
                      l = c3 ^ (c7 << 1 | c6 >>> 31);
                      s[4] ^= h;
                      s[5] ^= l;
                      s[14] ^= h;
                      s[15] ^= l;
                      s[24] ^= h;
                      s[25] ^= l;
                      s[34] ^= h;
                      s[35] ^= l;
                      s[44] ^= h;
                      s[45] ^= l;
                      h = c4 ^ (c8 << 1 | c9 >>> 31);
                      l = c5 ^ (c9 << 1 | c8 >>> 31);
                      s[6] ^= h;
                      s[7] ^= l;
                      s[16] ^= h;
                      s[17] ^= l;
                      s[26] ^= h;
                      s[27] ^= l;
                      s[36] ^= h;
                      s[37] ^= l;
                      s[46] ^= h;
                      s[47] ^= l;
                      h = c6 ^ (c0 << 1 | c1 >>> 31);
                      l = c7 ^ (c1 << 1 | c0 >>> 31);
                      s[8] ^= h;
                      s[9] ^= l;
                      s[18] ^= h;
                      s[19] ^= l;
                      s[28] ^= h;
                      s[29] ^= l;
                      s[38] ^= h;
                      s[39] ^= l;
                      s[48] ^= h;
                      s[49] ^= l;
                      b0 = s[0];
                      b1 = s[1];
                      b32 = s[11] << 4 | s[10] >>> 28;
                      b33 = s[10] << 4 | s[11] >>> 28;
                      b14 = s[20] << 3 | s[21] >>> 29;
                      b15 = s[21] << 3 | s[20] >>> 29;
                      b46 = s[31] << 9 | s[30] >>> 23;
                      b47 = s[30] << 9 | s[31] >>> 23;
                      b28 = s[40] << 18 | s[41] >>> 14;
                      b29 = s[41] << 18 | s[40] >>> 14;
                      b20 = s[2] << 1 | s[3] >>> 31;
                      b21 = s[3] << 1 | s[2] >>> 31;
                      b2 = s[13] << 12 | s[12] >>> 20;
                      b3 = s[12] << 12 | s[13] >>> 20;
                      b34 = s[22] << 10 | s[23] >>> 22;
                      b35 = s[23] << 10 | s[22] >>> 22;
                      b16 = s[33] << 13 | s[32] >>> 19;
                      b17 = s[32] << 13 | s[33] >>> 19;
                      b48 = s[42] << 2 | s[43] >>> 30;
                      b49 = s[43] << 2 | s[42] >>> 30;
                      b40 = s[5] << 30 | s[4] >>> 2;
                      b41 = s[4] << 30 | s[5] >>> 2;
                      b22 = s[14] << 6 | s[15] >>> 26;
                      b23 = s[15] << 6 | s[14] >>> 26;
                      b4 = s[25] << 11 | s[24] >>> 21;
                      b5 = s[24] << 11 | s[25] >>> 21;
                      b36 = s[34] << 15 | s[35] >>> 17;
                      b37 = s[35] << 15 | s[34] >>> 17;
                      b18 = s[45] << 29 | s[44] >>> 3;
                      b19 = s[44] << 29 | s[45] >>> 3;
                      b10 = s[6] << 28 | s[7] >>> 4;
                      b11 = s[7] << 28 | s[6] >>> 4;
                      b42 = s[17] << 23 | s[16] >>> 9;
                      b43 = s[16] << 23 | s[17] >>> 9;
                      b24 = s[26] << 25 | s[27] >>> 7;
                      b25 = s[27] << 25 | s[26] >>> 7;
                      b6 = s[36] << 21 | s[37] >>> 11;
                      b7 = s[37] << 21 | s[36] >>> 11;
                      b38 = s[47] << 24 | s[46] >>> 8;
                      b39 = s[46] << 24 | s[47] >>> 8;
                      b30 = s[8] << 27 | s[9] >>> 5;
                      b31 = s[9] << 27 | s[8] >>> 5;
                      b12 = s[18] << 20 | s[19] >>> 12;
                      b13 = s[19] << 20 | s[18] >>> 12;
                      b44 = s[29] << 7 | s[28] >>> 25;
                      b45 = s[28] << 7 | s[29] >>> 25;
                      b26 = s[38] << 8 | s[39] >>> 24;
                      b27 = s[39] << 8 | s[38] >>> 24;
                      b8 = s[48] << 14 | s[49] >>> 18;
                      b9 = s[49] << 14 | s[48] >>> 18;
                      s[0] = b0 ^ ~b2 & b4;
                      s[1] = b1 ^ ~b3 & b5;
                      s[10] = b10 ^ ~b12 & b14;
                      s[11] = b11 ^ ~b13 & b15;
                      s[20] = b20 ^ ~b22 & b24;
                      s[21] = b21 ^ ~b23 & b25;
                      s[30] = b30 ^ ~b32 & b34;
                      s[31] = b31 ^ ~b33 & b35;
                      s[40] = b40 ^ ~b42 & b44;
                      s[41] = b41 ^ ~b43 & b45;
                      s[2] = b2 ^ ~b4 & b6;
                      s[3] = b3 ^ ~b5 & b7;
                      s[12] = b12 ^ ~b14 & b16;
                      s[13] = b13 ^ ~b15 & b17;
                      s[22] = b22 ^ ~b24 & b26;
                      s[23] = b23 ^ ~b25 & b27;
                      s[32] = b32 ^ ~b34 & b36;
                      s[33] = b33 ^ ~b35 & b37;
                      s[42] = b42 ^ ~b44 & b46;
                      s[43] = b43 ^ ~b45 & b47;
                      s[4] = b4 ^ ~b6 & b8;
                      s[5] = b5 ^ ~b7 & b9;
                      s[14] = b14 ^ ~b16 & b18;
                      s[15] = b15 ^ ~b17 & b19;
                      s[24] = b24 ^ ~b26 & b28;
                      s[25] = b25 ^ ~b27 & b29;
                      s[34] = b34 ^ ~b36 & b38;
                      s[35] = b35 ^ ~b37 & b39;
                      s[44] = b44 ^ ~b46 & b48;
                      s[45] = b45 ^ ~b47 & b49;
                      s[6] = b6 ^ ~b8 & b0;
                      s[7] = b7 ^ ~b9 & b1;
                      s[16] = b16 ^ ~b18 & b10;
                      s[17] = b17 ^ ~b19 & b11;
                      s[26] = b26 ^ ~b28 & b20;
                      s[27] = b27 ^ ~b29 & b21;
                      s[36] = b36 ^ ~b38 & b30;
                      s[37] = b37 ^ ~b39 & b31;
                      s[46] = b46 ^ ~b48 & b40;
                      s[47] = b47 ^ ~b49 & b41;
                      s[8] = b8 ^ ~b0 & b2;
                      s[9] = b9 ^ ~b1 & b3;
                      s[18] = b18 ^ ~b10 & b12;
                      s[19] = b19 ^ ~b11 & b13;
                      s[28] = b28 ^ ~b20 & b22;
                      s[29] = b29 ^ ~b21 & b23;
                      s[38] = b38 ^ ~b30 & b32;
                      s[39] = b39 ^ ~b31 & b33;
                      s[48] = b48 ^ ~b40 & b42;
                      s[49] = b49 ^ ~b41 & b43;
                      s[0] ^= RC[n];
                      s[1] ^= RC[n + 1];
                    }
                  };
                  if (COMMON_JS) {
                    module2.exports = methods;
                  } else {
                    for (var i = 0; i < methodNames.length; ++i) {
                      root[methodNames[i]] = methods[methodNames[i]];
                    }
                  }
                })();
              }
            ),
            /***/
            6462: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                var __webpack_unused_export__;
                __webpack_unused_export__ = { value: true };
                function optional(scheme) {
                  return (value, context) => {
                    if (value !== void 0) {
                      validate(value, scheme, context);
                    }
                    return "";
                  };
                }
                exports2.jt = optional;
                function nullable(scheme) {
                  return (value, context) => {
                    if (value !== null) {
                      validate(value, scheme, context);
                    }
                    return "";
                  };
                }
                exports2.AG = nullable;
                class Validator {
                  constructor(scheme) {
                    this.scheme = scheme;
                  }
                  test(value, context) {
                    return validate(value, this.scheme, context);
                  }
                }
                __webpack_unused_export__ = Validator;
                class ValidationError extends Error {
                  constructor(rawMessage, context) {
                    super(context ? `${context}: ${rawMessage}` : rawMessage);
                    this.rawMessage = rawMessage;
                    this.context = context;
                  }
                }
                exports2.p8 = ValidationError;
                ValidationError.prototype.name = "ValidationError";
                function validate(value, scheme, context) {
                  if (Array.isArray(scheme)) {
                    if (!Array.isArray(value)) {
                      throw new ValidationError("expected array", context || "");
                    }
                    value.forEach((el, i) => validate(el, scheme[0], context ? `${context}.#${i}` : `#${i}`));
                  } else if (scheme instanceof Function) {
                    const errMsg = scheme(value, context);
                    if (errMsg) {
                      throw new ValidationError(errMsg, context || "");
                    }
                  } else {
                    if (!(value instanceof Object)) {
                      throw new ValidationError("expected object", context || "");
                    }
                    for (const key in scheme) {
                      if (scheme.hasOwnProperty(key)) {
                        validate(value[key], scheme[key], context ? `${context}.${key}` : key);
                      }
                    }
                  }
                  return value;
                }
                exports2.Gu = validate;
              }
            ),
            /***/
            2574: (
              /***/
              () => {
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            if (__webpack_module_cache__[moduleId]) {
              return __webpack_module_cache__[moduleId].exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              id: moduleId,
              /******/
              loaded: false,
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          (() => {
            __webpack_require__.n = (module2) => {
              var getter = module2 && module2.__esModule ? (
                /******/
                () => module2["default"]
              ) : (
                /******/
                () => module2
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object")
                return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object")
                  return window;
              }
            }();
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          (() => {
            __webpack_require__.nmd = (module2) => {
              module2.paths = [];
              if (!module2.children)
                module2.children = [];
              return module2;
            };
          })();
          return __webpack_require__(280);
        })()
      );
    });
  }
});

export {
  require_connex
};
/*! Bundled license information:

@vechain/connex/dist/connex.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! https://mths.be/punycode v1.3.2 by @mathias *)
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.5.7
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2016
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-VDGIGSMB.js.map
