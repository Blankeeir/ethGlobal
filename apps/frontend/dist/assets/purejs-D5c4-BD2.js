import{u as se,d as ce}from"./index-CIt7NACa.js";function zt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function fe(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function mt(t,...n){if(!fe(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error(`Uint8Array expected of length ${n}, not of length=${t.length}`)}function ue(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");zt(t.outputLen),zt(t.blockLen)}function bt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function ae(t,n){mt(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const ft=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Y=(t,n)=>t<<32-n|t>>>n;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function le(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function qt(t){return typeof t=="string"&&(t=le(t)),mt(t),t}function de(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];mt(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}class Pt{clone(){return this._cloneInto()}}function he(t){const n=r=>t().update(qt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function ge(t=32){if(ft&&typeof ft.getRandomValues=="function")return ft.getRandomValues(new Uint8Array(t));if(ft&&typeof ft.randomBytes=="function")return ft.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function we(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const s=BigInt(32),o=BigInt(4294967295),f=Number(e>>s&o),c=Number(e&o),i=r?4:0,a=r?0:4;t.setUint32(n+i,f,r),t.setUint32(n+a,c,r)}const ye=(t,n,e)=>t&n^~t&e,pe=(t,n,e)=>t&n^t&e^n&e;class be extends Pt{constructor(n,e,r,s){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=vt(this.buffer)}update(n){bt(this);const{view:e,buffer:r,blockLen:s}=this;n=qt(n);const o=n.length;for(let f=0;f<o;){const c=Math.min(s-this.pos,o-f);if(c===s){const i=vt(n);for(;s<=o-f;f+=s)this.process(i,f);continue}r.set(n.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){bt(this),ae(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(r,0),f=0);for(let h=f;h<s;h++)e[h]=0;we(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=vt(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=i/4,m=this.get();if(a>m.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<a;h++)c.setUint32(4*h,m[h],o)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:f,pos:c}=this;return n.length=s,n.pos=c,n.finished=o,n.destroyed=f,s%e&&n.buffer.set(r),n}}const me=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Q=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=new Uint32Array(64);class Ee extends be{constructor(){super(64,32,8,!1),this.A=Q[0]|0,this.B=Q[1]|0,this.C=Q[2]|0,this.D=Q[3]|0,this.E=Q[4]|0,this.F=Q[5]|0,this.G=Q[6]|0,this.H=Q[7]|0}get(){const{A:n,B:e,C:r,D:s,E:o,F:f,G:c,H:i}=this;return[n,e,r,s,o,f,c,i]}set(n,e,r,s,o,f,c,i){this.A=n|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=f|0,this.G=c|0,this.H=i|0}process(n,e){for(let h=0;h<16;h++,e+=4)J[h]=n.getUint32(e,!1);for(let h=16;h<64;h++){const l=J[h-15],I=J[h-2],U=Y(l,7)^Y(l,18)^l>>>3,p=Y(I,17)^Y(I,19)^I>>>10;J[h]=p+J[h-7]+U+J[h-16]|0}let{A:r,B:s,C:o,D:f,E:c,F:i,G:a,H:m}=this;for(let h=0;h<64;h++){const l=Y(c,6)^Y(c,11)^Y(c,25),I=m+l+ye(c,i,a)+me[h]+J[h]|0,p=(Y(r,2)^Y(r,13)^Y(r,22))+pe(r,s,o)|0;m=a,a=i,i=c,c=f+I|0,f=o,o=s,s=r,r=I+p|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,f=f+this.D|0,c=c+this.E|0,i=i+this.F|0,a=a+this.G|0,m=m+this.H|0,this.set(r,s,o,f,c,i,a,m)}roundClean(){J.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const xe=he(()=>new Ee);class Wt extends Pt{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,ue(n);const r=qt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let f=0;f<o.length;f++)o[f]^=54;this.iHash.update(o),this.oHash=n.create();for(let f=0;f<o.length;f++)o[f]^=106;this.oHash.update(o),o.fill(0)}update(n){return bt(this),this.iHash.update(n),this}digestInto(n){bt(this),mt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:f,outputLen:c}=this;return n=n,n.finished=s,n.destroyed=o,n.blockLen=f,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Xt=(t,n,e)=>new Wt(t,n).update(e).digest();Xt.create=(t,n)=>new Wt(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ht=BigInt(0),Et=BigInt(1),Be=BigInt(2);function ot(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function yt(t){if(!ot(t))throw new Error("Uint8Array expected")}function at(t,n){if(typeof n!="boolean")throw new Error(`${t} must be valid boolean, got "${n}".`)}const ve=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function lt(t){yt(t);let n="";for(let e=0;e<t.length;e++)n+=ve[t[e]];return n}function ut(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Ut(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const F={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Vt(t){if(t>=F._0&&t<=F._9)return t-F._0;if(t>=F._A&&t<=F._F)return t-(F._A-10);if(t>=F._a&&t<=F._f)return t-(F._a-10)}function dt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const f=Vt(t.charCodeAt(o)),c=Vt(t.charCodeAt(o+1));if(f===void 0||c===void 0){const i=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+o)}r[s]=f*16+c}return r}function nt(t){return Ut(lt(t))}function Tt(t){return yt(t),Ut(lt(Uint8Array.from(t).reverse()))}function ht(t,n){return dt(t.toString(16).padStart(n*2,"0"))}function _t(t,n){return ht(t,n).reverse()}function Se(t){return dt(ut(t))}function M(t,n,e){let r;if(typeof n=="string")try{r=dt(n)}catch(o){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${o}`)}else if(ot(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${t} expected ${e} bytes, got ${s}`);return r}function wt(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];yt(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}function Ae(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function Ie(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}const St=t=>typeof t=="bigint"&&Ht<=t;function xt(t,n,e){return St(t)&&St(n)&&St(e)&&n<=t&&t<e}function rt(t,n,e,r){if(!xt(n,e,r))throw new Error(`expected valid ${t}: ${e} <= n < ${r}, got ${typeof n} ${n}`)}function Qt(t){let n;for(n=0;t>Ht;t>>=Et,n+=1);return n}function Oe(t,n){return t>>BigInt(n)&Et}function Le(t,n,e){return t|(e?Et:Ht)<<BigInt(n)}const Rt=t=>(Be<<BigInt(t-1))-Et,At=t=>new Uint8Array(t),jt=t=>Uint8Array.from(t);function Jt(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=At(t),s=At(t),o=0;const f=()=>{r.fill(1),s.fill(0),o=0},c=(...h)=>e(s,r,...h),i=(h=At())=>{s=c(jt([0]),h),r=c(),h.length!==0&&(s=c(jt([1]),h),r=c())},a=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const l=[];for(;h<n;){r=c();const I=r.slice();l.push(I),h+=r.length}return wt(...l)};return(h,l)=>{f(),i(h);let I;for(;!(I=l(a()));)i();return f(),I}}const $e={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||ot(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function pt(t,n,e={}){const r=(s,o,f)=>{const c=$e[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const i=t[s];if(!(f&&i===void 0)&&!c(i,t))throw new Error(`Invalid param ${String(s)}=${i} (${typeof i}), expected ${o}`)};for(const[s,o]of Object.entries(n))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return t}const Ne=()=>{throw new Error("not implemented")};function Lt(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(s!==void 0)return s;const o=t(e,...r);return n.set(e,o),o}}const qe=Object.freeze(Object.defineProperty({__proto__:null,aInRange:rt,abool:at,abytes:yt,bitGet:Oe,bitLen:Qt,bitMask:Rt,bitSet:Le,bytesToHex:lt,bytesToNumberBE:nt,bytesToNumberLE:Tt,concatBytes:wt,createHmacDrbg:Jt,ensureBytes:M,equalBytes:Ae,hexToBytes:dt,hexToNumber:Ut,inRange:xt,isBytes:ot,memoized:Lt,notImplemented:Ne,numberToBytesBE:ht,numberToBytesLE:_t,numberToHexUnpadded:ut,numberToVarBytesBE:Se,utf8ToBytes:Ie,validateObject:pt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const R=BigInt(0),H=BigInt(1),et=BigInt(2),He=BigInt(3),$t=BigInt(4),Kt=BigInt(5),Mt=BigInt(8);BigInt(9);BigInt(16);function V(t,n){const e=t%n;return e>=R?e:n+e}function Ue(t,n,e){if(e<=R||n<R)throw new Error("Expected power/modulo > 0");if(e===H)return R;let r=H;for(;n>R;)n&H&&(r=r*t%e),t=t*t%e,n>>=H;return r}function Nt(t,n){if(t===R||n<=R)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=V(t,n),r=n,s=R,o=H;for(;e!==R;){const c=r/e,i=r%e,a=s-o*c;r=e,e=i,s=o,o=a}if(r!==H)throw new Error("invert: does not exist");return V(s,n)}function Te(t){const n=(t-H)/et;let e,r,s;for(e=t-H,r=0;e%et===R;e/=et,r++);for(s=et;s<t&&Ue(s,n,t)!==t-H;s++);if(r===1){const f=(t+H)/$t;return function(i,a){const m=i.pow(a,f);if(!i.eql(i.sqr(m),a))throw new Error("Cannot find square root");return m}}const o=(e+H)/et;return function(c,i){if(c.pow(i,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,m=c.pow(c.mul(c.ONE,s),e),h=c.pow(i,o),l=c.pow(i,e);for(;!c.eql(l,c.ONE);){if(c.eql(l,c.ZERO))return c.ZERO;let I=1;for(let p=c.sqr(l);I<a&&!c.eql(p,c.ONE);I++)p=c.sqr(p);const U=c.pow(m,H<<BigInt(a-I-1));m=c.sqr(U),h=c.mul(h,U),l=c.mul(l,m),a=I}return h}}function _e(t){if(t%$t===He){const n=(t+H)/$t;return function(r,s){const o=r.pow(s,n);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%Mt===Kt){const n=(t-Kt)/Mt;return function(r,s){const o=r.mul(s,et),f=r.pow(o,n),c=r.mul(s,f),i=r.mul(r.mul(c,et),f),a=r.mul(c,r.sub(i,r.ONE));if(!r.eql(r.sqr(a),s))throw new Error("Cannot find square root");return a}}return Te(t)}const Re=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ze(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Re.reduce((r,s)=>(r[s]="function",r),n);return pt(t,e)}function Ce(t,n,e){if(e<R)throw new Error("Expected power > 0");if(e===R)return t.ONE;if(e===H)return n;let r=t.ONE,s=n;for(;e>R;)e&H&&(r=t.mul(r,s)),s=t.sqr(s),e>>=H;return r}function ke(t,n){const e=new Array(n.length),r=n.reduce((o,f,c)=>t.is0(f)?o:(e[c]=o,t.mul(o,f)),t.ONE),s=t.inv(r);return n.reduceRight((o,f,c)=>t.is0(f)?o:(e[c]=t.mul(o,e[c]),t.mul(o,f)),s),e}function te(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function ee(t,n,e=!1,r={}){if(t<=R)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=te(t,n);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=_e(t),c=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:Rt(s),ZERO:R,ONE:H,create:i=>V(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof i}`);return R<=i&&i<t},is0:i=>i===R,isOdd:i=>(i&H)===H,neg:i=>V(-i,t),eql:(i,a)=>i===a,sqr:i=>V(i*i,t),add:(i,a)=>V(i+a,t),sub:(i,a)=>V(i-a,t),mul:(i,a)=>V(i*a,t),pow:(i,a)=>Ce(c,i,a),div:(i,a)=>V(i*Nt(a,t),t),sqrN:i=>i*i,addN:(i,a)=>i+a,subN:(i,a)=>i-a,mulN:(i,a)=>i*a,inv:i=>Nt(i,t),sqrt:r.sqrt||(i=>f(c,i)),invertBatch:i=>ke(c,i),cmov:(i,a,m)=>m?a:i,toBytes:i=>e?_t(i,o):ht(i,o),fromBytes:i=>{if(i.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${i.length}`);return e?Tt(i):nt(i)}});return Object.freeze(c)}function ne(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function re(t){const n=ne(t);return n+Math.ceil(n/2)}function ze(t,n,e=!1){const r=t.length,s=ne(n),o=re(n);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const f=e?nt(t):Tt(t),c=V(f,n-H)+H;return e?_t(c,s):ht(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ve=BigInt(0),It=BigInt(1),Ot=new WeakMap,Yt=new WeakMap;function je(t,n){const e=(o,f)=>{const c=f.negate();return o?c:f},r=o=>{if(!Number.isSafeInteger(o)||o<=0||o>n)throw new Error(`Wrong window size=${o}, should be [1..${n}]`)},s=o=>{r(o);const f=Math.ceil(n/o)+1,c=2**(o-1);return{windows:f,windowSize:c}};return{constTimeNegate:e,unsafeLadder(o,f){let c=t.ZERO,i=o;for(;f>Ve;)f&It&&(c=c.add(i)),i=i.double(),f>>=It;return c},precomputeWindow(o,f){const{windows:c,windowSize:i}=s(f),a=[];let m=o,h=m;for(let l=0;l<c;l++){h=m,a.push(h);for(let I=1;I<i;I++)h=h.add(m),a.push(h);m=h.double()}return a},wNAF(o,f,c){const{windows:i,windowSize:a}=s(o);let m=t.ZERO,h=t.BASE;const l=BigInt(2**o-1),I=2**o,U=BigInt(o);for(let p=0;p<i;p++){const u=p*a;let g=Number(c&l);c>>=U,g>a&&(g-=I,c+=It);const b=u,x=u+Math.abs(g)-1,S=p%2!==0,$=g<0;g===0?h=h.add(e(S,f[b])):m=m.add(e($,f[x]))}return{p:m,f:h}},wNAFCached(o,f,c){const i=Yt.get(o)||1;let a=Ot.get(o);return a||(a=this.precomputeWindow(o,i),i!==1&&Ot.set(o,c(a))),this.wNAF(i,a,f)},setWindowSize(o,f){r(f),Yt.set(o,f),Ot.delete(o)}}}function Ke(t,n,e,r){if(!Array.isArray(e)||!Array.isArray(r)||r.length!==e.length)throw new Error("arrays of points and scalars must have equal length");r.forEach((m,h)=>{if(!n.isValid(m))throw new Error(`wrong scalar at index ${h}`)}),e.forEach((m,h)=>{if(!(m instanceof t))throw new Error(`wrong point at index ${h}`)});const s=Qt(BigInt(e.length)),o=s>12?s-3:s>4?s-2:s?2:1,f=(1<<o)-1,c=new Array(f+1).fill(t.ZERO),i=Math.floor((n.BITS-1)/o)*o;let a=t.ZERO;for(let m=i;m>=0;m-=o){c.fill(t.ZERO);for(let l=0;l<r.length;l++){const I=r[l],U=Number(I>>BigInt(m)&BigInt(f));c[U]=c[U].add(e[l])}let h=t.ZERO;for(let l=c.length-1,I=t.ZERO;l>0;l--)I=I.add(c[l]),h=h.add(I);if(a=a.add(h),m!==0)for(let l=0;l<o;l++)a=a.double()}return a}function oe(t){return Ze(t.Fp),pt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...te(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ft(t){t.lowS!==void 0&&at("lowS",t.lowS),t.prehash!==void 0&&at("prehash",t.prehash)}function Me(t){const n=oe(t);pt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Ye,hexToBytes:Fe}=qe,G={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(t,n)=>{const{Err:e}=G;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=ut(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?ut(s.length/2|128):"";return`${ut(t)}${o}${s}${n}`},decode(t,n){const{Err:e}=G;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++],o=!!(s&128);let f=0;if(!o)f=s;else{const i=s&127;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const a=n.subarray(r,r+i);if(a.length!==i)throw new e("tlv.decode: length bytes not complete");if(a[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const m of a)f=f<<8|m;if(r+=i,f<128)throw new e("tlv.decode(long): not minimal encoding")}const c=n.subarray(r,r+f);if(c.length!==f)throw new e("tlv.decode: wrong value length");return{v:c,l:n.subarray(r+f)}}},_int:{encode(t){const{Err:n}=G;if(t<D)throw new n("integer: negative integers are not allowed");let e=ut(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected assertion");return e},decode(t){const{Err:n}=G;if(t[0]&128)throw new n("Invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return Ye(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=G,s=typeof t=="string"?Fe(t):t;yt(s);const{v:o,l:f}=r.decode(48,s);if(f.length)throw new n("Invalid signature: left bytes after parsing");const{v:c,l:i}=r.decode(2,o),{v:a,l:m}=r.decode(2,i);if(m.length)throw new n("Invalid signature: left bytes after parsing");return{r:e.decode(c),s:e.decode(a)}},hexFromSig(t){const{_tlv:n,_int:e}=G,r=`${n.encode(2,e.encode(t.r))}${n.encode(2,e.encode(t.s))}`;return n.encode(48,r)}},D=BigInt(0),_=BigInt(1);BigInt(2);const Gt=BigInt(3);BigInt(4);function Ge(t){const n=Me(t),{Fp:e}=n,r=ee(n.n,n.nBitLength),s=n.toBytes||((p,u,g)=>{const b=u.toAffine();return wt(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),o=n.fromBytes||(p=>{const u=p.subarray(1),g=e.fromBytes(u.subarray(0,e.BYTES)),b=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:g,y:b}});function f(p){const{a:u,b:g}=n,b=e.sqr(p),x=e.mul(b,p);return e.add(e.add(x,e.mul(p,u)),g)}if(!e.eql(e.sqr(n.Gy),f(n.Gx)))throw new Error("bad generator point: equation left != right");function c(p){return xt(p,_,n.n)}function i(p){const{allowedPrivateKeyLengths:u,nByteLength:g,wrapPrivateKey:b,n:x}=n;if(u&&typeof p!="bigint"){if(ot(p)&&(p=lt(p)),typeof p!="string"||!u.includes(p.length))throw new Error("Invalid key");p=p.padStart(g*2,"0")}let S;try{S=typeof p=="bigint"?p:nt(M("private key",p,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof p}`)}return b&&(S=V(S,x)),rt("private key",S,_,x),S}function a(p){if(!(p instanceof l))throw new Error("ProjectivePoint expected")}const m=Lt((p,u)=>{const{px:g,py:b,pz:x}=p;if(e.eql(x,e.ONE))return{x:g,y:b};const S=p.is0();u==null&&(u=S?e.ONE:e.inv(x));const $=e.mul(g,u),O=e.mul(b,u),E=e.mul(x,u);if(S)return{x:e.ZERO,y:e.ZERO};if(!e.eql(E,e.ONE))throw new Error("invZ was invalid");return{x:$,y:O}}),h=Lt(p=>{if(p.is0()){if(n.allowInfinityPoint&&!e.is0(p.py))return;throw new Error("bad point: ZERO")}const{x:u,y:g}=p.toAffine();if(!e.isValid(u)||!e.isValid(g))throw new Error("bad point: x or y not FE");const b=e.sqr(g),x=f(u);if(!e.eql(b,x))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class l{constructor(u,g,b){if(this.px=u,this.py=g,this.pz=b,u==null||!e.isValid(u))throw new Error("x required");if(g==null||!e.isValid(g))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required");Object.freeze(this)}static fromAffine(u){const{x:g,y:b}=u||{};if(!u||!e.isValid(g)||!e.isValid(b))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const x=S=>e.eql(S,e.ZERO);return x(g)&&x(b)?l.ZERO:new l(g,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const g=e.invertBatch(u.map(b=>b.pz));return u.map((b,x)=>b.toAffine(g[x])).map(l.fromAffine)}static fromHex(u){const g=l.fromAffine(o(M("pointHex",u)));return g.assertValidity(),g}static fromPrivateKey(u){return l.BASE.multiply(i(u))}static msm(u,g){return Ke(l,r,u,g)}_setWindowSize(u){U.setWindowSize(this,u)}assertValidity(){h(this)}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){a(u);const{px:g,py:b,pz:x}=this,{px:S,py:$,pz:O}=u,E=e.eql(e.mul(g,O),e.mul(S,x)),B=e.eql(e.mul(b,O),e.mul($,x));return E&&B}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:g}=n,b=e.mul(g,Gt),{px:x,py:S,pz:$}=this;let O=e.ZERO,E=e.ZERO,B=e.ZERO,A=e.mul(x,x),z=e.mul(S,S),q=e.mul($,$),L=e.mul(x,S);return L=e.add(L,L),B=e.mul(x,$),B=e.add(B,B),O=e.mul(u,B),E=e.mul(b,q),E=e.add(O,E),O=e.sub(z,E),E=e.add(z,E),E=e.mul(O,E),O=e.mul(L,O),B=e.mul(b,B),q=e.mul(u,q),L=e.sub(A,q),L=e.mul(u,L),L=e.add(L,B),B=e.add(A,A),A=e.add(B,A),A=e.add(A,q),A=e.mul(A,L),E=e.add(E,A),q=e.mul(S,$),q=e.add(q,q),A=e.mul(q,L),O=e.sub(O,A),B=e.mul(q,z),B=e.add(B,B),B=e.add(B,B),new l(O,E,B)}add(u){a(u);const{px:g,py:b,pz:x}=this,{px:S,py:$,pz:O}=u;let E=e.ZERO,B=e.ZERO,A=e.ZERO;const z=n.a,q=e.mul(n.b,Gt);let L=e.mul(g,S),k=e.mul(b,$),d=e.mul(x,O),w=e.add(g,b),y=e.add(S,$);w=e.mul(w,y),y=e.add(L,k),w=e.sub(w,y),y=e.add(g,x);let v=e.add(S,O);return y=e.mul(y,v),v=e.add(L,d),y=e.sub(y,v),v=e.add(b,x),E=e.add($,O),v=e.mul(v,E),E=e.add(k,d),v=e.sub(v,E),A=e.mul(z,y),E=e.mul(q,d),A=e.add(E,A),E=e.sub(k,A),A=e.add(k,A),B=e.mul(E,A),k=e.add(L,L),k=e.add(k,L),d=e.mul(z,d),y=e.mul(q,y),k=e.add(k,d),d=e.sub(L,d),d=e.mul(z,d),y=e.add(y,d),L=e.mul(k,y),B=e.add(B,L),L=e.mul(v,y),E=e.mul(w,E),E=e.sub(E,L),L=e.mul(w,k),A=e.mul(v,A),A=e.add(A,L),new l(E,B,A)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return U.wNAFCached(this,u,l.normalizeZ)}multiplyUnsafe(u){rt("scalar",u,D,n.n);const g=l.ZERO;if(u===D)return g;if(u===_)return this;const{endo:b}=n;if(!b)return U.unsafeLadder(this,u);let{k1neg:x,k1:S,k2neg:$,k2:O}=b.splitScalar(u),E=g,B=g,A=this;for(;S>D||O>D;)S&_&&(E=E.add(A)),O&_&&(B=B.add(A)),A=A.double(),S>>=_,O>>=_;return x&&(E=E.negate()),$&&(B=B.negate()),B=new l(e.mul(B.px,b.beta),B.py,B.pz),E.add(B)}multiply(u){const{endo:g,n:b}=n;rt("scalar",u,_,b);let x,S;if(g){const{k1neg:$,k1:O,k2neg:E,k2:B}=g.splitScalar(u);let{p:A,f:z}=this.wNAF(O),{p:q,f:L}=this.wNAF(B);A=U.constTimeNegate($,A),q=U.constTimeNegate(E,q),q=new l(e.mul(q.px,g.beta),q.py,q.pz),x=A.add(q),S=z.add(L)}else{const{p:$,f:O}=this.wNAF(u);x=$,S=O}return l.normalizeZ([x,S])[0]}multiplyAndAddUnsafe(u,g,b){const x=l.BASE,S=(O,E)=>E===D||E===_||!O.equals(x)?O.multiplyUnsafe(E):O.multiply(E),$=S(this,g).add(S(u,b));return $.is0()?void 0:$}toAffine(u){return m(this,u)}isTorsionFree(){const{h:u,isTorsionFree:g}=n;if(u===_)return!0;if(g)return g(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:g}=n;return u===_?this:g?g(l,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return at("isCompressed",u),this.assertValidity(),s(l,this,u)}toHex(u=!0){return at("isCompressed",u),lt(this.toRawBytes(u))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const I=n.nBitLength,U=je(l,n.endo?Math.ceil(I/2):I);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:i,weierstrassEquation:f,isWithinCurveOrder:c}}function De(t){const n=oe(t);return pt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Pe(t){const n=De(t),{Fp:e,n:r}=n,s=e.BYTES+1,o=2*e.BYTES+1;function f(d){return V(d,r)}function c(d){return Nt(d,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:a,weierstrassEquation:m,isWithinCurveOrder:h}=Ge({...n,toBytes(d,w,y){const v=w.toAffine(),N=e.toBytes(v.x),T=wt;return at("isCompressed",y),y?T(Uint8Array.from([w.hasEvenY()?2:3]),N):T(Uint8Array.from([4]),N,e.toBytes(v.y))},fromBytes(d){const w=d.length,y=d[0],v=d.subarray(1);if(w===s&&(y===2||y===3)){const N=nt(v);if(!xt(N,_,e.ORDER))throw new Error("Point is not on curve");const T=m(N);let Z;try{Z=e.sqrt(T)}catch(j){const W=j instanceof Error?": "+j.message:"";throw new Error("Point is not on curve"+W)}const C=(Z&_)===_;return(y&1)===1!==C&&(Z=e.neg(Z)),{x:N,y:Z}}else if(w===o&&y===4){const N=e.fromBytes(v.subarray(0,e.BYTES)),T=e.fromBytes(v.subarray(e.BYTES,2*e.BYTES));return{x:N,y:T}}else throw new Error(`Point of length ${w} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),l=d=>lt(ht(d,n.nByteLength));function I(d){const w=r>>_;return d>w}function U(d){return I(d)?f(-d):d}const p=(d,w,y)=>nt(d.slice(w,y));class u{constructor(w,y,v){this.r=w,this.s=y,this.recovery=v,this.assertValidity()}static fromCompact(w){const y=n.nByteLength;return w=M("compactSignature",w,y*2),new u(p(w,0,y),p(w,y,2*y))}static fromDER(w){const{r:y,s:v}=G.toSig(M("DER",w));return new u(y,v)}assertValidity(){rt("r",this.r,_,r),rt("s",this.s,_,r)}addRecoveryBit(w){return new u(this.r,this.s,w)}recoverPublicKey(w){const{r:y,s:v,recovery:N}=this,T=O(M("msgHash",w));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const Z=N===2||N===3?y+n.n:y;if(Z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const C=N&1?"03":"02",P=i.fromHex(C+l(Z)),j=c(Z),W=f(-T*j),gt=f(v*j),X=i.BASE.multiplyAndAddUnsafe(P,W,gt);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,f(-this.s),this.recovery):this}toDERRawBytes(){return dt(this.toDERHex())}toDERHex(){return G.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return dt(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const g={isValidPrivateKey(d){try{return a(d),!0}catch{return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const d=re(n.n);return ze(n.randomBytes(d),n.n)},precompute(d=8,w=i.BASE){return w._setWindowSize(d),w.multiply(BigInt(3)),w}};function b(d,w=!0){return i.fromPrivateKey(d).toRawBytes(w)}function x(d){const w=ot(d),y=typeof d=="string",v=(w||y)&&d.length;return w?v===s||v===o:y?v===2*s||v===2*o:d instanceof i}function S(d,w,y=!0){if(x(d))throw new Error("first arg must be private key");if(!x(w))throw new Error("second arg must be public key");return i.fromHex(w).multiply(a(d)).toRawBytes(y)}const $=n.bits2int||function(d){const w=nt(d),y=d.length*8-n.nBitLength;return y>0?w>>BigInt(y):w},O=n.bits2int_modN||function(d){return f($(d))},E=Rt(n.nBitLength);function B(d){return rt(`num < 2^${n.nBitLength}`,d,D,E),ht(d,n.nByteLength)}function A(d,w,y=z){if(["recovered","canonical"].some(tt=>tt in y))throw new Error("sign() legacy options not supported");const{hash:v,randomBytes:N}=n;let{lowS:T,prehash:Z,extraEntropy:C}=y;T==null&&(T=!0),d=M("msgHash",d),Ft(y),Z&&(d=M("prehashed msgHash",v(d)));const P=O(d),j=a(w),W=[B(j),B(P)];if(C!=null&&C!==!1){const tt=C===!0?N(e.BYTES):C;W.push(M("extraEntropy",tt))}const gt=wt(...W),X=P;function Bt(tt){const it=$(tt);if(!h(it))return;const Zt=c(it),st=i.BASE.multiply(it).toAffine(),K=f(st.x);if(K===D)return;const ct=f(Zt*f(X+K*j));if(ct===D)return;let Ct=(st.x===K?0:2)|Number(st.y&_),kt=ct;return T&&I(ct)&&(kt=U(ct),Ct^=1),new u(K,kt,Ct)}return{seed:gt,k2sig:Bt}}const z={lowS:n.lowS,prehash:!1},q={lowS:n.lowS,prehash:!1};function L(d,w,y=z){const{seed:v,k2sig:N}=A(d,w,y),T=n;return Jt(T.hash.outputLen,T.nByteLength,T.hmac)(v,N)}i.BASE._setWindowSize(8);function k(d,w,y,v=q){var st;const N=d;if(w=M("msgHash",w),y=M("publicKey",y),"strict"in v)throw new Error("options.strict was renamed to lowS");Ft(v);const{lowS:T,prehash:Z}=v;let C,P;try{if(typeof N=="string"||ot(N))try{C=u.fromDER(N)}catch(K){if(!(K instanceof G.Err))throw K;C=u.fromCompact(N)}else if(typeof N=="object"&&typeof N.r=="bigint"&&typeof N.s=="bigint"){const{r:K,s:ct}=N;C=new u(K,ct)}else throw new Error("PARSE");P=i.fromHex(y)}catch(K){if(K.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(T&&C.hasHighS())return!1;Z&&(w=n.hash(w));const{r:j,s:W}=C,gt=O(w),X=c(W),Bt=f(gt*X),tt=f(j*X),it=(st=i.BASE.multiplyAndAddUnsafe(P,Bt,tt))==null?void 0:st.toAffine();return it?f(it.x)===j:!1}return{CURVE:n,getPublicKey:b,getSharedSecret:S,sign:L,verify:k,ProjectivePoint:i,Signature:u,utils:g}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function We(t){return{hash:t,hmac:(n,...e)=>Xt(t,n,de(...e)),randomBytes:ge}}function Xe(t,n){const e=r=>Pe({...t,...We(r)});return Object.freeze({...e(n),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ie=ee(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Qe=ie.create(BigInt("-3")),Je=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Dt=Xe({a:Qe,b:Je,Fp:ie,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},xe),nn=async t=>{const n=Dt.getPublicKey(t.privateKey,!0),e=se(n);if(e!=t.publicKey)throw new Error(`Bad API key. Expected to get public key ${t.publicKey}, got ${e}`);const r=ce().update(t.content).digest();return Dt.sign(r,t.privateKey).toDERHex()};export{nn as signWithApiKey};
