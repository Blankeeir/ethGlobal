import{DriverNoVendor as ve,SimpleNet as be}from"@vechain/connex-driver/dist/index.js";import{Framework as Te}from"@vechain/connex-framework";import{blake2b256 as De,Hex as We}from"@vechain/sdk-core";import{proxy as j,subscribe as xe}from"valtio/vanilla";import{subscribeKey as ye}from"valtio/vanilla/utils";import{certificate as Se}from"@vechain/sdk-core";var h={NONE:0,ERROR:1,WARN:2,INFO:3,DEBUG:4},y=h.NONE,c={configure(n){y=h[n]},debug(n,e,...t){y>=h.DEBUG&&console.log(`[${n}] (${e})`,...t)},info(n,e,...t){y>=h.INFO&&console.info(`[${n}] (${e})`,...t)},warn(n,e,...t){y>=h.WARN&&console.warn(`[${n}] (${e})`,...t)},error(n,e,...t){y>=h.ERROR&&console.error(`[${n}] (${e})`,...t)}};var E=n=>({signTx:(e,t)=>{let o=n.sign("tx",e);return t.gas&&o.gas(t.gas),t.signer&&o.signer(t.signer),t.dependsOn&&o.dependsOn(t.dependsOn),t.link&&o.link(t.link),t.comment&&o.comment(t.comment),t.delegator&&o.delegate(t.delegator.url,t.delegator.signer),t.onAccepted&&o.accepted(t.onAccepted),c.debug("vendor","signTx",{messages:e.length,options:t}),o.request()},signCert:(e,t)=>{let o=n.sign("cert",e);return t.signer&&o.signer(t.signer),t.link&&o.link(t.link),t.onAccepted&&o.accepted(t.onAccepted),c.debug("vendor","signCert",{message:e,options:t}),o.request()},signTypedData(e,t,o,i){throw new Error("Sign typed data it is not available with sync2")}});var T="dappkit@vechain",O=`${T}/source`,k=`${T}/account`,M=`${T}/connectionCertificate`,N=`${T}/accountDomain`,oe=n=>{c.debug("LocalStorage","setSource",n),n?localStorage.setItem(O,n):localStorage.removeItem(O)},re=n=>{c.debug("LocalStorage","setAccount",n),n?localStorage.setItem(k,n):localStorage.removeItem(k)},ie=n=>{c.debug("LocalStorage","setAccountDomain",n),n?localStorage.setItem(N,n):localStorage.removeItem(N)},se=n=>{c.debug("LocalStorage","setConnectionCertificate",n),n?localStorage.setItem(M,JSON.stringify(n)):localStorage.removeItem(M)},ce=()=>{let n=localStorage.getItem(O);return n||null},ae=()=>{let n=localStorage.getItem(k);return n||null},le=()=>{let n=localStorage.getItem(N);return n||null},de=()=>{let n=localStorage.getItem(M);return n?JSON.parse(n):null},u={setAccount:re,setSource:oe,setConnectionCertificate:se,setAccountDomain:ie,getAccountDomain:le,getAccount:ae,getSource:ce,getConnectionCertificate:de};var D={purpose:"identification",payload:{type:"text",content:`The following dApp would like to see your public address: ${typeof window<"u"?window.origin:""}`}};var m={main:{number:0,id:"0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",size:170,parentID:"0xffffffff53616c757465202620526573706563742c20457468657265756d2100",timestamp:1530316800,gasLimit:1e7,beneficiary:"0x0000000000000000000000000000000000000000",gasUsed:0,totalScore:0,txsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",txsFeatures:0,stateRoot:"0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",receiptsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",signer:"0x0000000000000000000000000000000000000000",isTrunk:!0,transactions:[]},test:{number:0,id:"0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",size:170,parentID:"0xffffffff00000000000000000000000000000000000000000000000000000000",timestamp:1530014400,gasLimit:1e7,beneficiary:"0x0000000000000000000000000000000000000000",gasUsed:0,totalScore:0,txsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",txsFeatures:0,stateRoot:"0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",receiptsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",signer:"0x0000000000000000000000000000000000000000",isTrunk:!0,transactions:[]}};var L={requiresCertificate:!0},K={"wallet-connect":{requiresCertificate:!1},veworld:L,sync2:L,sync:L},V=Object.keys(K);Object.freeze(K);Object.freeze(V);var P=(o=>(o.RequestTransaction="thor_sendTransaction",o.SignCertificate="thor_signCertificate",o.SignTypedData="thor_signTypedData",o))(P||{});var $=n=>n?n==="main"||n==="test"?m[n].id:n.id:m.main.id,B=n=>n?n==="main"||n==="test"?m[n]:n:m.main;import*as F from"@vechain/connex";import{certificate as pe}from"@vechain/sdk-core";var w=class{constructor(e,t){this.wallet=e;this.connectionCertificateData=t;this.connect=async()=>{let e=this.connectionCertificateData?.message||D,t=this.connectionCertificateData?.options||{},{annex:{domain:o,signer:i,timestamp:r},signature:l}=await this.signCert(e,t),g={...e,signature:l,signer:i,domain:o,timestamp:r};try{return pe.verify(g),{account:i,verified:!0,connectionCertificate:g}}catch(f){return console.error("Failed to verify connection certificate",f),{account:i,verified:!1}}};this.signCert=(e,t)=>this.wallet.signCert(e,t);this.signTx=(e,t)=>this.wallet.signTx(e,t);this.signTypedData=(e,t,o,i)=>this.wallet.signTypedData(e,t,o,i);this.disconnect=async()=>this.wallet.disconnect?.()}};var W=class{constructor(e){this.signer=e;this.connect=async()=>({account:await this.signer.connect(),verified:!1});this.signCert=(e,t)=>this.signer.signCert(e,t);this.signTx=(e,t)=>this.signer.signTx(e,t);this.signTypedData=async(e,t,o,i)=>this.signer.signTypedData(e,t,o,i);this.disconnect=()=>this.signer.disconnect()}};import{SignClient as ge}from"@walletconnect/sign-client";var U={},q=({projectId:n,metadata:e})=>{let t=U[n];if(t)return t;let o=ge.init({projectId:n,metadata:e}),i={get:async()=>{try{return await o}catch(r){throw console.error("Failed to initialise the wallet connect sign client",r),new Error("Failed to initialise the wallet connect sign client")}}};return U[n]=i,i};import{WalletConnectModal as ue}from"@walletconnect/modal";var G={},fe=["0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a","0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127"],me=fe.map(n=>`vechain:${n.slice(-32)}`),z=n=>{let e=G[n];if(e)return e;let t=new ue({projectId:n,explorerRecommendedWalletIds:"NONE",mobileWallets:[{name:"VeWorld",id:"veworld-mobile",links:{native:"veworld://org.vechain.veworld.app/",universal:"https://veworld.com"}}],chains:me,themeVariables:{"--wcm-z-index":"99999999"},walletImages:{"veworld-mobile":"https://www.veworld.net/assets/logo/logo.svg"}});return G[n]=t,t};import{getSdkError as Ce}from"@walletconnect/utils";var Y=({genesisId:n,wcClient:e,web3Modal:t,onDisconnected:o})=>{let i=`vechain:${n.slice(-32)}`,r;e.get().then(s=>{l(s),g(s)}).catch(()=>{throw new Error("Failed to get the wallet connect sign client")});let l=s=>{s.on("session_update",({topic:a,params:d})=>{c.debug("wallet connect signer","session_update",{topic:a,params:d});let{namespaces:p}=d;r={...s.session.get(a),namespaces:p}}),s.on("session_delete",()=>{o(),_().catch(()=>{throw new Error("Failed to disconnect")})})},g=s=>{if(typeof r<"u")return;c.debug("wallet connect signer","restore session");let a=s.session.keys;for(let d of a){let p=s.session.get(d),v=p.namespaces.vechain.accounts;for(let b of v)if(b.split(":")[1]===n.slice(-32)){r=p;return}}},f=s=>{if(!r)return;c.debug("wallet connect signer","validate session");let a=r.namespaces.vechain.accounts[0],d=a.split(":")[2],p=a.split(":")[1];if(p===n.slice(-32)&&!(s&&s.toLowerCase()!==d.toLowerCase()))return{address:d,networkIdentifier:p,topic:r.topic}},S=async()=>{c.debug("wallet connect signer","connect");let s=await e.get(),a={methods:Object.values(P),chains:[i],events:[]};try{let d={vechain:a},p=await s.connect({requiredNamespaces:d});return p.uri&&await t.openModal({uri:p.uri}),await new Promise((v,b)=>{let I=t.subscribeModal(C=>{C.open||(b(new Error("User closed modal while connecting")),I())});p.approval().then(C=>{r=C,I(),v(C)}).catch(C=>{t.closeModal(),b(C)})})}catch(d){throw console.error("wc connect failed",d),new Error("wc connect failed")}},R=async s=>{let a=f(s);return a?a.topic:(await S()).topic},x=async(s,a)=>{let d=await R(a);return(await e.get()).request({topic:d,chainId:i,request:s})},ee=async(s,a)=>x({method:"thor_sendTransaction",params:[{message:s,options:a}]}),te=async(s,a)=>x({method:"thor_signCertificate",params:[{message:s,options:a}]}),ne=async(s,a,d,p)=>x({method:"thor_signTypedData",params:[{domain:s,types:a,value:d,options:p}]}),_=async()=>{if(!r)return;let s=r.topic;r=void 0;let a=await e.get();try{await a.disconnect({topic:s,reason:Ce("USER_DISCONNECTED")})}catch(d){throw console.error("SignClient.disconnect failed",d),new Error("SignClient.disconnect failed")}};return{signTx:ee,signCert:te,signTypedData:ne,disconnect:_,genesisId:n,connect:async()=>{r||(r=await S());let s=r.namespaces.vechain;if(!s)throw new Error("Failed to create a vechain session with wallet connect");let a=s.accounts[0];try{return a.split(":")[2]}catch(d){throw console.error("Failed to get account from session",d),new Error("Failed to get account from session")}}}};var H=({source:n,genesis:e,walletConnectOptions:t,onDisconnected:o,connectionCertificate:i})=>{let r=$(e);switch(c.debug("createWallet",n),n){case"sync":{if(!window.connex)throw new Error("User is not in a Sync wallet");let l=new F.Connex.Vendor(r,"sync");return new w(E(l),i)}case"sync2":{let l=new F.Connex.Vendor(r,"sync2");return new w(E(l),i)}case"veworld":{if(!window.vechain)throw new Error("VeWorld Extension is not installed");let l=window.vechain.newConnexSigner(r);return new w(l,i)}case"wallet-connect":{if(!t)throw new Error("WalletConnect options are not provided");let{projectId:l,metadata:g,modal:f}=t,S=q({projectId:l,metadata:g}),R=f??z(l),x=Y({genesisId:r,wcClient:S,web3Modal:R,onDisconnected:o});return new W(x)}}};var gt=(n,e=10,t=7)=>n.length>e+t+1?`${n.slice(0,e)}\u2026${n.slice(-t)}`:n;import{Framework as he}from"@vechain/connex-framework";var J={main:"0xA11413086e163e41901bb81fdc5617c975Fa5a1A",test:"0xc403b8EA53F707d7d4de095f0A20bC491Cf2bc94"},we={inputs:[{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getNames",outputs:[{internalType:"string[]",name:"names",type:"string[]"}],stateMutability:"view",type:"function"},X=async({address:n,driver:e})=>{if(!n)return null;let t=new he(e),o=e.genesis.id===m.test.id?J.test:J.main,i=await t.thor.account(o).method(we).call([n]),{decoded:{names:r}}=i;return r?.[0]||null};var A=class{constructor(e,t){this.options=e;this.driver=t;this.wallets={};this.setAccountDomain=e=>{e?(this.state.isAccountDomainLoading=!0,X({address:e,driver:this.driver}).then(t=>{this.state.accountDomain=t}).catch(t=>{console.error("Error getting account domain",t),this.state.accountDomain=null}).finally(()=>{this.state.isAccountDomainLoading=!1})):(this.state.accountDomain=null,this.state.isAccountDomainLoading=!1)};this.setAddress=e=>{this.state.address=e};this.setAddressAndDomain=e=>{this.setAddress(e),this.setAccountDomain(e)};this.signConnectionCertificate=async()=>{let e=this.options.connectionCertificate?.message||D,t=this.options.connectionCertificate?.options||{},{annex:{domain:o,signer:i,timestamp:r},signature:l}=await this.wallet.signCert(e,t),g={...e,signature:l,signer:i,domain:o,timestamp:r};try{return Se.verify(g),this.setAddressAndDomain(i),this.state.connectionCertificate=g,{account:i,verified:!0,connectionCertificate:g}}catch(f){return console.error("Failed to sign connection certificate",f),{account:i,verified:!1}}finally{this.options.walletConnectOptions?.modal?.onConnectionCertificateSigned?.()}};this.connect=()=>this.wallet.connect().then(e=>(this.state.source==="wallet-connect"&&this.options.requireCertificate&&this.options.walletConnectOptions?.modal?.askForConnectionCertificate?this.options.walletConnectOptions.modal.askForConnectionCertificate():(this.setAddressAndDomain(e.account),this.state.connectionCertificate=e.connectionCertificate??null),e)).catch(e=>{throw c.error("WalletManager","connect",e),e});this.disconnect=(e=!1)=>{if(!this.state.source){this.state.source=null,this.setAddressAndDomain(null),this.state.connectionCertificate=null;return}c.debug("WalletManager","disconnect","current source",this.state.source);let t=this.wallets[this.state.source];if(t&&!e&&t.disconnect){let o=t.disconnect();o instanceof Promise&&o.catch(i=>{c.error("WalletManager","disconnect",i)})}this.state.source=null,this.setAddressAndDomain(null),this.state.connectionCertificate=null};this.signTx=(e,t)=>this.wallet.signTx(e,t).catch(o=>{throw c.error("WalletManager","signTx",o),o});this.signCert=(e,t)=>this.wallet.signCert(e,t).catch(o=>{throw c.error("WalletManager","signCert",o),o});this.signTypedData=(e,t,o,i)=>this.wallet.signTypedData(e,t,o,i).catch(r=>{throw c.error("WalletManager","signTypedData",r),r});this.setSource=e=>{if(this.state.source!==e){if(this.state.source&&this.state.source!==e&&this.disconnect(),e==="wallet-connect"&&!this.options.walletConnectOptions)throw new Error("WalletConnect options are not provided");if(e==="veworld"&&!window.vechain)throw new Error("VeWorld Extension is not installed");if(e==="sync"&&!window.connex)throw new Error("User is not in a Sync wallet");c.debug("WalletManager","setSource",e),this.disconnect(),this.state.source=e}};this.subscribe=e=>xe(this.state,()=>{e(this.state)});this.subscribeToKey=(e,t)=>ye(this.state,e,o=>{t(o)});this.initState=e=>{let t=this.getAvailableSources();if(!e)return j({source:null,address:null,accountDomain:null,isAccountDomainLoading:!1,availableSources:t,connectionCertificate:null});let o=u.getAccount(),i=u.getAccountDomain(),r=u.getSource(),l=u.getConnectionCertificate();return j({source:r,address:o,accountDomain:i,isAccountDomainLoading:!1,availableSources:t,connectionCertificate:l})};this.initPersistence=e=>{e&&(this.subscribeToKey("address",u.setAccount),this.subscribeToKey("accountDomain",u.setAccountDomain),this.subscribeToKey("source",u.setSource),this.subscribeToKey("connectionCertificate",u.setConnectionCertificate))};this.getAvailableSources=()=>{let e=[];return e.push("veworld"),this.options.walletConnectOptions&&e.push("wallet-connect"),e.push("sync2"),window.connex&&e.push("sync"),e};this.setFirstDetectedSource=()=>{window.vechain?this.setSource("veworld"):this.options.walletConnectOptions?this.setSource("wallet-connect"):window.connex?this.setSource("sync"):this.setSource("sync2")};this.state=this.initState(e.usePersistence??!1),this.initPersistence(e.usePersistence??!1),c.debug("WalletManager","constructor",this.state),window.vechain?.isInAppBrowser===!0?this.setSource("veworld"):e.useFirstDetectedSource&&this.setFirstDetectedSource()}get wallet(){let e=this.state.source;if(c.debug("WalletManager","get wallet","current source",e),!e)throw new Error("No wallet has been selected");let t=this.wallets[e];if(!t){if(!V.includes(e))throw new Error(`No wallet found for: ${e}`);c.debug("WalletManager","get wallet","creating a new wallet",e);let o={...this.options,source:e,onDisconnected:()=>this.disconnect(!0)};t=H(o),this.wallets[e]=t}return t}};var Q={},Ae=(n,e)=>{let t=JSON.stringify({node:n,genesis:e}),o=new TextEncoder().encode(t.normalize()),i=We.canon(De(o,"hex")),r=Q[i];return r||(r=new ve(new be(n),e),Q[i]=r),r},Z=class{constructor(e){e.logLevel&&(c.configure(e.logLevel),c.debug("DAppKit","constructor",e));let{nodeUrl:t,genesis:o}=e,i=B(o),r=Ae(t,i),l=new A(e,r);r.signTx=l.signTx.bind(l),r.signCert=l.signCert.bind(l);let g=new Te(r);this.thor=g.thor,this.vendor=g.vendor,this.wallet=l}};export{w as CertificateBasedWallet,Z as DAppKit,c as DAppKitLogger,D as DEFAULT_CONNECT_CERT_MESSAGE,P as DefaultMethods,u as Storage,W as WCWallet,A as WalletManager,K as WalletMapping,V as WalletSources,E as convertVendorToSigner,H as createWallet,q as createWcClient,z as createWcModal,Y as createWcSigner,m as genesisBlocks,B as normalizeGenesisBlock,$ as normalizeGenesisId,gt as shortenedDomain};
//# sourceMappingURL=index.js.map