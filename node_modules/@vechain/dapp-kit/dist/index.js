import{DriverNoVendor as ve,SimpleNet as be}from"@vechain/connex-driver/dist/index.js";import{Framework as Te}from"@vechain/connex-framework";import{blake2b256 as De,Hex as We}from"@vechain/sdk-core";import{proxy as j,subscribe as xe}from"valtio/vanilla";import{subscribeKey as ye}from"valtio/vanilla/utils";import{Certificate as Se}from"@vechain/sdk-core";var w={NONE:0,ERROR:1,WARN:2,INFO:3,DEBUG:4},y=w.NONE,c={configure(n){y=w[n]},debug(n,e,...t){y>=w.DEBUG&&console.log(`[${n}] (${e})`,...t)},info(n,e,...t){y>=w.INFO&&console.info(`[${n}] (${e})`,...t)},warn(n,e,...t){y>=w.WARN&&console.warn(`[${n}] (${e})`,...t)},error(n,e,...t){y>=w.ERROR&&console.error(`[${n}] (${e})`,...t)}};var O=n=>({signTx:(e,t)=>{let o=n.sign("tx",e);return t.gas&&o.gas(t.gas),t.signer&&o.signer(t.signer),t.dependsOn&&o.dependsOn(t.dependsOn),t.link&&o.link(t.link),t.comment&&o.comment(t.comment),t.delegator&&o.delegate(t.delegator.url,t.delegator.signer),t.onAccepted&&o.accepted(t.onAccepted),c.debug("vendor","signTx",{messages:e.length,options:t}),o.request()},signCert:(e,t)=>{let o=n.sign("cert",e);return t.signer&&o.signer(t.signer),t.link&&o.link(t.link),t.onAccepted&&o.accepted(t.onAccepted),c.debug("vendor","signCert",{message:e,options:t}),o.request()},signTypedData(e,t,o,i){throw new Error("Sign typed data it is not available with sync2")}});var T="dappkit@vechain",k=`${T}/source`,N=`${T}/account`,M=`${T}/connectionCertificate`,L=`${T}/accountDomain`,oe=n=>{c.debug("LocalStorage","setSource",n),n?localStorage.setItem(k,n):localStorage.removeItem(k)},re=n=>{c.debug("LocalStorage","setAccount",n),n?localStorage.setItem(N,n):localStorage.removeItem(N)},ie=n=>{c.debug("LocalStorage","setAccountDomain",n),n?localStorage.setItem(L,n):localStorage.removeItem(L)},se=n=>{c.debug("LocalStorage","setConnectionCertificate",n),n?localStorage.setItem(M,JSON.stringify(n)):localStorage.removeItem(M)},ce=()=>{let n=localStorage.getItem(k);return n||null},ae=()=>{let n=localStorage.getItem(N);return n||null},le=()=>{let n=localStorage.getItem(L);return n||null},de=()=>{let n=localStorage.getItem(M);return n?JSON.parse(n):null},f={setAccount:re,setSource:oe,setConnectionCertificate:se,setAccountDomain:ie,getAccountDomain:le,getAccount:ae,getSource:ce,getConnectionCertificate:de};var D={purpose:"identification",payload:{type:"text",content:`The following dApp would like to see your public address: ${typeof window<"u"?window.origin:""}`}};var m={main:{number:0,id:"0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",size:170,parentID:"0xffffffff53616c757465202620526573706563742c20457468657265756d2100",timestamp:1530316800,gasLimit:1e7,beneficiary:"0x0000000000000000000000000000000000000000",gasUsed:0,totalScore:0,txsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",txsFeatures:0,stateRoot:"0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",receiptsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",signer:"0x0000000000000000000000000000000000000000",isTrunk:!0,transactions:[]},test:{number:0,id:"0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",size:170,parentID:"0xffffffff00000000000000000000000000000000000000000000000000000000",timestamp:1530014400,gasLimit:1e7,beneficiary:"0x0000000000000000000000000000000000000000",gasUsed:0,totalScore:0,txsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",txsFeatures:0,stateRoot:"0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",receiptsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",signer:"0x0000000000000000000000000000000000000000",isTrunk:!0,transactions:[]}};var V={requiresCertificate:!0},K={"wallet-connect":{requiresCertificate:!1},veworld:V,sync2:V,sync:V},W=Object.keys(K);Object.freeze(K);Object.freeze(W);var P=(o=>(o.RequestTransaction="thor_sendTransaction",o.SignCertificate="thor_signCertificate",o.SignTypedData="thor_signTypedData",o))(P||{});var $=n=>n?n==="main"||n==="test"?m[n].id:n.id:m.main.id,B=n=>n?n==="main"||n==="test"?m[n]:n:m.main;import*as F from"@vechain/connex";import{Certificate as pe}from"@vechain/sdk-core";var h=class{constructor(e,t){this.wallet=e;this.connectionCertificateData=t;this.connect=async()=>{let e=this.connectionCertificateData?.message||D,t=this.connectionCertificateData?.options||{},{annex:{domain:o,signer:i,timestamp:r},signature:a}=await this.signCert(e,t),p={...e,signature:a,signer:i,domain:o,timestamp:r};try{return pe.of(p).verify(),{account:i,verified:!0,connectionCertificate:p}}catch(u){return console.error("Failed to verify connection certificate",u),{account:i,verified:!1}}};this.signCert=(e,t)=>this.wallet.signCert(e,t);this.signTx=(e,t)=>this.wallet.signTx(e,t);this.signTypedData=(e,t,o,i)=>this.wallet.signTypedData(e,t,o,i);this.disconnect=async()=>this.wallet.disconnect?.()}};var A=class{constructor(e){this.signer=e;this.connect=async()=>({account:await this.signer.connect(),verified:!1});this.signCert=(e,t)=>this.signer.signCert(e,t);this.signTx=(e,t)=>this.signer.signTx(e,t);this.signTypedData=async(e,t,o,i)=>this.signer.signTypedData(e,t,o,i);this.disconnect=()=>this.signer.disconnect()}};import{SignClient as ge}from"@walletconnect/sign-client";var U={},q=({projectId:n,metadata:e})=>{let t=U[n];if(t)return t;let o=ge.init({projectId:n,metadata:e}),i={get:async()=>{try{return await o}catch(r){throw console.error("Failed to initialise the wallet connect sign client",r),new Error("Failed to initialise the wallet connect sign client")}}};return U[n]=i,i};import{WalletConnectModal as ue}from"@walletconnect/modal";var G={},fe=["0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a","0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127"],me=fe.map(n=>`vechain:${n.slice(-32)}`),z=n=>{let e=G[n];if(e)return e;let t=new ue({projectId:n,explorerRecommendedWalletIds:"NONE",mobileWallets:[{name:"VeWorld",id:"veworld-mobile",links:{native:"veworld://org.vechain.veworld.app/",universal:"https://veworld.com"}}],chains:me,themeVariables:{"--wcm-z-index":"99999999"},walletImages:{"veworld-mobile":"https://www.veworld.net/assets/logo/logo.svg"}});return G[n]=t,t};import{getSdkError as Ce}from"@walletconnect/utils";var Y=({genesisId:n,wcClient:e,web3Modal:t,onDisconnected:o})=>{let i=`vechain:${n.slice(-32)}`,r;e.get().then(s=>{a(s),p(s)}).catch(()=>{throw new Error("Failed to get the wallet connect sign client")}),window&&(window.onfocus=async()=>{r&&await(await e.get()).ping({topic:r.topic})});let a=s=>{s.on("session_update",({topic:l,params:d})=>{c.debug("wallet connect signer","session_update",{topic:l,params:d});let{namespaces:g}=d;r={...s.session.get(l),namespaces:g}}),s.on("session_delete",()=>{o(),_().catch(()=>{throw new Error("Failed to disconnect")})})},p=s=>{if(typeof r<"u")return;c.debug("wallet connect signer","restore session");let l=s.session.keys;for(let d of l){let g=s.session.get(d),v=g.namespaces.vechain.accounts;for(let b of v)if(b.split(":")[1]===n.slice(-32)){r=g;return}}},u=s=>{if(!r)return;c.debug("wallet connect signer","validate session");let l=r.namespaces.vechain.accounts[0],d=l.split(":")[2],g=l.split(":")[1];if(g===n.slice(-32)&&!(s&&s.toLowerCase()!==d.toLowerCase()))return{address:d,networkIdentifier:g,topic:r.topic}},S=async()=>{c.debug("wallet connect signer","connect");let s=await e.get(),l={methods:Object.values(P),chains:[i],events:[]};try{let d={vechain:l},g=await s.connect({requiredNamespaces:d});return g.uri&&await t.openModal({uri:g.uri}),await new Promise((v,b)=>{let I=t.subscribeModal(C=>{C.open||(b(new Error("User closed modal while connecting")),I())});g.approval().then(C=>{r=C,I(),v(C)}).catch(C=>{t.closeModal(),b(C)})})}catch(d){throw console.error("wc connect failed",d),new Error("wc connect failed")}},E=async s=>{let l=u(s);return l?l.topic:(await S()).topic},x=async(s,l)=>{let d=await E(l);return(await e.get()).request({topic:d,chainId:i,request:s})},ee=async(s,l)=>x({method:"thor_sendTransaction",params:[{message:s,options:l}]}),te=async(s,l)=>x({method:"thor_signCertificate",params:[{message:s,options:l}]}),ne=async(s,l,d,g)=>x({method:"thor_signTypedData",params:[{domain:s,types:l,value:d,options:g}]}),_=async()=>{if(!r)return;let s=r.topic;r=void 0;let l=await e.get();try{await l.disconnect({topic:s,reason:Ce("USER_DISCONNECTED")})}catch(d){throw console.error("SignClient.disconnect failed",d),new Error("SignClient.disconnect failed")}};return{signTx:ee,signCert:te,signTypedData:ne,disconnect:_,genesisId:n,connect:async()=>{r||(r=await S());let s=r.namespaces.vechain;if(!s)throw new Error("Failed to create a vechain session with wallet connect");let l=s.accounts[0];try{return l.split(":")[2]}catch(d){throw console.error("Failed to get account from session",d),new Error("Failed to get account from session")}}}};var H=({source:n,genesis:e,walletConnectOptions:t,onDisconnected:o,connectionCertificate:i})=>{let r=$(e);switch(c.debug("createWallet",n),n){case"sync":{if(!window.connex)throw new Error("User is not in a Sync wallet");let a=new F.Connex.Vendor(r,"sync");return new h(O(a),i)}case"sync2":{let a=new F.Connex.Vendor(r,"sync2");return new h(O(a),i)}case"veworld":{if(!window.vechain)throw new Error("VeWorld Extension is not installed");let a=window.vechain.newConnexSigner(r);return new h(a,i)}case"wallet-connect":{if(!t)throw new Error("WalletConnect options are not provided");let{projectId:a,metadata:p,modal:u}=t,S=q({projectId:a,metadata:p}),E=u??z(a),x=Y({genesisId:r,wcClient:S,web3Modal:E,onDisconnected:o});return new A(x)}}};var gt=(n,e=10,t=7)=>n.length>e+t+1?`${n.slice(0,e)}\u2026${n.slice(-t)}`:n;import{Framework as we}from"@vechain/connex-framework";var J={main:"0xA11413086e163e41901bb81fdc5617c975Fa5a1A",test:"0xc403b8EA53F707d7d4de095f0A20bC491Cf2bc94"},he={inputs:[{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getNames",outputs:[{internalType:"string[]",name:"names",type:"string[]"}],stateMutability:"view",type:"function"},X=async({address:n,driver:e})=>{if(!n)return null;let t=new we(e),o=e.genesis.id===m.test.id?J.test:J.main,i=await t.thor.account(o).method(he).call([n]),{decoded:{names:r}}=i;return r?.[0]||null};var R=class{constructor(e,t){this.options=e;this.driver=t;this.wallets={};this.setAccountDomain=e=>{e?(this.state.isAccountDomainLoading=!0,X({address:e,driver:this.driver}).then(t=>{this.state.accountDomain=t}).catch(t=>{console.error("Error getting account domain",t),this.state.accountDomain=null}).finally(()=>{this.state.isAccountDomainLoading=!1})):(this.state.accountDomain=null,this.state.isAccountDomainLoading=!1)};this.setAddress=e=>{this.state.address=e};this.setAddressAndDomain=e=>{this.setAddress(e),this.setAccountDomain(e)};this.signConnectionCertificate=async()=>{let e=this.options.connectionCertificate?.message||D,t=this.options.connectionCertificate?.options||{},{annex:{domain:o,signer:i,timestamp:r},signature:a}=await this.wallet.signCert(e,t),p={...e,signature:a,signer:i,domain:o,timestamp:r};try{return Se.of(p).verify(),this.setAddressAndDomain(i),this.state.connectionCertificate=p,{account:i,verified:!0,connectionCertificate:p}}catch(u){return console.error("Failed to sign connection certificate",u),{account:i,verified:!1}}finally{this.options.walletConnectOptions?.modal?.onConnectionCertificateSigned?.()}};this.connect=()=>this.wallet.connect().then(e=>(this.state.source==="wallet-connect"&&this.options.requireCertificate&&this.options.walletConnectOptions?.modal?.askForConnectionCertificate?this.options.walletConnectOptions.modal.askForConnectionCertificate():(this.setAddressAndDomain(e.account),this.state.connectionCertificate=e.connectionCertificate??null),e)).catch(e=>{throw c.error("WalletManager","connect",e),e});this.disconnect=(e=!1)=>{if(!this.state.source){this.state.source=null,this.setAddressAndDomain(null),this.state.connectionCertificate=null;return}c.debug("WalletManager","disconnect","current source",this.state.source);let t=this.wallets[this.state.source];if(t&&!e&&t.disconnect){let o=t.disconnect();o instanceof Promise&&o.catch(i=>{c.error("WalletManager","disconnect",i)})}this.state.source=null,this.setAddressAndDomain(null),this.state.connectionCertificate=null};this.signTx=(e,t)=>this.wallet.signTx(e,t).catch(o=>{throw c.error("WalletManager","signTx",o),o});this.signCert=(e,t)=>this.wallet.signCert(e,t).catch(o=>{throw c.error("WalletManager","signCert",o),o});this.signTypedData=(e,t,o,i)=>this.wallet.signTypedData(e,t,o,i).catch(r=>{throw c.error("WalletManager","signTypedData",r),r});this.setSource=e=>{if(this.state.source!==e){if(this.state.source&&this.state.source!==e&&this.disconnect(),e==="wallet-connect"&&!this.options.walletConnectOptions)throw new Error("WalletConnect options are not provided");if(e==="veworld"&&!window.vechain)throw new Error("VeWorld Extension is not installed");if(e==="sync"&&!window.connex)throw new Error("User is not in a Sync wallet");c.debug("WalletManager","setSource",e),this.disconnect(),this.state.source=e}};this.subscribe=e=>xe(this.state,()=>{e(this.state)});this.subscribeToKey=(e,t)=>ye(this.state,e,o=>{t(o)});this.initState=e=>{let t=this.getAvailableSources();if(!e)return j({source:null,address:null,accountDomain:null,isAccountDomainLoading:!1,availableSources:t,connectionCertificate:null});let o=f.getAccount(),i=f.getAccountDomain(),r=f.getSource(),a=f.getConnectionCertificate();return j({source:r,address:o,accountDomain:i,isAccountDomainLoading:!1,availableSources:t,connectionCertificate:a})};this.initPersistence=e=>{e&&(this.subscribeToKey("address",f.setAccount),this.subscribeToKey("accountDomain",f.setAccountDomain),this.subscribeToKey("source",f.setSource),this.subscribeToKey("connectionCertificate",f.setConnectionCertificate))};this.getAvailableSources=()=>{let e=W,t=this.options.allowedWallets??e,o=[];return t.includes("veworld")&&o.push("veworld"),this.options.walletConnectOptions&&t.includes("wallet-connect")&&o.push("wallet-connect"),t.includes("sync2")&&o.push("sync2"),window.connex&&t.includes("sync")&&o.push("sync"),o};this.setFirstDetectedSource=()=>{window.vechain?this.setSource("veworld"):this.options.walletConnectOptions?this.setSource("wallet-connect"):window.connex?this.setSource("sync"):this.setSource("sync2")};this.state=this.initState(e.usePersistence??!1),this.initPersistence(e.usePersistence??!1),c.debug("WalletManager","constructor",this.state),window.vechain?.isInAppBrowser===!0?this.setSource("veworld"):e.useFirstDetectedSource&&this.setFirstDetectedSource()}get wallet(){let e=this.state.source;if(c.debug("WalletManager","get wallet","current source",e),!e)throw new Error("No wallet has been selected");let t=this.wallets[e];if(!t){if(!W.includes(e))throw new Error(`No wallet found for: ${e}`);c.debug("WalletManager","get wallet","creating a new wallet",e);let o={...this.options,source:e,onDisconnected:()=>this.disconnect(!0)};t=H(o),this.wallets[e]=t}return t}};var Q={},Ae=(n,e,t)=>{let o=JSON.stringify({node:n,genesis:e}),i=new TextEncoder().encode(o.normalize()),r=We.of(De(i,"hex")).digits,a=Q[r];return a||(a=new ve(t,e),Q[r]=a),a},Z=class{constructor(e){e.logLevel&&(c.configure(e.logLevel),c.debug("DAppKit","constructor",e));let{nodeUrl:t,genesis:o}=e,i=B(o),r=e.customNet||new be(t),a=Ae(t,i,r),p=new R(e,a);a.signTx=p.signTx.bind(p),a.signCert=p.signCert.bind(p);let u=new Te(a);this.thor=u.thor,this.vendor=u.vendor,this.wallet=p}};export{h as CertificateBasedWallet,Z as DAppKit,c as DAppKitLogger,D as DEFAULT_CONNECT_CERT_MESSAGE,P as DefaultMethods,f as Storage,A as WCWallet,R as WalletManager,K as WalletMapping,W as WalletSources,O as convertVendorToSigner,H as createWallet,q as createWcClient,z as createWcModal,Y as createWcSigner,m as genesisBlocks,B as normalizeGenesisBlock,$ as normalizeGenesisId,gt as shortenedDomain};
//# sourceMappingURL=index.js.map