import { ethers as ethers$1 } from 'ethers';
import { DriverNoVendor } from '@vechain/connex-driver';
import { WalletConnectOptions as WalletConnectOptions$1 } from '@vechain/dapp-kit';
import { Certificate } from '@vechain/sdk-core';
import { SignClientTypes } from '@walletconnect/types';
import { SignClient } from '@walletconnect/sign-client';

declare const LogLevel: {
    NONE: number;
    ERROR: number;
    WARN: number;
    INFO: number;
    DEBUG: number;
};
type LogLevel = keyof typeof LogLevel;
declare const DAppKitLogger: {
    configure(level: LogLevel): void;
    debug(domain: string, context: string, ...args: unknown[]): void;
    info(domain: string, context: string, ...args: unknown[]): void;
    warn(domain: string, context: string, ...args: unknown[]): void;
    error(domain: string, context: string, ...args: unknown[]): void;
};

declare const convertVendorToSigner: (vendor: Connex.Vendor) => ExpandedConnexSigner;

type ResolvedSignClient = Awaited<ReturnType<typeof SignClient.init>>;

/**
 * WCSigner is a {@link Connex.Signer} with an additional disconnect method
 *
 */
type WCSigner = ExpandedConnexSigner & {
    /**
     * Disconnects and cleans up the WalletConnect session
     */
    disconnect: () => Promise<void>;

    /**
     * The genesis ID of the current signer
     */
    genesisId: string;

    /**
     * Connects to the Wallet and return the account address
     */
    connect: () => Promise<string>;
};

interface WCClient {
    /**
     * Gets the initialized WalletConnect SignClient
     */
    get: () => Promise<ResolvedSignClient>;
}

/**
 * WCModal is a modal that can be used to display a WalletConnect QR code/ URI
 * @param openModal - A function to open the modal
 * @param closeModal - A function to close the modal
 * @param subscribeModal - A function to subscribe to modal state changes
 */
interface WCModal {
    openModal: (options: OpenOptions) => Promise<void>;
    closeModal: () => void;
    subscribeModal: (
        callback: (newState: SubscribeModalState) => void,
    ) => () => void;
    askForConnectionCertificate?: () => void;
    onConnectionCertificateSigned?: () => void;
}

/**
 * Options for the createWcClient function
 * @param projectId - Your WalletConnect project ID
 * @param relayUrl - The URL of your WalletConnect relay server
 * @param metadata - The metadata of your WalletConnect dApp
 * @param logger - The logger or log level to use
 * @param modal - {@link WCModal} can be used to provide a custom modal
 */
interface WalletConnectOptions {
    projectId: string;
    metadata: SignClientTypes.Options['metadata'];
    modal?: WCModal;
}

/**
 * Options for the {@link WCModal}
 * @param open - Whether the modal is open
 */
interface SubscribeModalState {
    open: boolean;
}

/**
 * Options for opening the {@link WCModal}
 * @param uri - The WalletConnect URI to display / open
 */
interface OpenOptions {
    uri: string;
}

/**
 * Options for the {@link WCSigner}
 * @param wcClient - See {@link WCClient}
 * @param web3Modal - See {@link WCModal}
 * @param onDisconnected - (optional) A callback that will be called when the session is disconnected
 * @param genesisId - The genesis ID of the VeChain network you want to connect to
 */
interface WCSignerOptions {
    wcClient: WCClient;
    web3Modal: WCModal;
    onDisconnected: () => void;
    genesisId: string;
}

declare const Storage: {
    setAccount: (account: string | null) => void;
    setSource: (source: WalletSource | null) => void;
    setConnectionCertificate: (certificate: Certificate | null) => void;
    setAccountDomain: (domain: string | null) => void;
    getAccountDomain: () => string | null;
    getAccount: () => string | null;
    getSource: () => WalletSource | null;
    getConnectionCertificate: () => Certificate | null;
};

declare const normalizeGenesisId: (genesis?: Genesis) => string;
declare const normalizeGenesisBlock: (genesis?: Genesis) => Connex.Thor.Block;

type ICreateWallet = DAppKitOptions & {
    source: WalletSource;
    onDisconnected: () => void;
};
declare const createWallet: ({ source, genesis, walletConnectOptions, onDisconnected, connectionCertificate, }: ICreateWallet) => ConnexWallet;

/**
 * Create a new wallet connect sign client. Clients are cached by project id.
 * @param projectId - wallet connect dApp project id
 * @param metadata - dApp metadata
 */
declare const createWcClient: ({ projectId, metadata, }: WalletConnectOptions) => WCClient;

/**
 * Creates a new WalletConnect signer
 * @param options - The signer options. See {@link WCSignerOptions}
 * @returns A new {@link WCSigner}
 */
declare const createWcSigner: ({ genesisId, wcClient, web3Modal, onDisconnected, }: WCSignerOptions) => WCSigner;

/**
 * Creates a new WalletConnectModal instance
 * @param projectId - Your WalletConnect project ID
 */
declare const createWcModal: (projectId: string) => WCModal;

/**
 * If a domain name is longer than 18 characters, it shortens it to 10 leading characters and 7 trailing characters.
 * @param domain - The domain name to shorten.
 * @returns The shortened domain name.
 */
declare const shortenedDomain: (domain: string, leadingChars?: number, trailingChars?: number) => string;

declare global {
    interface Window {
        vechain?: {
            newConnexSigner: (genesisId: string) => ExpandedConnexSigner;
            isInAppBrowser?: boolean;
        };
        connex?: unknown;
    }
}

interface ExpandedConnexSigner extends Connex.Signer {
    signTypedData: (
        _domain: ethers.TypedDataDomain,
        _types: Record<string, ethers.TypedDataField[]>,
        _value: Record<string, unknown>,
        _options?: SignTypedDataOptions,
    ) => Promise<string>;
}

type WalletSource = 'wallet-connect' | 'veworld' | 'sync2' | 'sync';

interface WalletConfig {
    requiresCertificate: boolean;
}

type Genesis = 'main' | 'test' | Connex.Thor.Block;

/**
 * Options for the DAppKit class
 * @param nodeUrl - The URL of the VeChain node to connect to
 * @param genesis - Optional. The genesis block of the VeChain network you want to connect to. Eg, 'main', 'test', or a Connex.Thor.Block object
 * @param onDisconnected - A callback that will be called when the session is disconnected
 * @param walletConnectOptions - Optional. Options for the WalletConnect integration
 * @param usePersistence - Optional. Whether to persist the wallet source/ account
 * @param useFirstDetectedSource - Optional. Whether to use the first detected wallet source. Defaults to false
 * @param logLevel - Optional. The log level to use for the DAppKitUI logger
 */
interface DAppKitOptions {
    nodeUrl: string;
    genesis?: Genesis;
    walletConnectOptions?: WalletConnectOptions$1;
    usePersistence?: boolean;
    useFirstDetectedSource?: boolean;
    logLevel?: LogLevel;
    requireCertificate?: boolean;
    connectionCertificate?: {
        message?: Connex.Vendor.CertMessage;
        options?: Connex.Signer.CertOptions;
    };
}

type BaseWallet = ExpandedConnexSigner & {
    disconnect?: () => Promise<void> | void;
};

/**
 * Modifies the Connex.Signer interface to include a disconnect method
 */
type ConnexWallet = BaseWallet & {
    connect: () => Promise<ConnectResponse>;
};

interface ConnectResponse {
    account: string;
    verified: boolean;
    connectionCertificate?: Certificate;
}

interface WalletManagerState {
    source: WalletSource | null;
    address: string | null;
    accountDomain: string | null;
    isAccountDomainLoading: boolean;
    availableSources: WalletSource[];
    connectionCertificate: Certificate | null;
}

interface SignTypedDataOptions {
    signer?: string;
}

declare class WalletManager {
    private readonly options;
    private readonly driver;
    readonly state: WalletManagerState;
    private wallets;
    constructor(options: DAppKitOptions, driver: DriverNoVendor);
    private get wallet();
    /**
     * Set the account domain
     */
    setAccountDomain: (address: string | null) => void;
    /**
     * Set the address
     */
    setAddress: (address: string | null) => void;
    /**
     * Set the address and check for the vechain domain, if present set it as well
     */
    setAddressAndDomain: (address: string | null) => void;
    /**
     * Sign a connection certificate
     * this is needed for wallet connect connections when a connection certificate is required
     */
    signConnectionCertificate: () => Promise<ConnectResponse>;
    connect: () => Promise<ConnectResponse>;
    disconnect: (remote?: boolean) => void;
    signTx: (msg: Connex.Vendor.TxMessage, options: Connex.Signer.TxOptions) => Promise<Connex.Vendor.TxResponse>;
    signCert: (msg: Connex.Vendor.CertMessage, options: Connex.Signer.CertOptions) => Promise<Connex.Vendor.CertResponse>;
    signTypedData: (domain: ethers$1.TypedDataDomain, types: Record<string, ethers$1.TypedDataField[]>, value: Record<string, unknown>, options?: SignTypedDataOptions) => Promise<string>;
    setSource: (src: WalletSource) => void;
    subscribe: (listener: (state: WalletManagerState) => void) => (() => void);
    subscribeToKey: <T extends keyof WalletManagerState>(key: T, listener: (value: WalletManagerState[T]) => void) => (() => void);
    private initState;
    private initPersistence;
    private getAvailableSources;
    private setFirstDetectedSource;
}

/**
 * A `ConnexWallet` for wallet's that use a certificate connection
 */
declare class CertificateBasedWallet implements ConnexWallet {
    private readonly wallet;
    private readonly connectionCertificateData?;
    constructor(wallet: BaseWallet, connectionCertificateData?: {
        message?: Connex.Vendor.CertMessage;
        options?: Connex.Signer.CertOptions;
    } | undefined);
    connect: () => Promise<ConnectResponse>;
    signCert: (msg: Connex.Vendor.CertMessage, options: Connex.Signer.CertOptions) => Promise<Connex.Vendor.CertResponse>;
    signTx: (msg: Connex.Vendor.TxMessage, options: Connex.Signer.TxOptions) => Promise<Connex.Vendor.TxResponse>;
    signTypedData: (_domain: ethers$1.TypedDataDomain, _types: Record<string, ethers$1.TypedDataField[]>, _value: Record<string, unknown>, _options?: SignTypedDataOptions) => Promise<string>;
    disconnect: () => Promise<void>;
}

declare class WCWallet implements ConnexWallet {
    private readonly signer;
    constructor(signer: WCSigner);
    connect: () => Promise<ConnectResponse>;
    signCert: (msg: Connex.Vendor.CertMessage, options: Connex.Signer.CertOptions) => Promise<Connex.Vendor.CertResponse>;
    signTx: (msg: Connex.Vendor.TxMessage, options: Connex.Signer.TxOptions) => Promise<Connex.Vendor.TxResponse>;
    signTypedData: (_domain: ethers$1.TypedDataDomain, _types: Record<string, ethers$1.TypedDataField[]>, _value: Record<string, unknown>, _options?: SignTypedDataOptions) => Promise<string>;
    disconnect: () => Promise<void>;
}

declare class DAppKit {
    readonly thor: Connex.Thor;
    readonly vendor: Connex.Vendor;
    readonly wallet: WalletManager;
    constructor(options: DAppKitOptions);
}

declare const DEFAULT_CONNECT_CERT_MESSAGE: Connex.Vendor.CertMessage;

type NetworkType = 'main' | 'test';
declare const genesisBlocks: Record<NetworkType, Connex.Thor.Block>;

/**
 * Wallet types
 */

declare const WalletMapping: Record<WalletSource, WalletConfig>;
declare const WalletSources: WalletSource[];

/**
 * The methods supported by the WalletConnect integration
 * @param RequestTransaction - Request the wallet to send a transaction
 * @param SignCertificate - Request the wallet to sign a certificate
 */
declare enum DefaultMethods {
    RequestTransaction = "thor_sendTransaction",
    SignCertificate = "thor_signCertificate",
    SignTypedData = "thor_signTypedData"
}

export { type BaseWallet, CertificateBasedWallet, type ConnectResponse, type ConnexWallet, DAppKit, DAppKitLogger, type DAppKitOptions, DEFAULT_CONNECT_CERT_MESSAGE, DefaultMethods, type Genesis, LogLevel, type OpenOptions, type ResolvedSignClient, Storage, type SubscribeModalState, type WCClient, type WCModal, type WCSigner, type WCSignerOptions, WCWallet, type WalletConfig, type WalletConnectOptions, WalletManager, type WalletManagerState, WalletMapping, type WalletSource, WalletSources, convertVendorToSigner, createWallet, createWcClient, createWcModal, createWcSigner, genesisBlocks, normalizeGenesisBlock, normalizeGenesisId, shortenedDomain };
